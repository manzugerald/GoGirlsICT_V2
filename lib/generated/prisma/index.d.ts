
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model HomePage
 * 
 */
export type HomePage = $Result.DefaultSelection<Prisma.$HomePagePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordHistory
 * 
 */
export type PasswordHistory = $Result.DefaultSelection<Prisma.$PasswordHistoryPayload>
/**
 * Model PasswordChangeLog
 * 
 */
export type PasswordChangeLog = $Result.DefaultSelection<Prisma.$PasswordChangeLogPayload>
/**
 * Model FailedLoginAttempt
 * 
 */
export type FailedLoginAttempt = $Result.DefaultSelection<Prisma.$FailedLoginAttemptPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model YouTubeCacheMeta
 * 
 */
export type YouTubeCacheMeta = $Result.DefaultSelection<Prisma.$YouTubeCacheMetaPayload>
/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Beneficiary
 * 
 */
export type Beneficiary = $Result.DefaultSelection<Prisma.$BeneficiaryPayload>
/**
 * Model Response
 * 
 */
export type Response = $Result.DefaultSelection<Prisma.$ResponsePayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model FacebookPost
 * 
 */
export type FacebookPost = $Result.DefaultSelection<Prisma.$FacebookPostPayload>
/**
 * Model FacebookCacheMeta
 * 
 */
export type FacebookCacheMeta = $Result.DefaultSelection<Prisma.$FacebookCacheMetaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MessageCategory: {
  beneficiary: 'beneficiary',
  request: 'request',
  system: 'system',
  external: 'external',
  go_girls_ict_team: 'go_girls_ict_team',
  testimonial: 'testimonial'
};

export type MessageCategory = (typeof MessageCategory)[keyof typeof MessageCategory]


export const Role: {
  super: 'super',
  admin: 'admin',
  moderator: 'moderator',
  beneficiary: 'beneficiary',
  guest: 'guest'
};

export type Role = (typeof Role)[keyof typeof Role]


export const LoginStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type LoginStatus = (typeof LoginStatus)[keyof typeof LoginStatus]


export const Status: {
  active: 'active',
  completed: 'completed',
  paused: 'paused'
};

export type Status = (typeof Status)[keyof typeof Status]


export const PublishStatus: {
  draft: 'draft',
  published: 'published'
};

export type PublishStatus = (typeof PublishStatus)[keyof typeof PublishStatus]


export const EventStatus: {
  pending: 'pending',
  ongoing: 'ongoing',
  completed: 'completed',
  paused: 'paused'
};

export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus]


export const AttendanceType: {
  public: 'public',
  registration_required: 'registration_required'
};

export type AttendanceType = (typeof AttendanceType)[keyof typeof AttendanceType]


export const InstitutionType: {
  education: 'education',
  faith_based_organization: 'faith_based_organization',
  local_community: 'local_community',
  ngo: 'ngo',
  government: 'government',
  other: 'other'
};

export type InstitutionType = (typeof InstitutionType)[keyof typeof InstitutionType]


export const GenderType: {
  male: 'male',
  female: 'female'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const ResponderType: {
  user: 'user',
  beneficiary: 'beneficiary',
  system: 'system'
};

export type ResponderType = (typeof ResponderType)[keyof typeof ResponderType]


export const FAQCategory: {
  general: 'general',
  beneficiaries: 'beneficiaries',
  institutions: 'institutions',
  projects: 'projects',
  events: 'events',
  reports: 'reports',
  technnology: 'technnology',
  other: 'other'
};

export type FAQCategory = (typeof FAQCategory)[keyof typeof FAQCategory]

}

export type MessageCategory = $Enums.MessageCategory

export const MessageCategory: typeof $Enums.MessageCategory

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type LoginStatus = $Enums.LoginStatus

export const LoginStatus: typeof $Enums.LoginStatus

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type PublishStatus = $Enums.PublishStatus

export const PublishStatus: typeof $Enums.PublishStatus

export type EventStatus = $Enums.EventStatus

export const EventStatus: typeof $Enums.EventStatus

export type AttendanceType = $Enums.AttendanceType

export const AttendanceType: typeof $Enums.AttendanceType

export type InstitutionType = $Enums.InstitutionType

export const InstitutionType: typeof $Enums.InstitutionType

export type GenderType = $Enums.GenderType

export const GenderType: typeof $Enums.GenderType

export type ResponderType = $Enums.ResponderType

export const ResponderType: typeof $Enums.ResponderType

export type FAQCategory = $Enums.FAQCategory

export const FAQCategory: typeof $Enums.FAQCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Projects
 * const projects = await prisma.project.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Projects
   * const projects = await prisma.project.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homePage`: Exposes CRUD operations for the **HomePage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomePages
    * const homePages = await prisma.homePage.findMany()
    * ```
    */
  get homePage(): Prisma.HomePageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordHistory`: Exposes CRUD operations for the **PasswordHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordHistories
    * const passwordHistories = await prisma.passwordHistory.findMany()
    * ```
    */
  get passwordHistory(): Prisma.PasswordHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordChangeLog`: Exposes CRUD operations for the **PasswordChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordChangeLogs
    * const passwordChangeLogs = await prisma.passwordChangeLog.findMany()
    * ```
    */
  get passwordChangeLog(): Prisma.PasswordChangeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.failedLoginAttempt`: Exposes CRUD operations for the **FailedLoginAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FailedLoginAttempts
    * const failedLoginAttempts = await prisma.failedLoginAttempt.findMany()
    * ```
    */
  get failedLoginAttempt(): Prisma.FailedLoginAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.youTubeCacheMeta`: Exposes CRUD operations for the **YouTubeCacheMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YouTubeCacheMetas
    * const youTubeCacheMetas = await prisma.youTubeCacheMeta.findMany()
    * ```
    */
  get youTubeCacheMeta(): Prisma.YouTubeCacheMetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.beneficiary`: Exposes CRUD operations for the **Beneficiary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beneficiaries
    * const beneficiaries = await prisma.beneficiary.findMany()
    * ```
    */
  get beneficiary(): Prisma.BeneficiaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.response`: Exposes CRUD operations for the **Response** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responses
    * const responses = await prisma.response.findMany()
    * ```
    */
  get response(): Prisma.ResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facebookPost`: Exposes CRUD operations for the **FacebookPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookPosts
    * const facebookPosts = await prisma.facebookPost.findMany()
    * ```
    */
  get facebookPost(): Prisma.FacebookPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facebookCacheMeta`: Exposes CRUD operations for the **FacebookCacheMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookCacheMetas
    * const facebookCacheMetas = await prisma.facebookCacheMeta.findMany()
    * ```
    */
  get facebookCacheMeta(): Prisma.FacebookCacheMetaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Project: 'Project',
    HomePage: 'HomePage',
    Message: 'Message',
    Report: 'Report',
    User: 'User',
    PasswordHistory: 'PasswordHistory',
    PasswordChangeLog: 'PasswordChangeLog',
    FailedLoginAttempt: 'FailedLoginAttempt',
    Session: 'Session',
    Event: 'Event',
    Video: 'Video',
    YouTubeCacheMeta: 'YouTubeCacheMeta',
    Institution: 'Institution',
    Location: 'Location',
    Beneficiary: 'Beneficiary',
    Response: 'Response',
    FAQ: 'FAQ',
    FacebookPost: 'FacebookPost',
    FacebookCacheMeta: 'FacebookCacheMeta'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "project" | "homePage" | "message" | "report" | "user" | "passwordHistory" | "passwordChangeLog" | "failedLoginAttempt" | "session" | "event" | "video" | "youTubeCacheMeta" | "institution" | "location" | "beneficiary" | "response" | "fAQ" | "facebookPost" | "facebookCacheMeta"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      HomePage: {
        payload: Prisma.$HomePagePayload<ExtArgs>
        fields: Prisma.HomePageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomePageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomePageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          findFirst: {
            args: Prisma.HomePageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomePageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          findMany: {
            args: Prisma.HomePageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>[]
          }
          create: {
            args: Prisma.HomePageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          createMany: {
            args: Prisma.HomePageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomePageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>[]
          }
          delete: {
            args: Prisma.HomePageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          update: {
            args: Prisma.HomePageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          deleteMany: {
            args: Prisma.HomePageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomePageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomePageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>[]
          }
          upsert: {
            args: Prisma.HomePageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePagePayload>
          }
          aggregate: {
            args: Prisma.HomePageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomePage>
          }
          groupBy: {
            args: Prisma.HomePageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomePageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomePageCountArgs<ExtArgs>
            result: $Utils.Optional<HomePageCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordHistory: {
        payload: Prisma.$PasswordHistoryPayload<ExtArgs>
        fields: Prisma.PasswordHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findFirst: {
            args: Prisma.PasswordHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          findMany: {
            args: Prisma.PasswordHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          create: {
            args: Prisma.PasswordHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          createMany: {
            args: Prisma.PasswordHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          delete: {
            args: Prisma.PasswordHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          update: {
            args: Prisma.PasswordHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PasswordHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PasswordHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistoryPayload>
          }
          aggregate: {
            args: Prisma.PasswordHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordHistory>
          }
          groupBy: {
            args: Prisma.PasswordHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordChangeLog: {
        payload: Prisma.$PasswordChangeLogPayload<ExtArgs>
        fields: Prisma.PasswordChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          findFirst: {
            args: Prisma.PasswordChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          findMany: {
            args: Prisma.PasswordChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>[]
          }
          create: {
            args: Prisma.PasswordChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          createMany: {
            args: Prisma.PasswordChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>[]
          }
          delete: {
            args: Prisma.PasswordChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          update: {
            args: Prisma.PasswordChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.PasswordChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordChangeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>[]
          }
          upsert: {
            args: Prisma.PasswordChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordChangeLogPayload>
          }
          aggregate: {
            args: Prisma.PasswordChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordChangeLog>
          }
          groupBy: {
            args: Prisma.PasswordChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordChangeLogCountAggregateOutputType> | number
          }
        }
      }
      FailedLoginAttempt: {
        payload: Prisma.$FailedLoginAttemptPayload<ExtArgs>
        fields: Prisma.FailedLoginAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FailedLoginAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FailedLoginAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          findFirst: {
            args: Prisma.FailedLoginAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FailedLoginAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          findMany: {
            args: Prisma.FailedLoginAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>[]
          }
          create: {
            args: Prisma.FailedLoginAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          createMany: {
            args: Prisma.FailedLoginAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FailedLoginAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>[]
          }
          delete: {
            args: Prisma.FailedLoginAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          update: {
            args: Prisma.FailedLoginAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          deleteMany: {
            args: Prisma.FailedLoginAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FailedLoginAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FailedLoginAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>[]
          }
          upsert: {
            args: Prisma.FailedLoginAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedLoginAttemptPayload>
          }
          aggregate: {
            args: Prisma.FailedLoginAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailedLoginAttempt>
          }
          groupBy: {
            args: Prisma.FailedLoginAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<FailedLoginAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.FailedLoginAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<FailedLoginAttemptCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      YouTubeCacheMeta: {
        payload: Prisma.$YouTubeCacheMetaPayload<ExtArgs>
        fields: Prisma.YouTubeCacheMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YouTubeCacheMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YouTubeCacheMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          findFirst: {
            args: Prisma.YouTubeCacheMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YouTubeCacheMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          findMany: {
            args: Prisma.YouTubeCacheMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>[]
          }
          create: {
            args: Prisma.YouTubeCacheMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          createMany: {
            args: Prisma.YouTubeCacheMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YouTubeCacheMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>[]
          }
          delete: {
            args: Prisma.YouTubeCacheMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          update: {
            args: Prisma.YouTubeCacheMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          deleteMany: {
            args: Prisma.YouTubeCacheMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YouTubeCacheMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YouTubeCacheMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>[]
          }
          upsert: {
            args: Prisma.YouTubeCacheMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YouTubeCacheMetaPayload>
          }
          aggregate: {
            args: Prisma.YouTubeCacheMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYouTubeCacheMeta>
          }
          groupBy: {
            args: Prisma.YouTubeCacheMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<YouTubeCacheMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.YouTubeCacheMetaCountArgs<ExtArgs>
            result: $Utils.Optional<YouTubeCacheMetaCountAggregateOutputType> | number
          }
        }
      }
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Beneficiary: {
        payload: Prisma.$BeneficiaryPayload<ExtArgs>
        fields: Prisma.BeneficiaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeneficiaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeneficiaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          findFirst: {
            args: Prisma.BeneficiaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeneficiaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          findMany: {
            args: Prisma.BeneficiaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>[]
          }
          create: {
            args: Prisma.BeneficiaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          createMany: {
            args: Prisma.BeneficiaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BeneficiaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>[]
          }
          delete: {
            args: Prisma.BeneficiaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          update: {
            args: Prisma.BeneficiaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          deleteMany: {
            args: Prisma.BeneficiaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeneficiaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BeneficiaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>[]
          }
          upsert: {
            args: Prisma.BeneficiaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          aggregate: {
            args: Prisma.BeneficiaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeneficiary>
          }
          groupBy: {
            args: Prisma.BeneficiaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeneficiaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BeneficiaryCountArgs<ExtArgs>
            result: $Utils.Optional<BeneficiaryCountAggregateOutputType> | number
          }
        }
      }
      Response: {
        payload: Prisma.$ResponsePayload<ExtArgs>
        fields: Prisma.ResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findFirst: {
            args: Prisma.ResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findMany: {
            args: Prisma.ResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          create: {
            args: Prisma.ResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          createMany: {
            args: Prisma.ResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          delete: {
            args: Prisma.ResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          update: {
            args: Prisma.ResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          deleteMany: {
            args: Prisma.ResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          upsert: {
            args: Prisma.ResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          aggregate: {
            args: Prisma.ResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse>
          }
          groupBy: {
            args: Prisma.ResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseCountArgs<ExtArgs>
            result: $Utils.Optional<ResponseCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      FacebookPost: {
        payload: Prisma.$FacebookPostPayload<ExtArgs>
        fields: Prisma.FacebookPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacebookPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacebookPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          findFirst: {
            args: Prisma.FacebookPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacebookPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          findMany: {
            args: Prisma.FacebookPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>[]
          }
          create: {
            args: Prisma.FacebookPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          createMany: {
            args: Prisma.FacebookPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacebookPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>[]
          }
          delete: {
            args: Prisma.FacebookPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          update: {
            args: Prisma.FacebookPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          deleteMany: {
            args: Prisma.FacebookPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacebookPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacebookPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>[]
          }
          upsert: {
            args: Prisma.FacebookPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookPostPayload>
          }
          aggregate: {
            args: Prisma.FacebookPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacebookPost>
          }
          groupBy: {
            args: Prisma.FacebookPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacebookPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacebookPostCountArgs<ExtArgs>
            result: $Utils.Optional<FacebookPostCountAggregateOutputType> | number
          }
        }
      }
      FacebookCacheMeta: {
        payload: Prisma.$FacebookCacheMetaPayload<ExtArgs>
        fields: Prisma.FacebookCacheMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacebookCacheMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacebookCacheMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          findFirst: {
            args: Prisma.FacebookCacheMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacebookCacheMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          findMany: {
            args: Prisma.FacebookCacheMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>[]
          }
          create: {
            args: Prisma.FacebookCacheMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          createMany: {
            args: Prisma.FacebookCacheMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacebookCacheMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>[]
          }
          delete: {
            args: Prisma.FacebookCacheMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          update: {
            args: Prisma.FacebookCacheMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          deleteMany: {
            args: Prisma.FacebookCacheMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacebookCacheMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacebookCacheMetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>[]
          }
          upsert: {
            args: Prisma.FacebookCacheMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacebookCacheMetaPayload>
          }
          aggregate: {
            args: Prisma.FacebookCacheMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacebookCacheMeta>
          }
          groupBy: {
            args: Prisma.FacebookCacheMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacebookCacheMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacebookCacheMetaCountArgs<ExtArgs>
            result: $Utils.Optional<FacebookCacheMetaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    project?: ProjectOmit
    homePage?: HomePageOmit
    message?: MessageOmit
    report?: ReportOmit
    user?: UserOmit
    passwordHistory?: PasswordHistoryOmit
    passwordChangeLog?: PasswordChangeLogOmit
    failedLoginAttempt?: FailedLoginAttemptOmit
    session?: SessionOmit
    event?: EventOmit
    video?: VideoOmit
    youTubeCacheMeta?: YouTubeCacheMetaOmit
    institution?: InstitutionOmit
    location?: LocationOmit
    beneficiary?: BeneficiaryOmit
    response?: ResponseOmit
    fAQ?: FAQOmit
    facebookPost?: FacebookPostOmit
    facebookCacheMeta?: FacebookCacheMetaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    reports: number
    events: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ProjectCountOutputTypeCountReportsArgs
    events?: boolean | ProjectCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    responses: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | MessageCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    events: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | ReportCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    passwordHistory: number
    passwordChangeLog: number
    failedLogins: number
    sessions: number
    approvedMessages: number
    createdMessages: number
    updatedMessages: number
    responses: number
    approvedProjects: number
    createdProjects: number
    updatedProjects: number
    approvedReports: number
    createdReports: number
    updatedReports: number
    createdEvents: number
    updatedEvents: number
    createdBeneficiaries: number
    updatedBeneficiaries: number
    approvedBeneficiaries: number
    createdInstitutions: number
    updatedInstitutions: number
    approvedInstitutions: number
    createdFaqs: number
    updatedFaqs: number
    approvedFaqs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordHistory?: boolean | UserCountOutputTypeCountPasswordHistoryArgs
    passwordChangeLog?: boolean | UserCountOutputTypeCountPasswordChangeLogArgs
    failedLogins?: boolean | UserCountOutputTypeCountFailedLoginsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    approvedMessages?: boolean | UserCountOutputTypeCountApprovedMessagesArgs
    createdMessages?: boolean | UserCountOutputTypeCountCreatedMessagesArgs
    updatedMessages?: boolean | UserCountOutputTypeCountUpdatedMessagesArgs
    responses?: boolean | UserCountOutputTypeCountResponsesArgs
    approvedProjects?: boolean | UserCountOutputTypeCountApprovedProjectsArgs
    createdProjects?: boolean | UserCountOutputTypeCountCreatedProjectsArgs
    updatedProjects?: boolean | UserCountOutputTypeCountUpdatedProjectsArgs
    approvedReports?: boolean | UserCountOutputTypeCountApprovedReportsArgs
    createdReports?: boolean | UserCountOutputTypeCountCreatedReportsArgs
    updatedReports?: boolean | UserCountOutputTypeCountUpdatedReportsArgs
    createdEvents?: boolean | UserCountOutputTypeCountCreatedEventsArgs
    updatedEvents?: boolean | UserCountOutputTypeCountUpdatedEventsArgs
    createdBeneficiaries?: boolean | UserCountOutputTypeCountCreatedBeneficiariesArgs
    updatedBeneficiaries?: boolean | UserCountOutputTypeCountUpdatedBeneficiariesArgs
    approvedBeneficiaries?: boolean | UserCountOutputTypeCountApprovedBeneficiariesArgs
    createdInstitutions?: boolean | UserCountOutputTypeCountCreatedInstitutionsArgs
    updatedInstitutions?: boolean | UserCountOutputTypeCountUpdatedInstitutionsArgs
    approvedInstitutions?: boolean | UserCountOutputTypeCountApprovedInstitutionsArgs
    createdFaqs?: boolean | UserCountOutputTypeCountCreatedFaqsArgs
    updatedFaqs?: boolean | UserCountOutputTypeCountUpdatedFaqsArgs
    approvedFaqs?: boolean | UserCountOutputTypeCountApprovedFaqsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFailedLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FailedLoginAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
  }


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    locations: number
    beneficiaries: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | InstitutionCountOutputTypeCountLocationsArgs
    beneficiaries?: boolean | InstitutionCountOutputTypeCountBeneficiariesArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }


  /**
   * Count Type BeneficiaryCountOutputType
   */

  export type BeneficiaryCountOutputType = {
    messages: number
    responses: number
  }

  export type BeneficiaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | BeneficiaryCountOutputTypeCountMessagesArgs
    responses?: boolean | BeneficiaryCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeneficiaryCountOutputType
     */
    select?: BeneficiaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    projectStatus: $Enums.Status | null
    publishStatus: $Enums.PublishStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    projectStatus: $Enums.Status | null
    publishStatus: $Enums.PublishStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    images: number
    projectStatus: number
    publishStatus: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    approvedById: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    projectStatus?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    projectStatus?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    images?: true
    projectStatus?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    title: string
    slug: string
    content: JsonValue
    images: string[]
    projectStatus: $Enums.Status
    publishStatus: $Enums.PublishStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string | null
    approvedById: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    images?: boolean
    projectStatus?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
    reports?: boolean | Project$reportsArgs<ExtArgs>
    events?: boolean | Project$eventsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    images?: boolean
    projectStatus?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    images?: boolean
    projectStatus?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    images?: boolean
    projectStatus?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "images" | "projectStatus" | "publishStatus" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "approvedById", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
    reports?: boolean | Project$reportsArgs<ExtArgs>
    events?: boolean | Project$eventsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Project$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Project$updatedByArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      reports: Prisma.$ReportPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      content: Prisma.JsonValue
      images: string[]
      projectStatus: $Enums.Status
      publishStatus: $Enums.PublishStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string | null
      approvedById: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvedBy<T extends Project$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Project$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Project$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Project$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reports<T extends Project$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Project$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Project$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Project$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly title: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly content: FieldRef<"Project", 'Json'>
    readonly images: FieldRef<"Project", 'String[]'>
    readonly projectStatus: FieldRef<"Project", 'Status'>
    readonly publishStatus: FieldRef<"Project", 'PublishStatus'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly createdById: FieldRef<"Project", 'String'>
    readonly updatedById: FieldRef<"Project", 'String'>
    readonly approvedById: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.approvedBy
   */
  export type Project$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.updatedBy
   */
  export type Project$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.reports
   */
  export type Project$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Project.events
   */
  export type Project$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model HomePage
   */

  export type AggregateHomePage = {
    _count: HomePageCountAggregateOutputType | null
    _avg: HomePageAvgAggregateOutputType | null
    _sum: HomePageSumAggregateOutputType | null
    _min: HomePageMinAggregateOutputType | null
    _max: HomePageMaxAggregateOutputType | null
  }

  export type HomePageAvgAggregateOutputType = {
    id: number | null
  }

  export type HomePageSumAggregateOutputType = {
    id: number | null
  }

  export type HomePageMinAggregateOutputType = {
    id: number | null
    heroVideo: string | null
    vision: string | null
    mission: string | null
    focus: string | null
    coreValues: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageMaxAggregateOutputType = {
    id: number | null
    heroVideo: string | null
    vision: string | null
    mission: string | null
    focus: string | null
    coreValues: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageCountAggregateOutputType = {
    id: number
    heroVideo: number
    vision: number
    mission: number
    focus: number
    coreValues: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HomePageAvgAggregateInputType = {
    id?: true
  }

  export type HomePageSumAggregateInputType = {
    id?: true
  }

  export type HomePageMinAggregateInputType = {
    id?: true
    heroVideo?: true
    vision?: true
    mission?: true
    focus?: true
    coreValues?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageMaxAggregateInputType = {
    id?: true
    heroVideo?: true
    vision?: true
    mission?: true
    focus?: true
    coreValues?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageCountAggregateInputType = {
    id?: true
    heroVideo?: true
    vision?: true
    mission?: true
    focus?: true
    coreValues?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HomePageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePage to aggregate.
     */
    where?: HomePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePages to fetch.
     */
    orderBy?: HomePageOrderByWithRelationInput | HomePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomePages
    **/
    _count?: true | HomePageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomePageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomePageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomePageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomePageMaxAggregateInputType
  }

  export type GetHomePageAggregateType<T extends HomePageAggregateArgs> = {
        [P in keyof T & keyof AggregateHomePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomePage[P]>
      : GetScalarType<T[P], AggregateHomePage[P]>
  }




  export type HomePageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageWhereInput
    orderBy?: HomePageOrderByWithAggregationInput | HomePageOrderByWithAggregationInput[]
    by: HomePageScalarFieldEnum[] | HomePageScalarFieldEnum
    having?: HomePageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomePageCountAggregateInputType | true
    _avg?: HomePageAvgAggregateInputType
    _sum?: HomePageSumAggregateInputType
    _min?: HomePageMinAggregateInputType
    _max?: HomePageMaxAggregateInputType
  }

  export type HomePageGroupByOutputType = {
    id: number
    heroVideo: string
    vision: string
    mission: string
    focus: string
    coreValues: string
    createdAt: Date
    updatedAt: Date
    _count: HomePageCountAggregateOutputType | null
    _avg: HomePageAvgAggregateOutputType | null
    _sum: HomePageSumAggregateOutputType | null
    _min: HomePageMinAggregateOutputType | null
    _max: HomePageMaxAggregateOutputType | null
  }

  type GetHomePageGroupByPayload<T extends HomePageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomePageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomePageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomePageGroupByOutputType[P]>
            : GetScalarType<T[P], HomePageGroupByOutputType[P]>
        }
      >
    >


  export type HomePageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroVideo?: boolean
    vision?: boolean
    mission?: boolean
    focus?: boolean
    coreValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["homePage"]>

  export type HomePageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroVideo?: boolean
    vision?: boolean
    mission?: boolean
    focus?: boolean
    coreValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["homePage"]>

  export type HomePageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroVideo?: boolean
    vision?: boolean
    mission?: boolean
    focus?: boolean
    coreValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["homePage"]>

  export type HomePageSelectScalar = {
    id?: boolean
    heroVideo?: boolean
    vision?: boolean
    mission?: boolean
    focus?: boolean
    coreValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HomePageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heroVideo" | "vision" | "mission" | "focus" | "coreValues" | "createdAt" | "updatedAt", ExtArgs["result"]["homePage"]>

  export type $HomePagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomePage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      heroVideo: string
      vision: string
      mission: string
      focus: string
      coreValues: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["homePage"]>
    composites: {}
  }

  type HomePageGetPayload<S extends boolean | null | undefined | HomePageDefaultArgs> = $Result.GetResult<Prisma.$HomePagePayload, S>

  type HomePageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomePageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomePageCountAggregateInputType | true
    }

  export interface HomePageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomePage'], meta: { name: 'HomePage' } }
    /**
     * Find zero or one HomePage that matches the filter.
     * @param {HomePageFindUniqueArgs} args - Arguments to find a HomePage
     * @example
     * // Get one HomePage
     * const homePage = await prisma.homePage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomePageFindUniqueArgs>(args: SelectSubset<T, HomePageFindUniqueArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HomePage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomePageFindUniqueOrThrowArgs} args - Arguments to find a HomePage
     * @example
     * // Get one HomePage
     * const homePage = await prisma.homePage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomePageFindUniqueOrThrowArgs>(args: SelectSubset<T, HomePageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageFindFirstArgs} args - Arguments to find a HomePage
     * @example
     * // Get one HomePage
     * const homePage = await prisma.homePage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomePageFindFirstArgs>(args?: SelectSubset<T, HomePageFindFirstArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageFindFirstOrThrowArgs} args - Arguments to find a HomePage
     * @example
     * // Get one HomePage
     * const homePage = await prisma.homePage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomePageFindFirstOrThrowArgs>(args?: SelectSubset<T, HomePageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HomePages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomePages
     * const homePages = await prisma.homePage.findMany()
     * 
     * // Get first 10 HomePages
     * const homePages = await prisma.homePage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homePageWithIdOnly = await prisma.homePage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomePageFindManyArgs>(args?: SelectSubset<T, HomePageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HomePage.
     * @param {HomePageCreateArgs} args - Arguments to create a HomePage.
     * @example
     * // Create one HomePage
     * const HomePage = await prisma.homePage.create({
     *   data: {
     *     // ... data to create a HomePage
     *   }
     * })
     * 
     */
    create<T extends HomePageCreateArgs>(args: SelectSubset<T, HomePageCreateArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HomePages.
     * @param {HomePageCreateManyArgs} args - Arguments to create many HomePages.
     * @example
     * // Create many HomePages
     * const homePage = await prisma.homePage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomePageCreateManyArgs>(args?: SelectSubset<T, HomePageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomePages and returns the data saved in the database.
     * @param {HomePageCreateManyAndReturnArgs} args - Arguments to create many HomePages.
     * @example
     * // Create many HomePages
     * const homePage = await prisma.homePage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomePages and only return the `id`
     * const homePageWithIdOnly = await prisma.homePage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomePageCreateManyAndReturnArgs>(args?: SelectSubset<T, HomePageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HomePage.
     * @param {HomePageDeleteArgs} args - Arguments to delete one HomePage.
     * @example
     * // Delete one HomePage
     * const HomePage = await prisma.homePage.delete({
     *   where: {
     *     // ... filter to delete one HomePage
     *   }
     * })
     * 
     */
    delete<T extends HomePageDeleteArgs>(args: SelectSubset<T, HomePageDeleteArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HomePage.
     * @param {HomePageUpdateArgs} args - Arguments to update one HomePage.
     * @example
     * // Update one HomePage
     * const homePage = await prisma.homePage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomePageUpdateArgs>(args: SelectSubset<T, HomePageUpdateArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HomePages.
     * @param {HomePageDeleteManyArgs} args - Arguments to filter HomePages to delete.
     * @example
     * // Delete a few HomePages
     * const { count } = await prisma.homePage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomePageDeleteManyArgs>(args?: SelectSubset<T, HomePageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomePages
     * const homePage = await prisma.homePage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomePageUpdateManyArgs>(args: SelectSubset<T, HomePageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePages and returns the data updated in the database.
     * @param {HomePageUpdateManyAndReturnArgs} args - Arguments to update many HomePages.
     * @example
     * // Update many HomePages
     * const homePage = await prisma.homePage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HomePages and only return the `id`
     * const homePageWithIdOnly = await prisma.homePage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomePageUpdateManyAndReturnArgs>(args: SelectSubset<T, HomePageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HomePage.
     * @param {HomePageUpsertArgs} args - Arguments to update or create a HomePage.
     * @example
     * // Update or create a HomePage
     * const homePage = await prisma.homePage.upsert({
     *   create: {
     *     // ... data to create a HomePage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomePage we want to update
     *   }
     * })
     */
    upsert<T extends HomePageUpsertArgs>(args: SelectSubset<T, HomePageUpsertArgs<ExtArgs>>): Prisma__HomePageClient<$Result.GetResult<Prisma.$HomePagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HomePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageCountArgs} args - Arguments to filter HomePages to count.
     * @example
     * // Count the number of HomePages
     * const count = await prisma.homePage.count({
     *   where: {
     *     // ... the filter for the HomePages we want to count
     *   }
     * })
    **/
    count<T extends HomePageCountArgs>(
      args?: Subset<T, HomePageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomePageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomePageAggregateArgs>(args: Subset<T, HomePageAggregateArgs>): Prisma.PrismaPromise<GetHomePageAggregateType<T>>

    /**
     * Group by HomePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomePageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomePageGroupByArgs['orderBy'] }
        : { orderBy?: HomePageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomePageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomePageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomePage model
   */
  readonly fields: HomePageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomePage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomePageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomePage model
   */
  interface HomePageFieldRefs {
    readonly id: FieldRef<"HomePage", 'Int'>
    readonly heroVideo: FieldRef<"HomePage", 'String'>
    readonly vision: FieldRef<"HomePage", 'String'>
    readonly mission: FieldRef<"HomePage", 'String'>
    readonly focus: FieldRef<"HomePage", 'String'>
    readonly coreValues: FieldRef<"HomePage", 'String'>
    readonly createdAt: FieldRef<"HomePage", 'DateTime'>
    readonly updatedAt: FieldRef<"HomePage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomePage findUnique
   */
  export type HomePageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter, which HomePage to fetch.
     */
    where: HomePageWhereUniqueInput
  }

  /**
   * HomePage findUniqueOrThrow
   */
  export type HomePageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter, which HomePage to fetch.
     */
    where: HomePageWhereUniqueInput
  }

  /**
   * HomePage findFirst
   */
  export type HomePageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter, which HomePage to fetch.
     */
    where?: HomePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePages to fetch.
     */
    orderBy?: HomePageOrderByWithRelationInput | HomePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePages.
     */
    cursor?: HomePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePages.
     */
    distinct?: HomePageScalarFieldEnum | HomePageScalarFieldEnum[]
  }

  /**
   * HomePage findFirstOrThrow
   */
  export type HomePageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter, which HomePage to fetch.
     */
    where?: HomePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePages to fetch.
     */
    orderBy?: HomePageOrderByWithRelationInput | HomePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePages.
     */
    cursor?: HomePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePages.
     */
    distinct?: HomePageScalarFieldEnum | HomePageScalarFieldEnum[]
  }

  /**
   * HomePage findMany
   */
  export type HomePageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter, which HomePages to fetch.
     */
    where?: HomePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePages to fetch.
     */
    orderBy?: HomePageOrderByWithRelationInput | HomePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomePages.
     */
    cursor?: HomePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePages.
     */
    skip?: number
    distinct?: HomePageScalarFieldEnum | HomePageScalarFieldEnum[]
  }

  /**
   * HomePage create
   */
  export type HomePageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * The data needed to create a HomePage.
     */
    data: XOR<HomePageCreateInput, HomePageUncheckedCreateInput>
  }

  /**
   * HomePage createMany
   */
  export type HomePageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomePages.
     */
    data: HomePageCreateManyInput | HomePageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomePage createManyAndReturn
   */
  export type HomePageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * The data used to create many HomePages.
     */
    data: HomePageCreateManyInput | HomePageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomePage update
   */
  export type HomePageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * The data needed to update a HomePage.
     */
    data: XOR<HomePageUpdateInput, HomePageUncheckedUpdateInput>
    /**
     * Choose, which HomePage to update.
     */
    where: HomePageWhereUniqueInput
  }

  /**
   * HomePage updateMany
   */
  export type HomePageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomePages.
     */
    data: XOR<HomePageUpdateManyMutationInput, HomePageUncheckedUpdateManyInput>
    /**
     * Filter which HomePages to update
     */
    where?: HomePageWhereInput
    /**
     * Limit how many HomePages to update.
     */
    limit?: number
  }

  /**
   * HomePage updateManyAndReturn
   */
  export type HomePageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * The data used to update HomePages.
     */
    data: XOR<HomePageUpdateManyMutationInput, HomePageUncheckedUpdateManyInput>
    /**
     * Filter which HomePages to update
     */
    where?: HomePageWhereInput
    /**
     * Limit how many HomePages to update.
     */
    limit?: number
  }

  /**
   * HomePage upsert
   */
  export type HomePageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * The filter to search for the HomePage to update in case it exists.
     */
    where: HomePageWhereUniqueInput
    /**
     * In case the HomePage found by the `where` argument doesn't exist, create a new HomePage with this data.
     */
    create: XOR<HomePageCreateInput, HomePageUncheckedCreateInput>
    /**
     * In case the HomePage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomePageUpdateInput, HomePageUncheckedUpdateInput>
  }

  /**
   * HomePage delete
   */
  export type HomePageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
    /**
     * Filter which HomePage to delete.
     */
    where: HomePageWhereUniqueInput
  }

  /**
   * HomePage deleteMany
   */
  export type HomePageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePages to delete
     */
    where?: HomePageWhereInput
    /**
     * Limit how many HomePages to delete.
     */
    limit?: number
  }

  /**
   * HomePage without action
   */
  export type HomePageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePage
     */
    select?: HomePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePage
     */
    omit?: HomePageOmit<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    title: string | null
    affiliated: string | null
    name: string | null
    nameImageUrl: string | null
    messageImageUrl: string | null
    messageStatus: $Enums.PublishStatus | null
    messageCategory: $Enums.MessageCategory | null
    senderEmail: string | null
    senderIp: string | null
    allowResponses: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
    beneficiaryId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    title: string | null
    affiliated: string | null
    name: string | null
    nameImageUrl: string | null
    messageImageUrl: string | null
    messageStatus: $Enums.PublishStatus | null
    messageCategory: $Enums.MessageCategory | null
    senderEmail: string | null
    senderIp: string | null
    allowResponses: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
    beneficiaryId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    title: number
    affiliated: number
    name: number
    content: number
    nameImageUrl: number
    messageImageUrl: number
    messageStatus: number
    messageCategory: number
    senderEmail: number
    senderIp: number
    allowResponses: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    approvedById: number
    beneficiaryId: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    title?: true
    affiliated?: true
    name?: true
    nameImageUrl?: true
    messageImageUrl?: true
    messageStatus?: true
    messageCategory?: true
    senderEmail?: true
    senderIp?: true
    allowResponses?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    beneficiaryId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    title?: true
    affiliated?: true
    name?: true
    nameImageUrl?: true
    messageImageUrl?: true
    messageStatus?: true
    messageCategory?: true
    senderEmail?: true
    senderIp?: true
    allowResponses?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    beneficiaryId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    title?: true
    affiliated?: true
    name?: true
    content?: true
    nameImageUrl?: true
    messageImageUrl?: true
    messageStatus?: true
    messageCategory?: true
    senderEmail?: true
    senderIp?: true
    allowResponses?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    beneficiaryId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    title: string | null
    affiliated: string | null
    name: string | null
    content: JsonValue
    nameImageUrl: string | null
    messageImageUrl: string | null
    messageStatus: $Enums.PublishStatus
    messageCategory: $Enums.MessageCategory
    senderEmail: string | null
    senderIp: string | null
    allowResponses: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
    beneficiaryId: string | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    affiliated?: boolean
    name?: boolean
    content?: boolean
    nameImageUrl?: boolean
    messageImageUrl?: boolean
    messageStatus?: boolean
    messageCategory?: boolean
    senderEmail?: boolean
    senderIp?: boolean
    allowResponses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    beneficiaryId?: boolean
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
    responses?: boolean | Message$responsesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    affiliated?: boolean
    name?: boolean
    content?: boolean
    nameImageUrl?: boolean
    messageImageUrl?: boolean
    messageStatus?: boolean
    messageCategory?: boolean
    senderEmail?: boolean
    senderIp?: boolean
    allowResponses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    beneficiaryId?: boolean
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    affiliated?: boolean
    name?: boolean
    content?: boolean
    nameImageUrl?: boolean
    messageImageUrl?: boolean
    messageStatus?: boolean
    messageCategory?: boolean
    senderEmail?: boolean
    senderIp?: boolean
    allowResponses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    beneficiaryId?: boolean
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    title?: boolean
    affiliated?: boolean
    name?: boolean
    content?: boolean
    nameImageUrl?: boolean
    messageImageUrl?: boolean
    messageStatus?: boolean
    messageCategory?: boolean
    senderEmail?: boolean
    senderIp?: boolean
    allowResponses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    beneficiaryId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "affiliated" | "name" | "content" | "nameImageUrl" | "messageImageUrl" | "messageStatus" | "messageCategory" | "senderEmail" | "senderIp" | "allowResponses" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "approvedById" | "beneficiaryId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
    responses?: boolean | Message$responsesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Message$createdByArgs<ExtArgs>
    updatedBy?: boolean | Message$updatedByArgs<ExtArgs>
    approver?: boolean | Message$approverArgs<ExtArgs>
    beneficiary?: boolean | Message$beneficiaryArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      approver: Prisma.$UserPayload<ExtArgs> | null
      beneficiary: Prisma.$BeneficiaryPayload<ExtArgs> | null
      responses: Prisma.$ResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      affiliated: string | null
      name: string | null
      content: Prisma.JsonValue
      nameImageUrl: string | null
      messageImageUrl: string | null
      messageStatus: $Enums.PublishStatus
      messageCategory: $Enums.MessageCategory
      senderEmail: string | null
      senderIp: string | null
      allowResponses: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
      approvedById: string | null
      beneficiaryId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Message$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Message$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Message$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Message$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approver<T extends Message$approverArgs<ExtArgs> = {}>(args?: Subset<T, Message$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    beneficiary<T extends Message$beneficiaryArgs<ExtArgs> = {}>(args?: Subset<T, Message$beneficiaryArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responses<T extends Message$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Message$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly title: FieldRef<"Message", 'String'>
    readonly affiliated: FieldRef<"Message", 'String'>
    readonly name: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'Json'>
    readonly nameImageUrl: FieldRef<"Message", 'String'>
    readonly messageImageUrl: FieldRef<"Message", 'String'>
    readonly messageStatus: FieldRef<"Message", 'PublishStatus'>
    readonly messageCategory: FieldRef<"Message", 'MessageCategory'>
    readonly senderEmail: FieldRef<"Message", 'String'>
    readonly senderIp: FieldRef<"Message", 'String'>
    readonly allowResponses: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly createdById: FieldRef<"Message", 'String'>
    readonly updatedById: FieldRef<"Message", 'String'>
    readonly approvedById: FieldRef<"Message", 'String'>
    readonly beneficiaryId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.createdBy
   */
  export type Message$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.updatedBy
   */
  export type Message$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.approver
   */
  export type Message$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.beneficiary
   */
  export type Message$beneficiaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
  }

  /**
   * Message.responses
   */
  export type Message$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    accessCount: number | null
    downloadCount: number | null
    projectId: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    accessCount: number | null
    downloadCount: number | null
    projectId: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    publishStatus: $Enums.PublishStatus | null
    accessCount: number | null
    downloadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
    projectId: number | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    publishStatus: $Enums.PublishStatus | null
    accessCount: number | null
    downloadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
    projectId: number | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    images: number
    files: number
    publishStatus: number
    accessCount: number
    downloadCount: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    approvedById: number
    projectId: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    accessCount?: true
    downloadCount?: true
    projectId?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    accessCount?: true
    downloadCount?: true
    projectId?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    publishStatus?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    projectId?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    publishStatus?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    projectId?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    images?: true
    files?: true
    publishStatus?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    projectId?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    title: string
    slug: string
    images: string[]
    files: string[]
    publishStatus: $Enums.PublishStatus
    accessCount: number
    downloadCount: number
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string | null
    approvedById: string | null
    projectId: number | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    images?: boolean
    files?: boolean
    publishStatus?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    projectId?: boolean
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
    events?: boolean | Report$eventsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    images?: boolean
    files?: boolean
    publishStatus?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    projectId?: boolean
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    images?: boolean
    files?: boolean
    publishStatus?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    projectId?: boolean
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    images?: boolean
    files?: boolean
    publishStatus?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    projectId?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "images" | "files" | "publishStatus" | "accessCount" | "downloadCount" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "approvedById" | "projectId", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
    events?: boolean | Report$eventsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Report$approvedByArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Report$projectArgs<ExtArgs>
    updatedBy?: boolean | Report$updatedByArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      images: string[]
      files: string[]
      publishStatus: $Enums.PublishStatus
      accessCount: number
      downloadCount: number
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string | null
      approvedById: string | null
      projectId: number | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvedBy<T extends Report$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Report$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends Report$projectArgs<ExtArgs> = {}>(args?: Subset<T, Report$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Report$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Report$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends Report$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Report$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly title: FieldRef<"Report", 'String'>
    readonly slug: FieldRef<"Report", 'String'>
    readonly images: FieldRef<"Report", 'String[]'>
    readonly files: FieldRef<"Report", 'String[]'>
    readonly publishStatus: FieldRef<"Report", 'PublishStatus'>
    readonly accessCount: FieldRef<"Report", 'Int'>
    readonly downloadCount: FieldRef<"Report", 'Int'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly createdById: FieldRef<"Report", 'String'>
    readonly updatedById: FieldRef<"Report", 'String'>
    readonly approvedById: FieldRef<"Report", 'String'>
    readonly projectId: FieldRef<"Report", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.approvedBy
   */
  export type Report$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.project
   */
  export type Report$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Report.updatedBy
   */
  export type Report$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.events
   */
  export type Report$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginCount: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    password: string | null
    email: string | null
    image: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    about: string | null
    lastLogin: Date | null
    loginStatus: $Enums.LoginStatus | null
    failedLoginCount: number | null
    lockedUntil: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    password: string | null
    email: string | null
    image: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    about: string | null
    lastLogin: Date | null
    loginStatus: $Enums.LoginStatus | null
    failedLoginCount: number | null
    lockedUntil: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    password: number
    email: number
    image: number
    role: number
    createdAt: number
    updatedAt: number
    about: number
    lastLogin: number
    loginStatus: number
    failedLoginCount: number
    lockedUntil: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginCount?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    email?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    about?: true
    lastLogin?: true
    loginStatus?: true
    failedLoginCount?: true
    lockedUntil?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    email?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    about?: true
    lastLogin?: true
    loginStatus?: true
    failedLoginCount?: true
    lockedUntil?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    password?: true
    email?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    about?: true
    lastLogin?: true
    loginStatus?: true
    failedLoginCount?: true
    lockedUntil?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    username: string
    password: string
    email: string | null
    image: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    about: string | null
    lastLogin: Date | null
    loginStatus: $Enums.LoginStatus
    failedLoginCount: number
    lockedUntil: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    about?: boolean
    lastLogin?: boolean
    loginStatus?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordChangeLog?: boolean | User$passwordChangeLogArgs<ExtArgs>
    failedLogins?: boolean | User$failedLoginsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    approvedMessages?: boolean | User$approvedMessagesArgs<ExtArgs>
    createdMessages?: boolean | User$createdMessagesArgs<ExtArgs>
    updatedMessages?: boolean | User$updatedMessagesArgs<ExtArgs>
    responses?: boolean | User$responsesArgs<ExtArgs>
    approvedProjects?: boolean | User$approvedProjectsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    updatedProjects?: boolean | User$updatedProjectsArgs<ExtArgs>
    approvedReports?: boolean | User$approvedReportsArgs<ExtArgs>
    createdReports?: boolean | User$createdReportsArgs<ExtArgs>
    updatedReports?: boolean | User$updatedReportsArgs<ExtArgs>
    createdEvents?: boolean | User$createdEventsArgs<ExtArgs>
    updatedEvents?: boolean | User$updatedEventsArgs<ExtArgs>
    createdBeneficiaries?: boolean | User$createdBeneficiariesArgs<ExtArgs>
    updatedBeneficiaries?: boolean | User$updatedBeneficiariesArgs<ExtArgs>
    approvedBeneficiaries?: boolean | User$approvedBeneficiariesArgs<ExtArgs>
    createdInstitutions?: boolean | User$createdInstitutionsArgs<ExtArgs>
    updatedInstitutions?: boolean | User$updatedInstitutionsArgs<ExtArgs>
    approvedInstitutions?: boolean | User$approvedInstitutionsArgs<ExtArgs>
    createdFaqs?: boolean | User$createdFaqsArgs<ExtArgs>
    updatedFaqs?: boolean | User$updatedFaqsArgs<ExtArgs>
    approvedFaqs?: boolean | User$approvedFaqsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    about?: boolean
    lastLogin?: boolean
    loginStatus?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    about?: boolean
    lastLogin?: boolean
    loginStatus?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    about?: boolean
    lastLogin?: boolean
    loginStatus?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "username" | "password" | "email" | "image" | "role" | "createdAt" | "updatedAt" | "about" | "lastLogin" | "loginStatus" | "failedLoginCount" | "lockedUntil", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordHistory?: boolean | User$passwordHistoryArgs<ExtArgs>
    passwordChangeLog?: boolean | User$passwordChangeLogArgs<ExtArgs>
    failedLogins?: boolean | User$failedLoginsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    approvedMessages?: boolean | User$approvedMessagesArgs<ExtArgs>
    createdMessages?: boolean | User$createdMessagesArgs<ExtArgs>
    updatedMessages?: boolean | User$updatedMessagesArgs<ExtArgs>
    responses?: boolean | User$responsesArgs<ExtArgs>
    approvedProjects?: boolean | User$approvedProjectsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    updatedProjects?: boolean | User$updatedProjectsArgs<ExtArgs>
    approvedReports?: boolean | User$approvedReportsArgs<ExtArgs>
    createdReports?: boolean | User$createdReportsArgs<ExtArgs>
    updatedReports?: boolean | User$updatedReportsArgs<ExtArgs>
    createdEvents?: boolean | User$createdEventsArgs<ExtArgs>
    updatedEvents?: boolean | User$updatedEventsArgs<ExtArgs>
    createdBeneficiaries?: boolean | User$createdBeneficiariesArgs<ExtArgs>
    updatedBeneficiaries?: boolean | User$updatedBeneficiariesArgs<ExtArgs>
    approvedBeneficiaries?: boolean | User$approvedBeneficiariesArgs<ExtArgs>
    createdInstitutions?: boolean | User$createdInstitutionsArgs<ExtArgs>
    updatedInstitutions?: boolean | User$updatedInstitutionsArgs<ExtArgs>
    approvedInstitutions?: boolean | User$approvedInstitutionsArgs<ExtArgs>
    createdFaqs?: boolean | User$createdFaqsArgs<ExtArgs>
    updatedFaqs?: boolean | User$updatedFaqsArgs<ExtArgs>
    approvedFaqs?: boolean | User$approvedFaqsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      passwordHistory: Prisma.$PasswordHistoryPayload<ExtArgs>[]
      passwordChangeLog: Prisma.$PasswordChangeLogPayload<ExtArgs>[]
      failedLogins: Prisma.$FailedLoginAttemptPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      approvedMessages: Prisma.$MessagePayload<ExtArgs>[]
      createdMessages: Prisma.$MessagePayload<ExtArgs>[]
      updatedMessages: Prisma.$MessagePayload<ExtArgs>[]
      responses: Prisma.$ResponsePayload<ExtArgs>[]
      approvedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      createdProjects: Prisma.$ProjectPayload<ExtArgs>[]
      updatedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      approvedReports: Prisma.$ReportPayload<ExtArgs>[]
      createdReports: Prisma.$ReportPayload<ExtArgs>[]
      updatedReports: Prisma.$ReportPayload<ExtArgs>[]
      createdEvents: Prisma.$EventPayload<ExtArgs>[]
      updatedEvents: Prisma.$EventPayload<ExtArgs>[]
      createdBeneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      updatedBeneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      approvedBeneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      createdInstitutions: Prisma.$InstitutionPayload<ExtArgs>[]
      updatedInstitutions: Prisma.$InstitutionPayload<ExtArgs>[]
      approvedInstitutions: Prisma.$InstitutionPayload<ExtArgs>[]
      createdFaqs: Prisma.$FAQPayload<ExtArgs>[]
      updatedFaqs: Prisma.$FAQPayload<ExtArgs>[]
      approvedFaqs: Prisma.$FAQPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string | null
      lastName: string | null
      username: string
      password: string
      email: string | null
      image: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      about: string | null
      lastLogin: Date | null
      loginStatus: $Enums.LoginStatus
      failedLoginCount: number
      lockedUntil: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwordHistory<T extends User$passwordHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordChangeLog<T extends User$passwordChangeLogArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordChangeLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    failedLogins<T extends User$failedLoginsArgs<ExtArgs> = {}>(args?: Subset<T, User$failedLoginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedMessages<T extends User$approvedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdMessages<T extends User$createdMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedMessages<T extends User$updatedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends User$responsesArgs<ExtArgs> = {}>(args?: Subset<T, User$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedProjects<T extends User$approvedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProjects<T extends User$createdProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedProjects<T extends User$updatedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedReports<T extends User$approvedReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdReports<T extends User$createdReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedReports<T extends User$updatedReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdEvents<T extends User$createdEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedEvents<T extends User$updatedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBeneficiaries<T extends User$createdBeneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBeneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedBeneficiaries<T extends User$updatedBeneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedBeneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedBeneficiaries<T extends User$approvedBeneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedBeneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdInstitutions<T extends User$createdInstitutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInstitutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedInstitutions<T extends User$updatedInstitutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedInstitutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedInstitutions<T extends User$approvedInstitutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedInstitutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFaqs<T extends User$createdFaqsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFaqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedFaqs<T extends User$updatedFaqsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedFaqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedFaqs<T extends User$approvedFaqsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedFaqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly about: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly loginStatus: FieldRef<"User", 'LoginStatus'>
    readonly failedLoginCount: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.passwordHistory
   */
  export type User$passwordHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    cursor?: PasswordHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * User.passwordChangeLog
   */
  export type User$passwordChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    where?: PasswordChangeLogWhereInput
    orderBy?: PasswordChangeLogOrderByWithRelationInput | PasswordChangeLogOrderByWithRelationInput[]
    cursor?: PasswordChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordChangeLogScalarFieldEnum | PasswordChangeLogScalarFieldEnum[]
  }

  /**
   * User.failedLogins
   */
  export type User$failedLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    where?: FailedLoginAttemptWhereInput
    orderBy?: FailedLoginAttemptOrderByWithRelationInput | FailedLoginAttemptOrderByWithRelationInput[]
    cursor?: FailedLoginAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FailedLoginAttemptScalarFieldEnum | FailedLoginAttemptScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.approvedMessages
   */
  export type User$approvedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.createdMessages
   */
  export type User$createdMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.updatedMessages
   */
  export type User$updatedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.responses
   */
  export type User$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * User.approvedProjects
   */
  export type User$approvedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.createdProjects
   */
  export type User$createdProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.updatedProjects
   */
  export type User$updatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.approvedReports
   */
  export type User$approvedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.createdReports
   */
  export type User$createdReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.updatedReports
   */
  export type User$updatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.createdEvents
   */
  export type User$createdEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.updatedEvents
   */
  export type User$updatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.createdBeneficiaries
   */
  export type User$createdBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * User.updatedBeneficiaries
   */
  export type User$updatedBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * User.approvedBeneficiaries
   */
  export type User$approvedBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * User.createdInstitutions
   */
  export type User$createdInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    cursor?: InstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * User.updatedInstitutions
   */
  export type User$updatedInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    cursor?: InstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * User.approvedInstitutions
   */
  export type User$approvedInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    cursor?: InstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * User.createdFaqs
   */
  export type User$createdFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    cursor?: FAQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * User.updatedFaqs
   */
  export type User$updatedFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    cursor?: FAQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * User.approvedFaqs
   */
  export type User$approvedFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    cursor?: FAQWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordHistory
   */

  export type AggregatePasswordHistory = {
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  export type PasswordHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    passwordHash: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    passwordHash: string | null
    createdAt: Date | null
  }

  export type PasswordHistoryCountAggregateOutputType = {
    id: number
    userId: number
    passwordHash: number
    createdAt: number
    _all: number
  }


  export type PasswordHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    createdAt?: true
  }

  export type PasswordHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    createdAt?: true
  }

  export type PasswordHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    passwordHash?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistory to aggregate.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordHistories
    **/
    _count?: true | PasswordHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type GetPasswordHistoryAggregateType<T extends PasswordHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordHistory[P]>
      : GetScalarType<T[P], AggregatePasswordHistory[P]>
  }




  export type PasswordHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistoryWhereInput
    orderBy?: PasswordHistoryOrderByWithAggregationInput | PasswordHistoryOrderByWithAggregationInput[]
    by: PasswordHistoryScalarFieldEnum[] | PasswordHistoryScalarFieldEnum
    having?: PasswordHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordHistoryCountAggregateInputType | true
    _min?: PasswordHistoryMinAggregateInputType
    _max?: PasswordHistoryMaxAggregateInputType
  }

  export type PasswordHistoryGroupByOutputType = {
    id: string
    userId: string
    passwordHash: string
    createdAt: Date
    _count: PasswordHistoryCountAggregateOutputType | null
    _min: PasswordHistoryMinAggregateOutputType | null
    _max: PasswordHistoryMaxAggregateOutputType | null
  }

  type GetPasswordHistoryGroupByPayload<T extends PasswordHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PasswordHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistory"]>

  export type PasswordHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    passwordHash?: boolean
    createdAt?: boolean
  }

  export type PasswordHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "passwordHash" | "createdAt", ExtArgs["result"]["passwordHistory"]>
  export type PasswordHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      passwordHash: string
      createdAt: Date
    }, ExtArgs["result"]["passwordHistory"]>
    composites: {}
  }

  type PasswordHistoryGetPayload<S extends boolean | null | undefined | PasswordHistoryDefaultArgs> = $Result.GetResult<Prisma.$PasswordHistoryPayload, S>

  type PasswordHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordHistoryCountAggregateInputType | true
    }

  export interface PasswordHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordHistory'], meta: { name: 'PasswordHistory' } }
    /**
     * Find zero or one PasswordHistory that matches the filter.
     * @param {PasswordHistoryFindUniqueArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordHistoryFindUniqueArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordHistoryFindUniqueOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordHistoryFindFirstArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindFirstOrThrowArgs} args - Arguments to find a PasswordHistory
     * @example
     * // Get one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany()
     * 
     * // Get first 10 PasswordHistories
     * const passwordHistories = await prisma.passwordHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordHistoryFindManyArgs>(args?: SelectSubset<T, PasswordHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordHistory.
     * @param {PasswordHistoryCreateArgs} args - Arguments to create a PasswordHistory.
     * @example
     * // Create one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.create({
     *   data: {
     *     // ... data to create a PasswordHistory
     *   }
     * })
     * 
     */
    create<T extends PasswordHistoryCreateArgs>(args: SelectSubset<T, PasswordHistoryCreateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordHistories.
     * @param {PasswordHistoryCreateManyArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordHistoryCreateManyArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordHistories and returns the data saved in the database.
     * @param {PasswordHistoryCreateManyAndReturnArgs} args - Arguments to create many PasswordHistories.
     * @example
     * // Create many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordHistory.
     * @param {PasswordHistoryDeleteArgs} args - Arguments to delete one PasswordHistory.
     * @example
     * // Delete one PasswordHistory
     * const PasswordHistory = await prisma.passwordHistory.delete({
     *   where: {
     *     // ... filter to delete one PasswordHistory
     *   }
     * })
     * 
     */
    delete<T extends PasswordHistoryDeleteArgs>(args: SelectSubset<T, PasswordHistoryDeleteArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordHistory.
     * @param {PasswordHistoryUpdateArgs} args - Arguments to update one PasswordHistory.
     * @example
     * // Update one PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordHistoryUpdateArgs>(args: SelectSubset<T, PasswordHistoryUpdateArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordHistories.
     * @param {PasswordHistoryDeleteManyArgs} args - Arguments to filter PasswordHistories to delete.
     * @example
     * // Delete a few PasswordHistories
     * const { count } = await prisma.passwordHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordHistoryDeleteManyArgs>(args?: SelectSubset<T, PasswordHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordHistoryUpdateManyArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistories and returns the data updated in the database.
     * @param {PasswordHistoryUpdateManyAndReturnArgs} args - Arguments to update many PasswordHistories.
     * @example
     * // Update many PasswordHistories
     * const passwordHistory = await prisma.passwordHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordHistories and only return the `id`
     * const passwordHistoryWithIdOnly = await prisma.passwordHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordHistory.
     * @param {PasswordHistoryUpsertArgs} args - Arguments to update or create a PasswordHistory.
     * @example
     * // Update or create a PasswordHistory
     * const passwordHistory = await prisma.passwordHistory.upsert({
     *   create: {
     *     // ... data to create a PasswordHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordHistory we want to update
     *   }
     * })
     */
    upsert<T extends PasswordHistoryUpsertArgs>(args: SelectSubset<T, PasswordHistoryUpsertArgs<ExtArgs>>): Prisma__PasswordHistoryClient<$Result.GetResult<Prisma.$PasswordHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryCountArgs} args - Arguments to filter PasswordHistories to count.
     * @example
     * // Count the number of PasswordHistories
     * const count = await prisma.passwordHistory.count({
     *   where: {
     *     // ... the filter for the PasswordHistories we want to count
     *   }
     * })
    **/
    count<T extends PasswordHistoryCountArgs>(
      args?: Subset<T, PasswordHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordHistoryAggregateArgs>(args: Subset<T, PasswordHistoryAggregateArgs>): Prisma.PrismaPromise<GetPasswordHistoryAggregateType<T>>

    /**
     * Group by PasswordHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PasswordHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordHistory model
   */
  readonly fields: PasswordHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordHistory model
   */
  interface PasswordHistoryFieldRefs {
    readonly id: FieldRef<"PasswordHistory", 'String'>
    readonly userId: FieldRef<"PasswordHistory", 'String'>
    readonly passwordHash: FieldRef<"PasswordHistory", 'String'>
    readonly createdAt: FieldRef<"PasswordHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordHistory findUnique
   */
  export type PasswordHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findUniqueOrThrow
   */
  export type PasswordHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory findFirst
   */
  export type PasswordHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findFirstOrThrow
   */
  export type PasswordHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistory to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistories.
     */
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory findMany
   */
  export type PasswordHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistories to fetch.
     */
    where?: PasswordHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistories to fetch.
     */
    orderBy?: PasswordHistoryOrderByWithRelationInput | PasswordHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordHistories.
     */
    cursor?: PasswordHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistories.
     */
    skip?: number
    distinct?: PasswordHistoryScalarFieldEnum | PasswordHistoryScalarFieldEnum[]
  }

  /**
   * PasswordHistory create
   */
  export type PasswordHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordHistory.
     */
    data: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
  }

  /**
   * PasswordHistory createMany
   */
  export type PasswordHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordHistory createManyAndReturn
   */
  export type PasswordHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordHistories.
     */
    data: PasswordHistoryCreateManyInput | PasswordHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory update
   */
  export type PasswordHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordHistory.
     */
    data: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
    /**
     * Choose, which PasswordHistory to update.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory updateMany
   */
  export type PasswordHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
  }

  /**
   * PasswordHistory updateManyAndReturn
   */
  export type PasswordHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PasswordHistories.
     */
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistories to update
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistory upsert
   */
  export type PasswordHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordHistory to update in case it exists.
     */
    where: PasswordHistoryWhereUniqueInput
    /**
     * In case the PasswordHistory found by the `where` argument doesn't exist, create a new PasswordHistory with this data.
     */
    create: XOR<PasswordHistoryCreateInput, PasswordHistoryUncheckedCreateInput>
    /**
     * In case the PasswordHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordHistoryUpdateInput, PasswordHistoryUncheckedUpdateInput>
  }

  /**
   * PasswordHistory delete
   */
  export type PasswordHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
    /**
     * Filter which PasswordHistory to delete.
     */
    where: PasswordHistoryWhereUniqueInput
  }

  /**
   * PasswordHistory deleteMany
   */
  export type PasswordHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistories to delete
     */
    where?: PasswordHistoryWhereInput
    /**
     * Limit how many PasswordHistories to delete.
     */
    limit?: number
  }

  /**
   * PasswordHistory without action
   */
  export type PasswordHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistory
     */
    select?: PasswordHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordHistory
     */
    omit?: PasswordHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordChangeLog
   */

  export type AggregatePasswordChangeLog = {
    _count: PasswordChangeLogCountAggregateOutputType | null
    _min: PasswordChangeLogMinAggregateOutputType | null
    _max: PasswordChangeLogMaxAggregateOutputType | null
  }

  export type PasswordChangeLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    changedBy: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PasswordChangeLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    changedBy: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PasswordChangeLogCountAggregateOutputType = {
    id: number
    userId: number
    changedBy: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type PasswordChangeLogMinAggregateInputType = {
    id?: true
    userId?: true
    changedBy?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type PasswordChangeLogMaxAggregateInputType = {
    id?: true
    userId?: true
    changedBy?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type PasswordChangeLogCountAggregateInputType = {
    id?: true
    userId?: true
    changedBy?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordChangeLog to aggregate.
     */
    where?: PasswordChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordChangeLogs to fetch.
     */
    orderBy?: PasswordChangeLogOrderByWithRelationInput | PasswordChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordChangeLogs
    **/
    _count?: true | PasswordChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordChangeLogMaxAggregateInputType
  }

  export type GetPasswordChangeLogAggregateType<T extends PasswordChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordChangeLog[P]>
      : GetScalarType<T[P], AggregatePasswordChangeLog[P]>
  }




  export type PasswordChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordChangeLogWhereInput
    orderBy?: PasswordChangeLogOrderByWithAggregationInput | PasswordChangeLogOrderByWithAggregationInput[]
    by: PasswordChangeLogScalarFieldEnum[] | PasswordChangeLogScalarFieldEnum
    having?: PasswordChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordChangeLogCountAggregateInputType | true
    _min?: PasswordChangeLogMinAggregateInputType
    _max?: PasswordChangeLogMaxAggregateInputType
  }

  export type PasswordChangeLogGroupByOutputType = {
    id: string
    userId: string
    changedBy: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: PasswordChangeLogCountAggregateOutputType | null
    _min: PasswordChangeLogMinAggregateOutputType | null
    _max: PasswordChangeLogMaxAggregateOutputType | null
  }

  type GetPasswordChangeLogGroupByPayload<T extends PasswordChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type PasswordChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changedBy?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordChangeLog"]>

  export type PasswordChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changedBy?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordChangeLog"]>

  export type PasswordChangeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changedBy?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordChangeLog"]>

  export type PasswordChangeLogSelectScalar = {
    id?: boolean
    userId?: boolean
    changedBy?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type PasswordChangeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "changedBy" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["passwordChangeLog"]>
  export type PasswordChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordChangeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordChangeLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      changedBy: string | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["passwordChangeLog"]>
    composites: {}
  }

  type PasswordChangeLogGetPayload<S extends boolean | null | undefined | PasswordChangeLogDefaultArgs> = $Result.GetResult<Prisma.$PasswordChangeLogPayload, S>

  type PasswordChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordChangeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordChangeLogCountAggregateInputType | true
    }

  export interface PasswordChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordChangeLog'], meta: { name: 'PasswordChangeLog' } }
    /**
     * Find zero or one PasswordChangeLog that matches the filter.
     * @param {PasswordChangeLogFindUniqueArgs} args - Arguments to find a PasswordChangeLog
     * @example
     * // Get one PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordChangeLogFindUniqueArgs>(args: SelectSubset<T, PasswordChangeLogFindUniqueArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordChangeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordChangeLogFindUniqueOrThrowArgs} args - Arguments to find a PasswordChangeLog
     * @example
     * // Get one PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogFindFirstArgs} args - Arguments to find a PasswordChangeLog
     * @example
     * // Get one PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordChangeLogFindFirstArgs>(args?: SelectSubset<T, PasswordChangeLogFindFirstArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogFindFirstOrThrowArgs} args - Arguments to find a PasswordChangeLog
     * @example
     * // Get one PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordChangeLogs
     * const passwordChangeLogs = await prisma.passwordChangeLog.findMany()
     * 
     * // Get first 10 PasswordChangeLogs
     * const passwordChangeLogs = await prisma.passwordChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordChangeLogWithIdOnly = await prisma.passwordChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordChangeLogFindManyArgs>(args?: SelectSubset<T, PasswordChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordChangeLog.
     * @param {PasswordChangeLogCreateArgs} args - Arguments to create a PasswordChangeLog.
     * @example
     * // Create one PasswordChangeLog
     * const PasswordChangeLog = await prisma.passwordChangeLog.create({
     *   data: {
     *     // ... data to create a PasswordChangeLog
     *   }
     * })
     * 
     */
    create<T extends PasswordChangeLogCreateArgs>(args: SelectSubset<T, PasswordChangeLogCreateArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordChangeLogs.
     * @param {PasswordChangeLogCreateManyArgs} args - Arguments to create many PasswordChangeLogs.
     * @example
     * // Create many PasswordChangeLogs
     * const passwordChangeLog = await prisma.passwordChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordChangeLogCreateManyArgs>(args?: SelectSubset<T, PasswordChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordChangeLogs and returns the data saved in the database.
     * @param {PasswordChangeLogCreateManyAndReturnArgs} args - Arguments to create many PasswordChangeLogs.
     * @example
     * // Create many PasswordChangeLogs
     * const passwordChangeLog = await prisma.passwordChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordChangeLogs and only return the `id`
     * const passwordChangeLogWithIdOnly = await prisma.passwordChangeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordChangeLog.
     * @param {PasswordChangeLogDeleteArgs} args - Arguments to delete one PasswordChangeLog.
     * @example
     * // Delete one PasswordChangeLog
     * const PasswordChangeLog = await prisma.passwordChangeLog.delete({
     *   where: {
     *     // ... filter to delete one PasswordChangeLog
     *   }
     * })
     * 
     */
    delete<T extends PasswordChangeLogDeleteArgs>(args: SelectSubset<T, PasswordChangeLogDeleteArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordChangeLog.
     * @param {PasswordChangeLogUpdateArgs} args - Arguments to update one PasswordChangeLog.
     * @example
     * // Update one PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordChangeLogUpdateArgs>(args: SelectSubset<T, PasswordChangeLogUpdateArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordChangeLogs.
     * @param {PasswordChangeLogDeleteManyArgs} args - Arguments to filter PasswordChangeLogs to delete.
     * @example
     * // Delete a few PasswordChangeLogs
     * const { count } = await prisma.passwordChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordChangeLogDeleteManyArgs>(args?: SelectSubset<T, PasswordChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordChangeLogs
     * const passwordChangeLog = await prisma.passwordChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordChangeLogUpdateManyArgs>(args: SelectSubset<T, PasswordChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordChangeLogs and returns the data updated in the database.
     * @param {PasswordChangeLogUpdateManyAndReturnArgs} args - Arguments to update many PasswordChangeLogs.
     * @example
     * // Update many PasswordChangeLogs
     * const passwordChangeLog = await prisma.passwordChangeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordChangeLogs and only return the `id`
     * const passwordChangeLogWithIdOnly = await prisma.passwordChangeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordChangeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordChangeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordChangeLog.
     * @param {PasswordChangeLogUpsertArgs} args - Arguments to update or create a PasswordChangeLog.
     * @example
     * // Update or create a PasswordChangeLog
     * const passwordChangeLog = await prisma.passwordChangeLog.upsert({
     *   create: {
     *     // ... data to create a PasswordChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends PasswordChangeLogUpsertArgs>(args: SelectSubset<T, PasswordChangeLogUpsertArgs<ExtArgs>>): Prisma__PasswordChangeLogClient<$Result.GetResult<Prisma.$PasswordChangeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogCountArgs} args - Arguments to filter PasswordChangeLogs to count.
     * @example
     * // Count the number of PasswordChangeLogs
     * const count = await prisma.passwordChangeLog.count({
     *   where: {
     *     // ... the filter for the PasswordChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends PasswordChangeLogCountArgs>(
      args?: Subset<T, PasswordChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordChangeLogAggregateArgs>(args: Subset<T, PasswordChangeLogAggregateArgs>): Prisma.PrismaPromise<GetPasswordChangeLogAggregateType<T>>

    /**
     * Group by PasswordChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: PasswordChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordChangeLog model
   */
  readonly fields: PasswordChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordChangeLog model
   */
  interface PasswordChangeLogFieldRefs {
    readonly id: FieldRef<"PasswordChangeLog", 'String'>
    readonly userId: FieldRef<"PasswordChangeLog", 'String'>
    readonly changedBy: FieldRef<"PasswordChangeLog", 'String'>
    readonly ip: FieldRef<"PasswordChangeLog", 'String'>
    readonly userAgent: FieldRef<"PasswordChangeLog", 'String'>
    readonly createdAt: FieldRef<"PasswordChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordChangeLog findUnique
   */
  export type PasswordChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which PasswordChangeLog to fetch.
     */
    where: PasswordChangeLogWhereUniqueInput
  }

  /**
   * PasswordChangeLog findUniqueOrThrow
   */
  export type PasswordChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which PasswordChangeLog to fetch.
     */
    where: PasswordChangeLogWhereUniqueInput
  }

  /**
   * PasswordChangeLog findFirst
   */
  export type PasswordChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which PasswordChangeLog to fetch.
     */
    where?: PasswordChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordChangeLogs to fetch.
     */
    orderBy?: PasswordChangeLogOrderByWithRelationInput | PasswordChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordChangeLogs.
     */
    cursor?: PasswordChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordChangeLogs.
     */
    distinct?: PasswordChangeLogScalarFieldEnum | PasswordChangeLogScalarFieldEnum[]
  }

  /**
   * PasswordChangeLog findFirstOrThrow
   */
  export type PasswordChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which PasswordChangeLog to fetch.
     */
    where?: PasswordChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordChangeLogs to fetch.
     */
    orderBy?: PasswordChangeLogOrderByWithRelationInput | PasswordChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordChangeLogs.
     */
    cursor?: PasswordChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordChangeLogs.
     */
    distinct?: PasswordChangeLogScalarFieldEnum | PasswordChangeLogScalarFieldEnum[]
  }

  /**
   * PasswordChangeLog findMany
   */
  export type PasswordChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which PasswordChangeLogs to fetch.
     */
    where?: PasswordChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordChangeLogs to fetch.
     */
    orderBy?: PasswordChangeLogOrderByWithRelationInput | PasswordChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordChangeLogs.
     */
    cursor?: PasswordChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordChangeLogs.
     */
    skip?: number
    distinct?: PasswordChangeLogScalarFieldEnum | PasswordChangeLogScalarFieldEnum[]
  }

  /**
   * PasswordChangeLog create
   */
  export type PasswordChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordChangeLog.
     */
    data: XOR<PasswordChangeLogCreateInput, PasswordChangeLogUncheckedCreateInput>
  }

  /**
   * PasswordChangeLog createMany
   */
  export type PasswordChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordChangeLogs.
     */
    data: PasswordChangeLogCreateManyInput | PasswordChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordChangeLog createManyAndReturn
   */
  export type PasswordChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordChangeLogs.
     */
    data: PasswordChangeLogCreateManyInput | PasswordChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordChangeLog update
   */
  export type PasswordChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordChangeLog.
     */
    data: XOR<PasswordChangeLogUpdateInput, PasswordChangeLogUncheckedUpdateInput>
    /**
     * Choose, which PasswordChangeLog to update.
     */
    where: PasswordChangeLogWhereUniqueInput
  }

  /**
   * PasswordChangeLog updateMany
   */
  export type PasswordChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordChangeLogs.
     */
    data: XOR<PasswordChangeLogUpdateManyMutationInput, PasswordChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which PasswordChangeLogs to update
     */
    where?: PasswordChangeLogWhereInput
    /**
     * Limit how many PasswordChangeLogs to update.
     */
    limit?: number
  }

  /**
   * PasswordChangeLog updateManyAndReturn
   */
  export type PasswordChangeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * The data used to update PasswordChangeLogs.
     */
    data: XOR<PasswordChangeLogUpdateManyMutationInput, PasswordChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which PasswordChangeLogs to update
     */
    where?: PasswordChangeLogWhereInput
    /**
     * Limit how many PasswordChangeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordChangeLog upsert
   */
  export type PasswordChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordChangeLog to update in case it exists.
     */
    where: PasswordChangeLogWhereUniqueInput
    /**
     * In case the PasswordChangeLog found by the `where` argument doesn't exist, create a new PasswordChangeLog with this data.
     */
    create: XOR<PasswordChangeLogCreateInput, PasswordChangeLogUncheckedCreateInput>
    /**
     * In case the PasswordChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordChangeLogUpdateInput, PasswordChangeLogUncheckedUpdateInput>
  }

  /**
   * PasswordChangeLog delete
   */
  export type PasswordChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
    /**
     * Filter which PasswordChangeLog to delete.
     */
    where: PasswordChangeLogWhereUniqueInput
  }

  /**
   * PasswordChangeLog deleteMany
   */
  export type PasswordChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordChangeLogs to delete
     */
    where?: PasswordChangeLogWhereInput
    /**
     * Limit how many PasswordChangeLogs to delete.
     */
    limit?: number
  }

  /**
   * PasswordChangeLog without action
   */
  export type PasswordChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordChangeLog
     */
    select?: PasswordChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordChangeLog
     */
    omit?: PasswordChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model FailedLoginAttempt
   */

  export type AggregateFailedLoginAttempt = {
    _count: FailedLoginAttemptCountAggregateOutputType | null
    _min: FailedLoginAttemptMinAggregateOutputType | null
    _max: FailedLoginAttemptMaxAggregateOutputType | null
  }

  export type FailedLoginAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type FailedLoginAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type FailedLoginAttemptCountAggregateOutputType = {
    id: number
    userId: number
    ip: number
    createdAt: number
    _all: number
  }


  export type FailedLoginAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    createdAt?: true
  }

  export type FailedLoginAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    createdAt?: true
  }

  export type FailedLoginAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    createdAt?: true
    _all?: true
  }

  export type FailedLoginAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedLoginAttempt to aggregate.
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedLoginAttempts to fetch.
     */
    orderBy?: FailedLoginAttemptOrderByWithRelationInput | FailedLoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FailedLoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedLoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedLoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FailedLoginAttempts
    **/
    _count?: true | FailedLoginAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FailedLoginAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FailedLoginAttemptMaxAggregateInputType
  }

  export type GetFailedLoginAttemptAggregateType<T extends FailedLoginAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateFailedLoginAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailedLoginAttempt[P]>
      : GetScalarType<T[P], AggregateFailedLoginAttempt[P]>
  }




  export type FailedLoginAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FailedLoginAttemptWhereInput
    orderBy?: FailedLoginAttemptOrderByWithAggregationInput | FailedLoginAttemptOrderByWithAggregationInput[]
    by: FailedLoginAttemptScalarFieldEnum[] | FailedLoginAttemptScalarFieldEnum
    having?: FailedLoginAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FailedLoginAttemptCountAggregateInputType | true
    _min?: FailedLoginAttemptMinAggregateInputType
    _max?: FailedLoginAttemptMaxAggregateInputType
  }

  export type FailedLoginAttemptGroupByOutputType = {
    id: string
    userId: string | null
    ip: string | null
    createdAt: Date
    _count: FailedLoginAttemptCountAggregateOutputType | null
    _min: FailedLoginAttemptMinAggregateOutputType | null
    _max: FailedLoginAttemptMaxAggregateOutputType | null
  }

  type GetFailedLoginAttemptGroupByPayload<T extends FailedLoginAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FailedLoginAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FailedLoginAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FailedLoginAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], FailedLoginAttemptGroupByOutputType[P]>
        }
      >
    >


  export type FailedLoginAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip?: boolean
    createdAt?: boolean
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }, ExtArgs["result"]["failedLoginAttempt"]>

  export type FailedLoginAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip?: boolean
    createdAt?: boolean
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }, ExtArgs["result"]["failedLoginAttempt"]>

  export type FailedLoginAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip?: boolean
    createdAt?: boolean
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }, ExtArgs["result"]["failedLoginAttempt"]>

  export type FailedLoginAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    ip?: boolean
    createdAt?: boolean
  }

  export type FailedLoginAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ip" | "createdAt", ExtArgs["result"]["failedLoginAttempt"]>
  export type FailedLoginAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }
  export type FailedLoginAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }
  export type FailedLoginAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FailedLoginAttempt$userArgs<ExtArgs>
  }

  export type $FailedLoginAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FailedLoginAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      ip: string | null
      createdAt: Date
    }, ExtArgs["result"]["failedLoginAttempt"]>
    composites: {}
  }

  type FailedLoginAttemptGetPayload<S extends boolean | null | undefined | FailedLoginAttemptDefaultArgs> = $Result.GetResult<Prisma.$FailedLoginAttemptPayload, S>

  type FailedLoginAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FailedLoginAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FailedLoginAttemptCountAggregateInputType | true
    }

  export interface FailedLoginAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FailedLoginAttempt'], meta: { name: 'FailedLoginAttempt' } }
    /**
     * Find zero or one FailedLoginAttempt that matches the filter.
     * @param {FailedLoginAttemptFindUniqueArgs} args - Arguments to find a FailedLoginAttempt
     * @example
     * // Get one FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FailedLoginAttemptFindUniqueArgs>(args: SelectSubset<T, FailedLoginAttemptFindUniqueArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FailedLoginAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FailedLoginAttemptFindUniqueOrThrowArgs} args - Arguments to find a FailedLoginAttempt
     * @example
     * // Get one FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FailedLoginAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, FailedLoginAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedLoginAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptFindFirstArgs} args - Arguments to find a FailedLoginAttempt
     * @example
     * // Get one FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FailedLoginAttemptFindFirstArgs>(args?: SelectSubset<T, FailedLoginAttemptFindFirstArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedLoginAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptFindFirstOrThrowArgs} args - Arguments to find a FailedLoginAttempt
     * @example
     * // Get one FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FailedLoginAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, FailedLoginAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FailedLoginAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FailedLoginAttempts
     * const failedLoginAttempts = await prisma.failedLoginAttempt.findMany()
     * 
     * // Get first 10 FailedLoginAttempts
     * const failedLoginAttempts = await prisma.failedLoginAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failedLoginAttemptWithIdOnly = await prisma.failedLoginAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FailedLoginAttemptFindManyArgs>(args?: SelectSubset<T, FailedLoginAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FailedLoginAttempt.
     * @param {FailedLoginAttemptCreateArgs} args - Arguments to create a FailedLoginAttempt.
     * @example
     * // Create one FailedLoginAttempt
     * const FailedLoginAttempt = await prisma.failedLoginAttempt.create({
     *   data: {
     *     // ... data to create a FailedLoginAttempt
     *   }
     * })
     * 
     */
    create<T extends FailedLoginAttemptCreateArgs>(args: SelectSubset<T, FailedLoginAttemptCreateArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FailedLoginAttempts.
     * @param {FailedLoginAttemptCreateManyArgs} args - Arguments to create many FailedLoginAttempts.
     * @example
     * // Create many FailedLoginAttempts
     * const failedLoginAttempt = await prisma.failedLoginAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FailedLoginAttemptCreateManyArgs>(args?: SelectSubset<T, FailedLoginAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FailedLoginAttempts and returns the data saved in the database.
     * @param {FailedLoginAttemptCreateManyAndReturnArgs} args - Arguments to create many FailedLoginAttempts.
     * @example
     * // Create many FailedLoginAttempts
     * const failedLoginAttempt = await prisma.failedLoginAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FailedLoginAttempts and only return the `id`
     * const failedLoginAttemptWithIdOnly = await prisma.failedLoginAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FailedLoginAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, FailedLoginAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FailedLoginAttempt.
     * @param {FailedLoginAttemptDeleteArgs} args - Arguments to delete one FailedLoginAttempt.
     * @example
     * // Delete one FailedLoginAttempt
     * const FailedLoginAttempt = await prisma.failedLoginAttempt.delete({
     *   where: {
     *     // ... filter to delete one FailedLoginAttempt
     *   }
     * })
     * 
     */
    delete<T extends FailedLoginAttemptDeleteArgs>(args: SelectSubset<T, FailedLoginAttemptDeleteArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FailedLoginAttempt.
     * @param {FailedLoginAttemptUpdateArgs} args - Arguments to update one FailedLoginAttempt.
     * @example
     * // Update one FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FailedLoginAttemptUpdateArgs>(args: SelectSubset<T, FailedLoginAttemptUpdateArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FailedLoginAttempts.
     * @param {FailedLoginAttemptDeleteManyArgs} args - Arguments to filter FailedLoginAttempts to delete.
     * @example
     * // Delete a few FailedLoginAttempts
     * const { count } = await prisma.failedLoginAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FailedLoginAttemptDeleteManyArgs>(args?: SelectSubset<T, FailedLoginAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedLoginAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FailedLoginAttempts
     * const failedLoginAttempt = await prisma.failedLoginAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FailedLoginAttemptUpdateManyArgs>(args: SelectSubset<T, FailedLoginAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedLoginAttempts and returns the data updated in the database.
     * @param {FailedLoginAttemptUpdateManyAndReturnArgs} args - Arguments to update many FailedLoginAttempts.
     * @example
     * // Update many FailedLoginAttempts
     * const failedLoginAttempt = await prisma.failedLoginAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FailedLoginAttempts and only return the `id`
     * const failedLoginAttemptWithIdOnly = await prisma.failedLoginAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FailedLoginAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, FailedLoginAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FailedLoginAttempt.
     * @param {FailedLoginAttemptUpsertArgs} args - Arguments to update or create a FailedLoginAttempt.
     * @example
     * // Update or create a FailedLoginAttempt
     * const failedLoginAttempt = await prisma.failedLoginAttempt.upsert({
     *   create: {
     *     // ... data to create a FailedLoginAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FailedLoginAttempt we want to update
     *   }
     * })
     */
    upsert<T extends FailedLoginAttemptUpsertArgs>(args: SelectSubset<T, FailedLoginAttemptUpsertArgs<ExtArgs>>): Prisma__FailedLoginAttemptClient<$Result.GetResult<Prisma.$FailedLoginAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FailedLoginAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptCountArgs} args - Arguments to filter FailedLoginAttempts to count.
     * @example
     * // Count the number of FailedLoginAttempts
     * const count = await prisma.failedLoginAttempt.count({
     *   where: {
     *     // ... the filter for the FailedLoginAttempts we want to count
     *   }
     * })
    **/
    count<T extends FailedLoginAttemptCountArgs>(
      args?: Subset<T, FailedLoginAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FailedLoginAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FailedLoginAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FailedLoginAttemptAggregateArgs>(args: Subset<T, FailedLoginAttemptAggregateArgs>): Prisma.PrismaPromise<GetFailedLoginAttemptAggregateType<T>>

    /**
     * Group by FailedLoginAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedLoginAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FailedLoginAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FailedLoginAttemptGroupByArgs['orderBy'] }
        : { orderBy?: FailedLoginAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FailedLoginAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailedLoginAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FailedLoginAttempt model
   */
  readonly fields: FailedLoginAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FailedLoginAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FailedLoginAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends FailedLoginAttempt$userArgs<ExtArgs> = {}>(args?: Subset<T, FailedLoginAttempt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FailedLoginAttempt model
   */
  interface FailedLoginAttemptFieldRefs {
    readonly id: FieldRef<"FailedLoginAttempt", 'String'>
    readonly userId: FieldRef<"FailedLoginAttempt", 'String'>
    readonly ip: FieldRef<"FailedLoginAttempt", 'String'>
    readonly createdAt: FieldRef<"FailedLoginAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FailedLoginAttempt findUnique
   */
  export type FailedLoginAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter, which FailedLoginAttempt to fetch.
     */
    where: FailedLoginAttemptWhereUniqueInput
  }

  /**
   * FailedLoginAttempt findUniqueOrThrow
   */
  export type FailedLoginAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter, which FailedLoginAttempt to fetch.
     */
    where: FailedLoginAttemptWhereUniqueInput
  }

  /**
   * FailedLoginAttempt findFirst
   */
  export type FailedLoginAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter, which FailedLoginAttempt to fetch.
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedLoginAttempts to fetch.
     */
    orderBy?: FailedLoginAttemptOrderByWithRelationInput | FailedLoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedLoginAttempts.
     */
    cursor?: FailedLoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedLoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedLoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedLoginAttempts.
     */
    distinct?: FailedLoginAttemptScalarFieldEnum | FailedLoginAttemptScalarFieldEnum[]
  }

  /**
   * FailedLoginAttempt findFirstOrThrow
   */
  export type FailedLoginAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter, which FailedLoginAttempt to fetch.
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedLoginAttempts to fetch.
     */
    orderBy?: FailedLoginAttemptOrderByWithRelationInput | FailedLoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedLoginAttempts.
     */
    cursor?: FailedLoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedLoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedLoginAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedLoginAttempts.
     */
    distinct?: FailedLoginAttemptScalarFieldEnum | FailedLoginAttemptScalarFieldEnum[]
  }

  /**
   * FailedLoginAttempt findMany
   */
  export type FailedLoginAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter, which FailedLoginAttempts to fetch.
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedLoginAttempts to fetch.
     */
    orderBy?: FailedLoginAttemptOrderByWithRelationInput | FailedLoginAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FailedLoginAttempts.
     */
    cursor?: FailedLoginAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedLoginAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedLoginAttempts.
     */
    skip?: number
    distinct?: FailedLoginAttemptScalarFieldEnum | FailedLoginAttemptScalarFieldEnum[]
  }

  /**
   * FailedLoginAttempt create
   */
  export type FailedLoginAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a FailedLoginAttempt.
     */
    data?: XOR<FailedLoginAttemptCreateInput, FailedLoginAttemptUncheckedCreateInput>
  }

  /**
   * FailedLoginAttempt createMany
   */
  export type FailedLoginAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FailedLoginAttempts.
     */
    data: FailedLoginAttemptCreateManyInput | FailedLoginAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedLoginAttempt createManyAndReturn
   */
  export type FailedLoginAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many FailedLoginAttempts.
     */
    data: FailedLoginAttemptCreateManyInput | FailedLoginAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FailedLoginAttempt update
   */
  export type FailedLoginAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a FailedLoginAttempt.
     */
    data: XOR<FailedLoginAttemptUpdateInput, FailedLoginAttemptUncheckedUpdateInput>
    /**
     * Choose, which FailedLoginAttempt to update.
     */
    where: FailedLoginAttemptWhereUniqueInput
  }

  /**
   * FailedLoginAttempt updateMany
   */
  export type FailedLoginAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FailedLoginAttempts.
     */
    data: XOR<FailedLoginAttemptUpdateManyMutationInput, FailedLoginAttemptUncheckedUpdateManyInput>
    /**
     * Filter which FailedLoginAttempts to update
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * Limit how many FailedLoginAttempts to update.
     */
    limit?: number
  }

  /**
   * FailedLoginAttempt updateManyAndReturn
   */
  export type FailedLoginAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * The data used to update FailedLoginAttempts.
     */
    data: XOR<FailedLoginAttemptUpdateManyMutationInput, FailedLoginAttemptUncheckedUpdateManyInput>
    /**
     * Filter which FailedLoginAttempts to update
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * Limit how many FailedLoginAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FailedLoginAttempt upsert
   */
  export type FailedLoginAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the FailedLoginAttempt to update in case it exists.
     */
    where: FailedLoginAttemptWhereUniqueInput
    /**
     * In case the FailedLoginAttempt found by the `where` argument doesn't exist, create a new FailedLoginAttempt with this data.
     */
    create: XOR<FailedLoginAttemptCreateInput, FailedLoginAttemptUncheckedCreateInput>
    /**
     * In case the FailedLoginAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FailedLoginAttemptUpdateInput, FailedLoginAttemptUncheckedUpdateInput>
  }

  /**
   * FailedLoginAttempt delete
   */
  export type FailedLoginAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
    /**
     * Filter which FailedLoginAttempt to delete.
     */
    where: FailedLoginAttemptWhereUniqueInput
  }

  /**
   * FailedLoginAttempt deleteMany
   */
  export type FailedLoginAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedLoginAttempts to delete
     */
    where?: FailedLoginAttemptWhereInput
    /**
     * Limit how many FailedLoginAttempts to delete.
     */
    limit?: number
  }

  /**
   * FailedLoginAttempt.user
   */
  export type FailedLoginAttempt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FailedLoginAttempt without action
   */
  export type FailedLoginAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedLoginAttempt
     */
    select?: FailedLoginAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedLoginAttempt
     */
    omit?: FailedLoginAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FailedLoginAttemptInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    lastSeenAt: Date | null
    endedAt: Date | null
    ip: string | null
    userAgent: string | null
    active: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    lastSeenAt: Date | null
    endedAt: Date | null
    ip: string | null
    userAgent: string | null
    active: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    startedAt: number
    lastSeenAt: number
    endedAt: number
    ip: number
    userAgent: number
    active: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    lastSeenAt?: true
    endedAt?: true
    ip?: true
    userAgent?: true
    active?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    lastSeenAt?: true
    endedAt?: true
    ip?: true
    userAgent?: true
    active?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    lastSeenAt?: true
    endedAt?: true
    ip?: true
    userAgent?: true
    active?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    startedAt: Date
    lastSeenAt: Date
    endedAt: Date | null
    ip: string | null
    userAgent: string | null
    active: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    lastSeenAt?: boolean
    endedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    lastSeenAt?: boolean
    endedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    lastSeenAt?: boolean
    endedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    lastSeenAt?: boolean
    endedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    active?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startedAt" | "lastSeenAt" | "endedAt" | "ip" | "userAgent" | "active", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startedAt: Date
      lastSeenAt: Date
      endedAt: Date | null
      ip: string | null
      userAgent: string | null
      active: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly startedAt: FieldRef<"Session", 'DateTime'>
    readonly lastSeenAt: FieldRef<"Session", 'DateTime'>
    readonly endedAt: FieldRef<"Session", 'DateTime'>
    readonly ip: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly active: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    maxAttendees: number | null
    accessCount: number | null
    downloadCount: number | null
    projectId: number | null
    reportId: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    maxAttendees: number | null
    accessCount: number | null
    downloadCount: number | null
    projectId: number | null
    reportId: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    slug: string | null
    eventTitle: string | null
    eventLocation: string | null
    eventBanner: string | null
    eventFile: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventStatus: $Enums.EventStatus | null
    publishStatus: $Enums.PublishStatus | null
    eventAttendance: $Enums.AttendanceType | null
    maxAttendees: number | null
    accessCount: number | null
    downloadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdById: string | null
    updatedById: string | null
    projectId: number | null
    reportId: number | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    eventTitle: string | null
    eventLocation: string | null
    eventBanner: string | null
    eventFile: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventStatus: $Enums.EventStatus | null
    publishStatus: $Enums.PublishStatus | null
    eventAttendance: $Enums.AttendanceType | null
    maxAttendees: number | null
    accessCount: number | null
    downloadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    createdById: string | null
    updatedById: string | null
    projectId: number | null
    reportId: number | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    slug: number
    eventTitle: number
    eventDescription: number
    eventDetails: number
    eventLocation: number
    eventBanner: number
    eventImages: number
    eventFile: number
    eventStartDate: number
    eventEndDate: number
    eventTags: number
    eventStatus: number
    publishStatus: number
    eventAttendance: number
    maxAttendees: number
    accessCount: number
    downloadCount: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    createdById: number
    updatedById: number
    projectId: number
    reportId: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    maxAttendees?: true
    accessCount?: true
    downloadCount?: true
    projectId?: true
    reportId?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    maxAttendees?: true
    accessCount?: true
    downloadCount?: true
    projectId?: true
    reportId?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    slug?: true
    eventTitle?: true
    eventLocation?: true
    eventBanner?: true
    eventFile?: true
    eventStartDate?: true
    eventEndDate?: true
    eventStatus?: true
    publishStatus?: true
    eventAttendance?: true
    maxAttendees?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
    projectId?: true
    reportId?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    slug?: true
    eventTitle?: true
    eventLocation?: true
    eventBanner?: true
    eventFile?: true
    eventStartDate?: true
    eventEndDate?: true
    eventStatus?: true
    publishStatus?: true
    eventAttendance?: true
    maxAttendees?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
    projectId?: true
    reportId?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    slug?: true
    eventTitle?: true
    eventDescription?: true
    eventDetails?: true
    eventLocation?: true
    eventBanner?: true
    eventImages?: true
    eventFile?: true
    eventStartDate?: true
    eventEndDate?: true
    eventTags?: true
    eventStatus?: true
    publishStatus?: true
    eventAttendance?: true
    maxAttendees?: true
    accessCount?: true
    downloadCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    createdById?: true
    updatedById?: true
    projectId?: true
    reportId?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    slug: string
    eventTitle: string
    eventDescription: JsonValue
    eventDetails: JsonValue | null
    eventLocation: string | null
    eventBanner: string
    eventImages: string[]
    eventFile: string
    eventStartDate: Date
    eventEndDate: Date
    eventTags: string[]
    eventStatus: $Enums.EventStatus
    publishStatus: $Enums.PublishStatus
    eventAttendance: $Enums.AttendanceType
    maxAttendees: number | null
    accessCount: number
    downloadCount: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    createdById: string
    updatedById: string
    projectId: number | null
    reportId: number | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    eventTitle?: boolean
    eventDescription?: boolean
    eventDetails?: boolean
    eventLocation?: boolean
    eventBanner?: boolean
    eventImages?: boolean
    eventFile?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventTags?: boolean
    eventStatus?: boolean
    publishStatus?: boolean
    eventAttendance?: boolean
    maxAttendees?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    projectId?: boolean
    reportId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    eventTitle?: boolean
    eventDescription?: boolean
    eventDetails?: boolean
    eventLocation?: boolean
    eventBanner?: boolean
    eventImages?: boolean
    eventFile?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventTags?: boolean
    eventStatus?: boolean
    publishStatus?: boolean
    eventAttendance?: boolean
    maxAttendees?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    projectId?: boolean
    reportId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    eventTitle?: boolean
    eventDescription?: boolean
    eventDetails?: boolean
    eventLocation?: boolean
    eventBanner?: boolean
    eventImages?: boolean
    eventFile?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventTags?: boolean
    eventStatus?: boolean
    publishStatus?: boolean
    eventAttendance?: boolean
    maxAttendees?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    projectId?: boolean
    reportId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    slug?: boolean
    eventTitle?: boolean
    eventDescription?: boolean
    eventDetails?: boolean
    eventLocation?: boolean
    eventBanner?: boolean
    eventImages?: boolean
    eventFile?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventTags?: boolean
    eventStatus?: boolean
    publishStatus?: boolean
    eventAttendance?: boolean
    maxAttendees?: boolean
    accessCount?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    projectId?: boolean
    reportId?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "eventTitle" | "eventDescription" | "eventDetails" | "eventLocation" | "eventBanner" | "eventImages" | "eventFile" | "eventStartDate" | "eventEndDate" | "eventTags" | "eventStatus" | "publishStatus" | "eventAttendance" | "maxAttendees" | "accessCount" | "downloadCount" | "createdAt" | "updatedAt" | "deletedAt" | "createdById" | "updatedById" | "projectId" | "reportId", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Event$projectArgs<ExtArgs>
    report?: boolean | Event$reportArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      report: Prisma.$ReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      eventTitle: string
      eventDescription: Prisma.JsonValue
      eventDetails: Prisma.JsonValue | null
      eventLocation: string | null
      eventBanner: string
      eventImages: string[]
      eventFile: string
      eventStartDate: Date
      eventEndDate: Date
      eventTags: string[]
      eventStatus: $Enums.EventStatus
      publishStatus: $Enums.PublishStatus
      eventAttendance: $Enums.AttendanceType
      maxAttendees: number | null
      accessCount: number
      downloadCount: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      createdById: string
      updatedById: string
      projectId: number | null
      reportId: number | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends Event$projectArgs<ExtArgs> = {}>(args?: Subset<T, Event$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    report<T extends Event$reportArgs<ExtArgs> = {}>(args?: Subset<T, Event$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly slug: FieldRef<"Event", 'String'>
    readonly eventTitle: FieldRef<"Event", 'String'>
    readonly eventDescription: FieldRef<"Event", 'Json'>
    readonly eventDetails: FieldRef<"Event", 'Json'>
    readonly eventLocation: FieldRef<"Event", 'String'>
    readonly eventBanner: FieldRef<"Event", 'String'>
    readonly eventImages: FieldRef<"Event", 'String[]'>
    readonly eventFile: FieldRef<"Event", 'String'>
    readonly eventStartDate: FieldRef<"Event", 'DateTime'>
    readonly eventEndDate: FieldRef<"Event", 'DateTime'>
    readonly eventTags: FieldRef<"Event", 'String[]'>
    readonly eventStatus: FieldRef<"Event", 'EventStatus'>
    readonly publishStatus: FieldRef<"Event", 'PublishStatus'>
    readonly eventAttendance: FieldRef<"Event", 'AttendanceType'>
    readonly maxAttendees: FieldRef<"Event", 'Int'>
    readonly accessCount: FieldRef<"Event", 'Int'>
    readonly downloadCount: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
    readonly deletedAt: FieldRef<"Event", 'DateTime'>
    readonly createdById: FieldRef<"Event", 'String'>
    readonly updatedById: FieldRef<"Event", 'String'>
    readonly projectId: FieldRef<"Event", 'Int'>
    readonly reportId: FieldRef<"Event", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.project
   */
  export type Event$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Event.report
   */
  export type Event$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    viewCount: number | null
    likeCount: number | null
  }

  export type VideoSumAggregateOutputType = {
    viewCount: number | null
    likeCount: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    publishedAt: Date | null
    viewCount: number | null
    likeCount: number | null
    duration: string | null
    fetchedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    publishedAt: Date | null
    viewCount: number | null
    likeCount: number | null
    duration: string | null
    fetchedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail: number
    publishedAt: number
    viewCount: number
    likeCount: number
    duration: number
    fetchedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    viewCount?: true
    likeCount?: true
  }

  export type VideoSumAggregateInputType = {
    viewCount?: true
    likeCount?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    publishedAt?: true
    viewCount?: true
    likeCount?: true
    duration?: true
    fetchedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    publishedAt?: true
    viewCount?: true
    likeCount?: true
    duration?: true
    fetchedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    publishedAt?: true
    viewCount?: true
    likeCount?: true
    duration?: true
    fetchedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    title: string
    description: string
    thumbnail: string
    publishedAt: Date
    viewCount: number | null
    likeCount: number | null
    duration: string
    fetchedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    duration?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    duration?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    duration?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    duration?: boolean
    fetchedAt?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail" | "publishedAt" | "viewCount" | "likeCount" | "duration" | "fetchedAt", ExtArgs["result"]["video"]>

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      thumbnail: string
      publishedAt: Date
      viewCount: number | null
      likeCount: number | null
      duration: string
      fetchedAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideoUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly title: FieldRef<"Video", 'String'>
    readonly description: FieldRef<"Video", 'String'>
    readonly thumbnail: FieldRef<"Video", 'String'>
    readonly publishedAt: FieldRef<"Video", 'DateTime'>
    readonly viewCount: FieldRef<"Video", 'Int'>
    readonly likeCount: FieldRef<"Video", 'Int'>
    readonly duration: FieldRef<"Video", 'String'>
    readonly fetchedAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video updateManyAndReturn
   */
  export type VideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
  }


  /**
   * Model YouTubeCacheMeta
   */

  export type AggregateYouTubeCacheMeta = {
    _count: YouTubeCacheMetaCountAggregateOutputType | null
    _avg: YouTubeCacheMetaAvgAggregateOutputType | null
    _sum: YouTubeCacheMetaSumAggregateOutputType | null
    _min: YouTubeCacheMetaMinAggregateOutputType | null
    _max: YouTubeCacheMetaMaxAggregateOutputType | null
  }

  export type YouTubeCacheMetaAvgAggregateOutputType = {
    id: number | null
  }

  export type YouTubeCacheMetaSumAggregateOutputType = {
    id: number | null
  }

  export type YouTubeCacheMetaMinAggregateOutputType = {
    id: number | null
    lastFetched: Date | null
  }

  export type YouTubeCacheMetaMaxAggregateOutputType = {
    id: number | null
    lastFetched: Date | null
  }

  export type YouTubeCacheMetaCountAggregateOutputType = {
    id: number
    lastFetched: number
    _all: number
  }


  export type YouTubeCacheMetaAvgAggregateInputType = {
    id?: true
  }

  export type YouTubeCacheMetaSumAggregateInputType = {
    id?: true
  }

  export type YouTubeCacheMetaMinAggregateInputType = {
    id?: true
    lastFetched?: true
  }

  export type YouTubeCacheMetaMaxAggregateInputType = {
    id?: true
    lastFetched?: true
  }

  export type YouTubeCacheMetaCountAggregateInputType = {
    id?: true
    lastFetched?: true
    _all?: true
  }

  export type YouTubeCacheMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTubeCacheMeta to aggregate.
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCacheMetas to fetch.
     */
    orderBy?: YouTubeCacheMetaOrderByWithRelationInput | YouTubeCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YouTubeCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YouTubeCacheMetas
    **/
    _count?: true | YouTubeCacheMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YouTubeCacheMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YouTubeCacheMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YouTubeCacheMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YouTubeCacheMetaMaxAggregateInputType
  }

  export type GetYouTubeCacheMetaAggregateType<T extends YouTubeCacheMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateYouTubeCacheMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYouTubeCacheMeta[P]>
      : GetScalarType<T[P], AggregateYouTubeCacheMeta[P]>
  }




  export type YouTubeCacheMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YouTubeCacheMetaWhereInput
    orderBy?: YouTubeCacheMetaOrderByWithAggregationInput | YouTubeCacheMetaOrderByWithAggregationInput[]
    by: YouTubeCacheMetaScalarFieldEnum[] | YouTubeCacheMetaScalarFieldEnum
    having?: YouTubeCacheMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YouTubeCacheMetaCountAggregateInputType | true
    _avg?: YouTubeCacheMetaAvgAggregateInputType
    _sum?: YouTubeCacheMetaSumAggregateInputType
    _min?: YouTubeCacheMetaMinAggregateInputType
    _max?: YouTubeCacheMetaMaxAggregateInputType
  }

  export type YouTubeCacheMetaGroupByOutputType = {
    id: number
    lastFetched: Date
    _count: YouTubeCacheMetaCountAggregateOutputType | null
    _avg: YouTubeCacheMetaAvgAggregateOutputType | null
    _sum: YouTubeCacheMetaSumAggregateOutputType | null
    _min: YouTubeCacheMetaMinAggregateOutputType | null
    _max: YouTubeCacheMetaMaxAggregateOutputType | null
  }

  type GetYouTubeCacheMetaGroupByPayload<T extends YouTubeCacheMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YouTubeCacheMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YouTubeCacheMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YouTubeCacheMetaGroupByOutputType[P]>
            : GetScalarType<T[P], YouTubeCacheMetaGroupByOutputType[P]>
        }
      >
    >


  export type YouTubeCacheMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["youTubeCacheMeta"]>

  export type YouTubeCacheMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["youTubeCacheMeta"]>

  export type YouTubeCacheMetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["youTubeCacheMeta"]>

  export type YouTubeCacheMetaSelectScalar = {
    id?: boolean
    lastFetched?: boolean
  }

  export type YouTubeCacheMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastFetched", ExtArgs["result"]["youTubeCacheMeta"]>

  export type $YouTubeCacheMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YouTubeCacheMeta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lastFetched: Date
    }, ExtArgs["result"]["youTubeCacheMeta"]>
    composites: {}
  }

  type YouTubeCacheMetaGetPayload<S extends boolean | null | undefined | YouTubeCacheMetaDefaultArgs> = $Result.GetResult<Prisma.$YouTubeCacheMetaPayload, S>

  type YouTubeCacheMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YouTubeCacheMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YouTubeCacheMetaCountAggregateInputType | true
    }

  export interface YouTubeCacheMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YouTubeCacheMeta'], meta: { name: 'YouTubeCacheMeta' } }
    /**
     * Find zero or one YouTubeCacheMeta that matches the filter.
     * @param {YouTubeCacheMetaFindUniqueArgs} args - Arguments to find a YouTubeCacheMeta
     * @example
     * // Get one YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YouTubeCacheMetaFindUniqueArgs>(args: SelectSubset<T, YouTubeCacheMetaFindUniqueArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YouTubeCacheMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YouTubeCacheMetaFindUniqueOrThrowArgs} args - Arguments to find a YouTubeCacheMeta
     * @example
     * // Get one YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YouTubeCacheMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, YouTubeCacheMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YouTubeCacheMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaFindFirstArgs} args - Arguments to find a YouTubeCacheMeta
     * @example
     * // Get one YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YouTubeCacheMetaFindFirstArgs>(args?: SelectSubset<T, YouTubeCacheMetaFindFirstArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YouTubeCacheMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaFindFirstOrThrowArgs} args - Arguments to find a YouTubeCacheMeta
     * @example
     * // Get one YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YouTubeCacheMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, YouTubeCacheMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YouTubeCacheMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YouTubeCacheMetas
     * const youTubeCacheMetas = await prisma.youTubeCacheMeta.findMany()
     * 
     * // Get first 10 YouTubeCacheMetas
     * const youTubeCacheMetas = await prisma.youTubeCacheMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youTubeCacheMetaWithIdOnly = await prisma.youTubeCacheMeta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YouTubeCacheMetaFindManyArgs>(args?: SelectSubset<T, YouTubeCacheMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YouTubeCacheMeta.
     * @param {YouTubeCacheMetaCreateArgs} args - Arguments to create a YouTubeCacheMeta.
     * @example
     * // Create one YouTubeCacheMeta
     * const YouTubeCacheMeta = await prisma.youTubeCacheMeta.create({
     *   data: {
     *     // ... data to create a YouTubeCacheMeta
     *   }
     * })
     * 
     */
    create<T extends YouTubeCacheMetaCreateArgs>(args: SelectSubset<T, YouTubeCacheMetaCreateArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YouTubeCacheMetas.
     * @param {YouTubeCacheMetaCreateManyArgs} args - Arguments to create many YouTubeCacheMetas.
     * @example
     * // Create many YouTubeCacheMetas
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YouTubeCacheMetaCreateManyArgs>(args?: SelectSubset<T, YouTubeCacheMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YouTubeCacheMetas and returns the data saved in the database.
     * @param {YouTubeCacheMetaCreateManyAndReturnArgs} args - Arguments to create many YouTubeCacheMetas.
     * @example
     * // Create many YouTubeCacheMetas
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YouTubeCacheMetas and only return the `id`
     * const youTubeCacheMetaWithIdOnly = await prisma.youTubeCacheMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YouTubeCacheMetaCreateManyAndReturnArgs>(args?: SelectSubset<T, YouTubeCacheMetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YouTubeCacheMeta.
     * @param {YouTubeCacheMetaDeleteArgs} args - Arguments to delete one YouTubeCacheMeta.
     * @example
     * // Delete one YouTubeCacheMeta
     * const YouTubeCacheMeta = await prisma.youTubeCacheMeta.delete({
     *   where: {
     *     // ... filter to delete one YouTubeCacheMeta
     *   }
     * })
     * 
     */
    delete<T extends YouTubeCacheMetaDeleteArgs>(args: SelectSubset<T, YouTubeCacheMetaDeleteArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YouTubeCacheMeta.
     * @param {YouTubeCacheMetaUpdateArgs} args - Arguments to update one YouTubeCacheMeta.
     * @example
     * // Update one YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YouTubeCacheMetaUpdateArgs>(args: SelectSubset<T, YouTubeCacheMetaUpdateArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YouTubeCacheMetas.
     * @param {YouTubeCacheMetaDeleteManyArgs} args - Arguments to filter YouTubeCacheMetas to delete.
     * @example
     * // Delete a few YouTubeCacheMetas
     * const { count } = await prisma.youTubeCacheMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YouTubeCacheMetaDeleteManyArgs>(args?: SelectSubset<T, YouTubeCacheMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubeCacheMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YouTubeCacheMetas
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YouTubeCacheMetaUpdateManyArgs>(args: SelectSubset<T, YouTubeCacheMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubeCacheMetas and returns the data updated in the database.
     * @param {YouTubeCacheMetaUpdateManyAndReturnArgs} args - Arguments to update many YouTubeCacheMetas.
     * @example
     * // Update many YouTubeCacheMetas
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YouTubeCacheMetas and only return the `id`
     * const youTubeCacheMetaWithIdOnly = await prisma.youTubeCacheMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YouTubeCacheMetaUpdateManyAndReturnArgs>(args: SelectSubset<T, YouTubeCacheMetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YouTubeCacheMeta.
     * @param {YouTubeCacheMetaUpsertArgs} args - Arguments to update or create a YouTubeCacheMeta.
     * @example
     * // Update or create a YouTubeCacheMeta
     * const youTubeCacheMeta = await prisma.youTubeCacheMeta.upsert({
     *   create: {
     *     // ... data to create a YouTubeCacheMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YouTubeCacheMeta we want to update
     *   }
     * })
     */
    upsert<T extends YouTubeCacheMetaUpsertArgs>(args: SelectSubset<T, YouTubeCacheMetaUpsertArgs<ExtArgs>>): Prisma__YouTubeCacheMetaClient<$Result.GetResult<Prisma.$YouTubeCacheMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YouTubeCacheMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaCountArgs} args - Arguments to filter YouTubeCacheMetas to count.
     * @example
     * // Count the number of YouTubeCacheMetas
     * const count = await prisma.youTubeCacheMeta.count({
     *   where: {
     *     // ... the filter for the YouTubeCacheMetas we want to count
     *   }
     * })
    **/
    count<T extends YouTubeCacheMetaCountArgs>(
      args?: Subset<T, YouTubeCacheMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YouTubeCacheMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YouTubeCacheMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YouTubeCacheMetaAggregateArgs>(args: Subset<T, YouTubeCacheMetaAggregateArgs>): Prisma.PrismaPromise<GetYouTubeCacheMetaAggregateType<T>>

    /**
     * Group by YouTubeCacheMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeCacheMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YouTubeCacheMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YouTubeCacheMetaGroupByArgs['orderBy'] }
        : { orderBy?: YouTubeCacheMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YouTubeCacheMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYouTubeCacheMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YouTubeCacheMeta model
   */
  readonly fields: YouTubeCacheMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YouTubeCacheMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YouTubeCacheMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YouTubeCacheMeta model
   */
  interface YouTubeCacheMetaFieldRefs {
    readonly id: FieldRef<"YouTubeCacheMeta", 'Int'>
    readonly lastFetched: FieldRef<"YouTubeCacheMeta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * YouTubeCacheMeta findUnique
   */
  export type YouTubeCacheMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which YouTubeCacheMeta to fetch.
     */
    where: YouTubeCacheMetaWhereUniqueInput
  }

  /**
   * YouTubeCacheMeta findUniqueOrThrow
   */
  export type YouTubeCacheMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which YouTubeCacheMeta to fetch.
     */
    where: YouTubeCacheMetaWhereUniqueInput
  }

  /**
   * YouTubeCacheMeta findFirst
   */
  export type YouTubeCacheMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which YouTubeCacheMeta to fetch.
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCacheMetas to fetch.
     */
    orderBy?: YouTubeCacheMetaOrderByWithRelationInput | YouTubeCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeCacheMetas.
     */
    cursor?: YouTubeCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeCacheMetas.
     */
    distinct?: YouTubeCacheMetaScalarFieldEnum | YouTubeCacheMetaScalarFieldEnum[]
  }

  /**
   * YouTubeCacheMeta findFirstOrThrow
   */
  export type YouTubeCacheMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which YouTubeCacheMeta to fetch.
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCacheMetas to fetch.
     */
    orderBy?: YouTubeCacheMetaOrderByWithRelationInput | YouTubeCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeCacheMetas.
     */
    cursor?: YouTubeCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeCacheMetas.
     */
    distinct?: YouTubeCacheMetaScalarFieldEnum | YouTubeCacheMetaScalarFieldEnum[]
  }

  /**
   * YouTubeCacheMeta findMany
   */
  export type YouTubeCacheMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which YouTubeCacheMetas to fetch.
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeCacheMetas to fetch.
     */
    orderBy?: YouTubeCacheMetaOrderByWithRelationInput | YouTubeCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YouTubeCacheMetas.
     */
    cursor?: YouTubeCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeCacheMetas.
     */
    skip?: number
    distinct?: YouTubeCacheMetaScalarFieldEnum | YouTubeCacheMetaScalarFieldEnum[]
  }

  /**
   * YouTubeCacheMeta create
   */
  export type YouTubeCacheMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * The data needed to create a YouTubeCacheMeta.
     */
    data: XOR<YouTubeCacheMetaCreateInput, YouTubeCacheMetaUncheckedCreateInput>
  }

  /**
   * YouTubeCacheMeta createMany
   */
  export type YouTubeCacheMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YouTubeCacheMetas.
     */
    data: YouTubeCacheMetaCreateManyInput | YouTubeCacheMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YouTubeCacheMeta createManyAndReturn
   */
  export type YouTubeCacheMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * The data used to create many YouTubeCacheMetas.
     */
    data: YouTubeCacheMetaCreateManyInput | YouTubeCacheMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YouTubeCacheMeta update
   */
  export type YouTubeCacheMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * The data needed to update a YouTubeCacheMeta.
     */
    data: XOR<YouTubeCacheMetaUpdateInput, YouTubeCacheMetaUncheckedUpdateInput>
    /**
     * Choose, which YouTubeCacheMeta to update.
     */
    where: YouTubeCacheMetaWhereUniqueInput
  }

  /**
   * YouTubeCacheMeta updateMany
   */
  export type YouTubeCacheMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YouTubeCacheMetas.
     */
    data: XOR<YouTubeCacheMetaUpdateManyMutationInput, YouTubeCacheMetaUncheckedUpdateManyInput>
    /**
     * Filter which YouTubeCacheMetas to update
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * Limit how many YouTubeCacheMetas to update.
     */
    limit?: number
  }

  /**
   * YouTubeCacheMeta updateManyAndReturn
   */
  export type YouTubeCacheMetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * The data used to update YouTubeCacheMetas.
     */
    data: XOR<YouTubeCacheMetaUpdateManyMutationInput, YouTubeCacheMetaUncheckedUpdateManyInput>
    /**
     * Filter which YouTubeCacheMetas to update
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * Limit how many YouTubeCacheMetas to update.
     */
    limit?: number
  }

  /**
   * YouTubeCacheMeta upsert
   */
  export type YouTubeCacheMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * The filter to search for the YouTubeCacheMeta to update in case it exists.
     */
    where: YouTubeCacheMetaWhereUniqueInput
    /**
     * In case the YouTubeCacheMeta found by the `where` argument doesn't exist, create a new YouTubeCacheMeta with this data.
     */
    create: XOR<YouTubeCacheMetaCreateInput, YouTubeCacheMetaUncheckedCreateInput>
    /**
     * In case the YouTubeCacheMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YouTubeCacheMetaUpdateInput, YouTubeCacheMetaUncheckedUpdateInput>
  }

  /**
   * YouTubeCacheMeta delete
   */
  export type YouTubeCacheMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
    /**
     * Filter which YouTubeCacheMeta to delete.
     */
    where: YouTubeCacheMetaWhereUniqueInput
  }

  /**
   * YouTubeCacheMeta deleteMany
   */
  export type YouTubeCacheMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YouTubeCacheMetas to delete
     */
    where?: YouTubeCacheMetaWhereInput
    /**
     * Limit how many YouTubeCacheMetas to delete.
     */
    limit?: number
  }

  /**
   * YouTubeCacheMeta without action
   */
  export type YouTubeCacheMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YouTubeCacheMeta
     */
    select?: YouTubeCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YouTubeCacheMeta
     */
    omit?: YouTubeCacheMetaOmit<ExtArgs> | null
  }


  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    logo: string | null
    headName: string | null
    institutionType: $Enums.InstitutionType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    logo: string | null
    headName: string | null
    institutionType: $Enums.InstitutionType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    logo: number
    institutionImages: number
    headName: number
    institutionType: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    approvedById: number
    _all: number
  }


  export type InstitutionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    logo?: true
    headName?: true
    institutionType?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    logo?: true
    headName?: true
    institutionType?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    logo?: true
    institutionImages?: true
    headName?: true
    institutionType?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    logo: string | null
    institutionImages: string[]
    headName: string | null
    institutionType: $Enums.InstitutionType
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string | null
    approvedById: string | null
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    logo?: boolean
    institutionImages?: boolean
    headName?: boolean
    institutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    locations?: boolean | Institution$locationsArgs<ExtArgs>
    beneficiaries?: boolean | Institution$beneficiariesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    logo?: boolean
    institutionImages?: boolean
    headName?: boolean
    institutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    logo?: boolean
    institutionImages?: boolean
    headName?: boolean
    institutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    logo?: boolean
    institutionImages?: boolean
    headName?: boolean
    institutionType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "logo" | "institutionImages" | "headName" | "institutionType" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "approvedById", ExtArgs["result"]["institution"]>
  export type InstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Institution$locationsArgs<ExtArgs>
    beneficiaries?: boolean | Institution$beneficiariesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
  }
  export type InstitutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Institution$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Institution$approvedByArgs<ExtArgs>
  }

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
      beneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      logo: string | null
      institutionImages: string[]
      headName: string | null
      institutionType: $Enums.InstitutionType
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string | null
      approvedById: string | null
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutions and returns the data saved in the database.
     * @param {InstitutionCreateManyAndReturnArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions and returns the data updated in the database.
     * @param {InstitutionUpdateManyAndReturnArgs} args - Arguments to update many Institutions.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends Institution$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    beneficiaries<T extends Institution$beneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$beneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Institution$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Institution$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Institution$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Institution$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly email: FieldRef<"Institution", 'String'>
    readonly phone: FieldRef<"Institution", 'String'>
    readonly logo: FieldRef<"Institution", 'String'>
    readonly institutionImages: FieldRef<"Institution", 'String[]'>
    readonly headName: FieldRef<"Institution", 'String'>
    readonly institutionType: FieldRef<"Institution", 'InstitutionType'>
    readonly createdAt: FieldRef<"Institution", 'DateTime'>
    readonly updatedAt: FieldRef<"Institution", 'DateTime'>
    readonly createdById: FieldRef<"Institution", 'String'>
    readonly updatedById: FieldRef<"Institution", 'String'>
    readonly approvedById: FieldRef<"Institution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institution createManyAndReturn
   */
  export type InstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution updateManyAndReturn
   */
  export type InstitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution.locations
   */
  export type Institution$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Institution.beneficiaries
   */
  export type Institution$beneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Institution.updatedBy
   */
  export type Institution$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Institution.approvedBy
   */
  export type Institution$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    locationName: string | null
    latitude: number | null
    longitude: number | null
    institutionId: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    locationName: string | null
    latitude: number | null
    longitude: number | null
    institutionId: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    locationName: number
    latitude: number
    longitude: number
    institutionId: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    locationName?: true
    latitude?: true
    longitude?: true
    institutionId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    locationName?: true
    latitude?: true
    longitude?: true
    institutionId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    locationName?: true
    latitude?: true
    longitude?: true
    institutionId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    locationName: string | null
    latitude: number | null
    longitude: number | null
    institutionId: string
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    latitude?: boolean
    longitude?: boolean
    institutionId?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    latitude?: boolean
    longitude?: boolean
    institutionId?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationName?: boolean
    latitude?: boolean
    longitude?: boolean
    institutionId?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    locationName?: boolean
    latitude?: boolean
    longitude?: boolean
    institutionId?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationName" | "latitude" | "longitude" | "institutionId", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationName: string | null
      latitude: number | null
      longitude: number | null
      institutionId: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly locationName: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly institutionId: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Beneficiary
   */

  export type AggregateBeneficiary = {
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  export type BeneficiaryMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    image: string | null
    gender: $Enums.GenderType | null
    email: string | null
    phone: string | null
    dateOfBirth: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    beneficiaryStatus: $Enums.PublishStatus | null
    institutionId: string | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type BeneficiaryMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    image: string | null
    gender: $Enums.GenderType | null
    email: string | null
    phone: string | null
    dateOfBirth: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    beneficiaryStatus: $Enums.PublishStatus | null
    institutionId: string | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type BeneficiaryCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    image: number
    images: number
    gender: number
    email: number
    phone: number
    dateOfBirth: number
    createdAt: number
    updatedAt: number
    beneficiaryStatus: number
    institutionId: number
    createdById: number
    updatedById: number
    approvedById: number
    _all: number
  }


  export type BeneficiaryMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    gender?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    beneficiaryStatus?: true
    institutionId?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type BeneficiaryMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    gender?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    beneficiaryStatus?: true
    institutionId?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type BeneficiaryCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    images?: true
    gender?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    beneficiaryStatus?: true
    institutionId?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    _all?: true
  }

  export type BeneficiaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beneficiary to aggregate.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beneficiaries
    **/
    _count?: true | BeneficiaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiaryMaxAggregateInputType
  }

  export type GetBeneficiaryAggregateType<T extends BeneficiaryAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficiary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficiary[P]>
      : GetScalarType<T[P], AggregateBeneficiary[P]>
  }




  export type BeneficiaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithAggregationInput | BeneficiaryOrderByWithAggregationInput[]
    by: BeneficiaryScalarFieldEnum[] | BeneficiaryScalarFieldEnum
    having?: BeneficiaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiaryCountAggregateInputType | true
    _min?: BeneficiaryMinAggregateInputType
    _max?: BeneficiaryMaxAggregateInputType
  }

  export type BeneficiaryGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    image: string | null
    images: string[]
    gender: $Enums.GenderType
    email: string | null
    phone: string | null
    dateOfBirth: Date
    createdAt: Date
    updatedAt: Date
    beneficiaryStatus: $Enums.PublishStatus
    institutionId: string | null
    createdById: string
    updatedById: string | null
    approvedById: string | null
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  type GetBeneficiaryGroupByPayload<T extends BeneficiaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeneficiaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
        }
      >
    >


  export type BeneficiarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    images?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beneficiaryStatus?: boolean
    institutionId?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    messages?: boolean | Beneficiary$messagesArgs<ExtArgs>
    responses?: boolean | Beneficiary$responsesArgs<ExtArgs>
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
    _count?: boolean | BeneficiaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiary"]>

  export type BeneficiarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    images?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beneficiaryStatus?: boolean
    institutionId?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiary"]>

  export type BeneficiarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    images?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beneficiaryStatus?: boolean
    institutionId?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiary"]>

  export type BeneficiarySelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    images?: boolean
    gender?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beneficiaryStatus?: boolean
    institutionId?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
  }

  export type BeneficiaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "image" | "images" | "gender" | "email" | "phone" | "dateOfBirth" | "createdAt" | "updatedAt" | "beneficiaryStatus" | "institutionId" | "createdById" | "updatedById" | "approvedById", ExtArgs["result"]["beneficiary"]>
  export type BeneficiaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Beneficiary$messagesArgs<ExtArgs>
    responses?: boolean | Beneficiary$responsesArgs<ExtArgs>
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
    _count?: boolean | BeneficiaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BeneficiaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
  }
  export type BeneficiaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Beneficiary$institutionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Beneficiary$updatedByArgs<ExtArgs>
    approvedBy?: boolean | Beneficiary$approvedByArgs<ExtArgs>
  }

  export type $BeneficiaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Beneficiary"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      responses: Prisma.$ResponsePayload<ExtArgs>[]
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      image: string | null
      images: string[]
      gender: $Enums.GenderType
      email: string | null
      phone: string | null
      dateOfBirth: Date
      createdAt: Date
      updatedAt: Date
      beneficiaryStatus: $Enums.PublishStatus
      institutionId: string | null
      createdById: string
      updatedById: string | null
      approvedById: string | null
    }, ExtArgs["result"]["beneficiary"]>
    composites: {}
  }

  type BeneficiaryGetPayload<S extends boolean | null | undefined | BeneficiaryDefaultArgs> = $Result.GetResult<Prisma.$BeneficiaryPayload, S>

  type BeneficiaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BeneficiaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BeneficiaryCountAggregateInputType | true
    }

  export interface BeneficiaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Beneficiary'], meta: { name: 'Beneficiary' } }
    /**
     * Find zero or one Beneficiary that matches the filter.
     * @param {BeneficiaryFindUniqueArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeneficiaryFindUniqueArgs>(args: SelectSubset<T, BeneficiaryFindUniqueArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Beneficiary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BeneficiaryFindUniqueOrThrowArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeneficiaryFindUniqueOrThrowArgs>(args: SelectSubset<T, BeneficiaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Beneficiary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindFirstArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeneficiaryFindFirstArgs>(args?: SelectSubset<T, BeneficiaryFindFirstArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Beneficiary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindFirstOrThrowArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeneficiaryFindFirstOrThrowArgs>(args?: SelectSubset<T, BeneficiaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Beneficiaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany()
     * 
     * // Get first 10 Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeneficiaryFindManyArgs>(args?: SelectSubset<T, BeneficiaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Beneficiary.
     * @param {BeneficiaryCreateArgs} args - Arguments to create a Beneficiary.
     * @example
     * // Create one Beneficiary
     * const Beneficiary = await prisma.beneficiary.create({
     *   data: {
     *     // ... data to create a Beneficiary
     *   }
     * })
     * 
     */
    create<T extends BeneficiaryCreateArgs>(args: SelectSubset<T, BeneficiaryCreateArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Beneficiaries.
     * @param {BeneficiaryCreateManyArgs} args - Arguments to create many Beneficiaries.
     * @example
     * // Create many Beneficiaries
     * const beneficiary = await prisma.beneficiary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeneficiaryCreateManyArgs>(args?: SelectSubset<T, BeneficiaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beneficiaries and returns the data saved in the database.
     * @param {BeneficiaryCreateManyAndReturnArgs} args - Arguments to create many Beneficiaries.
     * @example
     * // Create many Beneficiaries
     * const beneficiary = await prisma.beneficiary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beneficiaries and only return the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BeneficiaryCreateManyAndReturnArgs>(args?: SelectSubset<T, BeneficiaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Beneficiary.
     * @param {BeneficiaryDeleteArgs} args - Arguments to delete one Beneficiary.
     * @example
     * // Delete one Beneficiary
     * const Beneficiary = await prisma.beneficiary.delete({
     *   where: {
     *     // ... filter to delete one Beneficiary
     *   }
     * })
     * 
     */
    delete<T extends BeneficiaryDeleteArgs>(args: SelectSubset<T, BeneficiaryDeleteArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Beneficiary.
     * @param {BeneficiaryUpdateArgs} args - Arguments to update one Beneficiary.
     * @example
     * // Update one Beneficiary
     * const beneficiary = await prisma.beneficiary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeneficiaryUpdateArgs>(args: SelectSubset<T, BeneficiaryUpdateArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Beneficiaries.
     * @param {BeneficiaryDeleteManyArgs} args - Arguments to filter Beneficiaries to delete.
     * @example
     * // Delete a few Beneficiaries
     * const { count } = await prisma.beneficiary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeneficiaryDeleteManyArgs>(args?: SelectSubset<T, BeneficiaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beneficiaries
     * const beneficiary = await prisma.beneficiary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeneficiaryUpdateManyArgs>(args: SelectSubset<T, BeneficiaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beneficiaries and returns the data updated in the database.
     * @param {BeneficiaryUpdateManyAndReturnArgs} args - Arguments to update many Beneficiaries.
     * @example
     * // Update many Beneficiaries
     * const beneficiary = await prisma.beneficiary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Beneficiaries and only return the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BeneficiaryUpdateManyAndReturnArgs>(args: SelectSubset<T, BeneficiaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Beneficiary.
     * @param {BeneficiaryUpsertArgs} args - Arguments to update or create a Beneficiary.
     * @example
     * // Update or create a Beneficiary
     * const beneficiary = await prisma.beneficiary.upsert({
     *   create: {
     *     // ... data to create a Beneficiary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beneficiary we want to update
     *   }
     * })
     */
    upsert<T extends BeneficiaryUpsertArgs>(args: SelectSubset<T, BeneficiaryUpsertArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryCountArgs} args - Arguments to filter Beneficiaries to count.
     * @example
     * // Count the number of Beneficiaries
     * const count = await prisma.beneficiary.count({
     *   where: {
     *     // ... the filter for the Beneficiaries we want to count
     *   }
     * })
    **/
    count<T extends BeneficiaryCountArgs>(
      args?: Subset<T, BeneficiaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiaryAggregateArgs>(args: Subset<T, BeneficiaryAggregateArgs>): Prisma.PrismaPromise<GetBeneficiaryAggregateType<T>>

    /**
     * Group by Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeneficiaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeneficiaryGroupByArgs['orderBy'] }
        : { orderBy?: BeneficiaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeneficiaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Beneficiary model
   */
  readonly fields: BeneficiaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Beneficiary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeneficiaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Beneficiary$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends Beneficiary$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institution<T extends Beneficiary$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Beneficiary$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Beneficiary$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Beneficiary model
   */
  interface BeneficiaryFieldRefs {
    readonly id: FieldRef<"Beneficiary", 'String'>
    readonly firstName: FieldRef<"Beneficiary", 'String'>
    readonly lastName: FieldRef<"Beneficiary", 'String'>
    readonly image: FieldRef<"Beneficiary", 'String'>
    readonly images: FieldRef<"Beneficiary", 'String[]'>
    readonly gender: FieldRef<"Beneficiary", 'GenderType'>
    readonly email: FieldRef<"Beneficiary", 'String'>
    readonly phone: FieldRef<"Beneficiary", 'String'>
    readonly dateOfBirth: FieldRef<"Beneficiary", 'DateTime'>
    readonly createdAt: FieldRef<"Beneficiary", 'DateTime'>
    readonly updatedAt: FieldRef<"Beneficiary", 'DateTime'>
    readonly beneficiaryStatus: FieldRef<"Beneficiary", 'PublishStatus'>
    readonly institutionId: FieldRef<"Beneficiary", 'String'>
    readonly createdById: FieldRef<"Beneficiary", 'String'>
    readonly updatedById: FieldRef<"Beneficiary", 'String'>
    readonly approvedById: FieldRef<"Beneficiary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Beneficiary findUnique
   */
  export type BeneficiaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary findUniqueOrThrow
   */
  export type BeneficiaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary findFirst
   */
  export type BeneficiaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beneficiaries.
     */
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary findFirstOrThrow
   */
  export type BeneficiaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beneficiaries.
     */
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary findMany
   */
  export type BeneficiaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiaries to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary create
   */
  export type BeneficiaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Beneficiary.
     */
    data: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
  }

  /**
   * Beneficiary createMany
   */
  export type BeneficiaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beneficiaries.
     */
    data: BeneficiaryCreateManyInput | BeneficiaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Beneficiary createManyAndReturn
   */
  export type BeneficiaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * The data used to create many Beneficiaries.
     */
    data: BeneficiaryCreateManyInput | BeneficiaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Beneficiary update
   */
  export type BeneficiaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Beneficiary.
     */
    data: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
    /**
     * Choose, which Beneficiary to update.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary updateMany
   */
  export type BeneficiaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beneficiaries.
     */
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyInput>
    /**
     * Filter which Beneficiaries to update
     */
    where?: BeneficiaryWhereInput
    /**
     * Limit how many Beneficiaries to update.
     */
    limit?: number
  }

  /**
   * Beneficiary updateManyAndReturn
   */
  export type BeneficiaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * The data used to update Beneficiaries.
     */
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyInput>
    /**
     * Filter which Beneficiaries to update
     */
    where?: BeneficiaryWhereInput
    /**
     * Limit how many Beneficiaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Beneficiary upsert
   */
  export type BeneficiaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Beneficiary to update in case it exists.
     */
    where: BeneficiaryWhereUniqueInput
    /**
     * In case the Beneficiary found by the `where` argument doesn't exist, create a new Beneficiary with this data.
     */
    create: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
    /**
     * In case the Beneficiary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
  }

  /**
   * Beneficiary delete
   */
  export type BeneficiaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter which Beneficiary to delete.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary deleteMany
   */
  export type BeneficiaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beneficiaries to delete
     */
    where?: BeneficiaryWhereInput
    /**
     * Limit how many Beneficiaries to delete.
     */
    limit?: number
  }

  /**
   * Beneficiary.messages
   */
  export type Beneficiary$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Beneficiary.responses
   */
  export type Beneficiary$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Beneficiary.institution
   */
  export type Beneficiary$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Beneficiary.updatedBy
   */
  export type Beneficiary$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Beneficiary.approvedBy
   */
  export type Beneficiary$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Beneficiary without action
   */
  export type BeneficiaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
  }


  /**
   * Model Response
   */

  export type AggregateResponse = {
    _count: ResponseCountAggregateOutputType | null
    _avg: ResponseAvgAggregateOutputType | null
    _sum: ResponseSumAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  export type ResponseAvgAggregateOutputType = {
    messageId: number | null
  }

  export type ResponseSumAggregateOutputType = {
    messageId: number | null
  }

  export type ResponseMinAggregateOutputType = {
    id: string | null
    messageId: number | null
    responderType: $Enums.ResponderType | null
    responderUserId: string | null
    responderBeneficiaryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResponseMaxAggregateOutputType = {
    id: string | null
    messageId: number | null
    responderType: $Enums.ResponderType | null
    responderUserId: string | null
    responderBeneficiaryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResponseCountAggregateOutputType = {
    id: number
    messageId: number
    responderType: number
    responderUserId: number
    responderBeneficiaryId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResponseAvgAggregateInputType = {
    messageId?: true
  }

  export type ResponseSumAggregateInputType = {
    messageId?: true
  }

  export type ResponseMinAggregateInputType = {
    id?: true
    messageId?: true
    responderType?: true
    responderUserId?: true
    responderBeneficiaryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResponseMaxAggregateInputType = {
    id?: true
    messageId?: true
    responderType?: true
    responderUserId?: true
    responderBeneficiaryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResponseCountAggregateInputType = {
    id?: true
    messageId?: true
    responderType?: true
    responderUserId?: true
    responderBeneficiaryId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Response to aggregate.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Responses
    **/
    _count?: true | ResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseMaxAggregateInputType
  }

  export type GetResponseAggregateType<T extends ResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse[P]>
      : GetScalarType<T[P], AggregateResponse[P]>
  }




  export type ResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithAggregationInput | ResponseOrderByWithAggregationInput[]
    by: ResponseScalarFieldEnum[] | ResponseScalarFieldEnum
    having?: ResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseCountAggregateInputType | true
    _avg?: ResponseAvgAggregateInputType
    _sum?: ResponseSumAggregateInputType
    _min?: ResponseMinAggregateInputType
    _max?: ResponseMaxAggregateInputType
  }

  export type ResponseGroupByOutputType = {
    id: string
    messageId: number
    responderType: $Enums.ResponderType
    responderUserId: string | null
    responderBeneficiaryId: string | null
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ResponseCountAggregateOutputType | null
    _avg: ResponseAvgAggregateOutputType | null
    _sum: ResponseSumAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  type GetResponseGroupByPayload<T extends ResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseGroupByOutputType[P]>
        }
      >
    >


  export type ResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    responderType?: boolean
    responderUserId?: boolean
    responderBeneficiaryId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    responderType?: boolean
    responderUserId?: boolean
    responderBeneficiaryId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    responderType?: boolean
    responderUserId?: boolean
    responderBeneficiaryId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectScalar = {
    id?: boolean
    messageId?: boolean
    responderType?: boolean
    responderUserId?: boolean
    responderBeneficiaryId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "responderType" | "responderUserId" | "responderBeneficiaryId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["response"]>
  export type ResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }
  export type ResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }
  export type ResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    responderUser?: boolean | Response$responderUserArgs<ExtArgs>
    responderBeneficiary?: boolean | Response$responderBeneficiaryArgs<ExtArgs>
  }

  export type $ResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Response"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      responderUser: Prisma.$UserPayload<ExtArgs> | null
      responderBeneficiary: Prisma.$BeneficiaryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: number
      responderType: $Enums.ResponderType
      responderUserId: string | null
      responderBeneficiaryId: string | null
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["response"]>
    composites: {}
  }

  type ResponseGetPayload<S extends boolean | null | undefined | ResponseDefaultArgs> = $Result.GetResult<Prisma.$ResponsePayload, S>

  type ResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResponseCountAggregateInputType | true
    }

  export interface ResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Response'], meta: { name: 'Response' } }
    /**
     * Find zero or one Response that matches the filter.
     * @param {ResponseFindUniqueArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponseFindUniqueArgs>(args: SelectSubset<T, ResponseFindUniqueArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Response that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponseFindUniqueOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Response that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponseFindFirstArgs>(args?: SelectSubset<T, ResponseFindFirstArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Response that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responses
     * const responses = await prisma.response.findMany()
     * 
     * // Get first 10 Responses
     * const responses = await prisma.response.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responseWithIdOnly = await prisma.response.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponseFindManyArgs>(args?: SelectSubset<T, ResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Response.
     * @param {ResponseCreateArgs} args - Arguments to create a Response.
     * @example
     * // Create one Response
     * const Response = await prisma.response.create({
     *   data: {
     *     // ... data to create a Response
     *   }
     * })
     * 
     */
    create<T extends ResponseCreateArgs>(args: SelectSubset<T, ResponseCreateArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Responses.
     * @param {ResponseCreateManyArgs} args - Arguments to create many Responses.
     * @example
     * // Create many Responses
     * const response = await prisma.response.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponseCreateManyArgs>(args?: SelectSubset<T, ResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Responses and returns the data saved in the database.
     * @param {ResponseCreateManyAndReturnArgs} args - Arguments to create many Responses.
     * @example
     * // Create many Responses
     * const response = await prisma.response.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Responses and only return the `id`
     * const responseWithIdOnly = await prisma.response.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Response.
     * @param {ResponseDeleteArgs} args - Arguments to delete one Response.
     * @example
     * // Delete one Response
     * const Response = await prisma.response.delete({
     *   where: {
     *     // ... filter to delete one Response
     *   }
     * })
     * 
     */
    delete<T extends ResponseDeleteArgs>(args: SelectSubset<T, ResponseDeleteArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Response.
     * @param {ResponseUpdateArgs} args - Arguments to update one Response.
     * @example
     * // Update one Response
     * const response = await prisma.response.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponseUpdateArgs>(args: SelectSubset<T, ResponseUpdateArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Responses.
     * @param {ResponseDeleteManyArgs} args - Arguments to filter Responses to delete.
     * @example
     * // Delete a few Responses
     * const { count } = await prisma.response.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponseDeleteManyArgs>(args?: SelectSubset<T, ResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responses
     * const response = await prisma.response.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponseUpdateManyArgs>(args: SelectSubset<T, ResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responses and returns the data updated in the database.
     * @param {ResponseUpdateManyAndReturnArgs} args - Arguments to update many Responses.
     * @example
     * // Update many Responses
     * const response = await prisma.response.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Responses and only return the `id`
     * const responseWithIdOnly = await prisma.response.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, ResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Response.
     * @param {ResponseUpsertArgs} args - Arguments to update or create a Response.
     * @example
     * // Update or create a Response
     * const response = await prisma.response.upsert({
     *   create: {
     *     // ... data to create a Response
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response we want to update
     *   }
     * })
     */
    upsert<T extends ResponseUpsertArgs>(args: SelectSubset<T, ResponseUpsertArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseCountArgs} args - Arguments to filter Responses to count.
     * @example
     * // Count the number of Responses
     * const count = await prisma.response.count({
     *   where: {
     *     // ... the filter for the Responses we want to count
     *   }
     * })
    **/
    count<T extends ResponseCountArgs>(
      args?: Subset<T, ResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseAggregateArgs>(args: Subset<T, ResponseAggregateArgs>): Prisma.PrismaPromise<GetResponseAggregateType<T>>

    /**
     * Group by Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseGroupByArgs['orderBy'] }
        : { orderBy?: ResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Response model
   */
  readonly fields: ResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Response.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responderUser<T extends Response$responderUserArgs<ExtArgs> = {}>(args?: Subset<T, Response$responderUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responderBeneficiary<T extends Response$responderBeneficiaryArgs<ExtArgs> = {}>(args?: Subset<T, Response$responderBeneficiaryArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Response model
   */
  interface ResponseFieldRefs {
    readonly id: FieldRef<"Response", 'String'>
    readonly messageId: FieldRef<"Response", 'Int'>
    readonly responderType: FieldRef<"Response", 'ResponderType'>
    readonly responderUserId: FieldRef<"Response", 'String'>
    readonly responderBeneficiaryId: FieldRef<"Response", 'String'>
    readonly content: FieldRef<"Response", 'Json'>
    readonly createdAt: FieldRef<"Response", 'DateTime'>
    readonly updatedAt: FieldRef<"Response", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Response findUnique
   */
  export type ResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response findUniqueOrThrow
   */
  export type ResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response findFirst
   */
  export type ResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response findFirstOrThrow
   */
  export type ResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response findMany
   */
  export type ResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Responses to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response create
   */
  export type ResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a Response.
     */
    data: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
  }

  /**
   * Response createMany
   */
  export type ResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Responses.
     */
    data: ResponseCreateManyInput | ResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Response createManyAndReturn
   */
  export type ResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * The data used to create many Responses.
     */
    data: ResponseCreateManyInput | ResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Response update
   */
  export type ResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a Response.
     */
    data: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
    /**
     * Choose, which Response to update.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response updateMany
   */
  export type ResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Responses.
     */
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyInput>
    /**
     * Filter which Responses to update
     */
    where?: ResponseWhereInput
    /**
     * Limit how many Responses to update.
     */
    limit?: number
  }

  /**
   * Response updateManyAndReturn
   */
  export type ResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * The data used to update Responses.
     */
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyInput>
    /**
     * Filter which Responses to update
     */
    where?: ResponseWhereInput
    /**
     * Limit how many Responses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Response upsert
   */
  export type ResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the Response to update in case it exists.
     */
    where: ResponseWhereUniqueInput
    /**
     * In case the Response found by the `where` argument doesn't exist, create a new Response with this data.
     */
    create: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
    /**
     * In case the Response was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
  }

  /**
   * Response delete
   */
  export type ResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter which Response to delete.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response deleteMany
   */
  export type ResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Responses to delete
     */
    where?: ResponseWhereInput
    /**
     * Limit how many Responses to delete.
     */
    limit?: number
  }

  /**
   * Response.responderUser
   */
  export type Response$responderUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Response.responderBeneficiary
   */
  export type Response$responderBeneficiaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Beneficiary
     */
    omit?: BeneficiaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
  }

  /**
   * Response without action
   */
  export type ResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Response
     */
    omit?: ResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQAvgAggregateOutputType = {
    id: number | null
  }

  export type FAQSumAggregateOutputType = {
    id: number | null
  }

  export type FAQMinAggregateOutputType = {
    id: number | null
    category: $Enums.FAQCategory | null
    publishStatus: $Enums.PublishStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type FAQMaxAggregateOutputType = {
    id: number | null
    category: $Enums.FAQCategory | null
    publishStatus: $Enums.PublishStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    approvedById: string | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    publishStatus: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    approvedById: number
    _all: number
  }


  export type FAQAvgAggregateInputType = {
    id?: true
  }

  export type FAQSumAggregateInputType = {
    id?: true
  }

  export type FAQMinAggregateInputType = {
    id?: true
    category?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    category?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    publishStatus?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    approvedById?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _avg?: FAQAvgAggregateInputType
    _sum?: FAQSumAggregateInputType
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: number
    question: JsonValue
    answer: JsonValue
    category: $Enums.FAQCategory
    publishStatus: $Enums.PublishStatus
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string
    approvedById: string
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    publishStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    approvedById?: boolean
  }

  export type FAQOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "publishStatus" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "approvedById", ExtArgs["result"]["fAQ"]>
  export type FAQInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FAQIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FAQIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: Prisma.JsonValue
      answer: Prisma.JsonValue
      category: $Enums.FAQCategory
      publishStatus: $Enums.PublishStatus
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string
      approvedById: string
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS and returns the data updated in the database.
     * @param {FAQUpdateManyAndReturnArgs} args - Arguments to update many FAQS.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'Int'>
    readonly question: FieldRef<"FAQ", 'Json'>
    readonly answer: FieldRef<"FAQ", 'Json'>
    readonly category: FieldRef<"FAQ", 'FAQCategory'>
    readonly publishStatus: FieldRef<"FAQ", 'PublishStatus'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
    readonly createdById: FieldRef<"FAQ", 'String'>
    readonly updatedById: FieldRef<"FAQ", 'String'>
    readonly approvedById: FieldRef<"FAQ", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
  }

  /**
   * FAQ updateManyAndReturn
   */
  export type FAQUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
    /**
     * Limit how many FAQS to delete.
     */
    limit?: number
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQ
     */
    omit?: FAQOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
  }


  /**
   * Model FacebookPost
   */

  export type AggregateFacebookPost = {
    _count: FacebookPostCountAggregateOutputType | null
    _min: FacebookPostMinAggregateOutputType | null
    _max: FacebookPostMaxAggregateOutputType | null
  }

  export type FacebookPostMinAggregateOutputType = {
    id: string | null
    message: string | null
    createdTime: Date | null
    permalinkUrl: string | null
    fullPicture: string | null
    fetchedAt: Date | null
  }

  export type FacebookPostMaxAggregateOutputType = {
    id: string | null
    message: string | null
    createdTime: Date | null
    permalinkUrl: string | null
    fullPicture: string | null
    fetchedAt: Date | null
  }

  export type FacebookPostCountAggregateOutputType = {
    id: number
    message: number
    createdTime: number
    permalinkUrl: number
    fullPicture: number
    fetchedAt: number
    _all: number
  }


  export type FacebookPostMinAggregateInputType = {
    id?: true
    message?: true
    createdTime?: true
    permalinkUrl?: true
    fullPicture?: true
    fetchedAt?: true
  }

  export type FacebookPostMaxAggregateInputType = {
    id?: true
    message?: true
    createdTime?: true
    permalinkUrl?: true
    fullPicture?: true
    fetchedAt?: true
  }

  export type FacebookPostCountAggregateInputType = {
    id?: true
    message?: true
    createdTime?: true
    permalinkUrl?: true
    fullPicture?: true
    fetchedAt?: true
    _all?: true
  }

  export type FacebookPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookPost to aggregate.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: FacebookPostOrderByWithRelationInput | FacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookPosts
    **/
    _count?: true | FacebookPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookPostMaxAggregateInputType
  }

  export type GetFacebookPostAggregateType<T extends FacebookPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookPost[P]>
      : GetScalarType<T[P], AggregateFacebookPost[P]>
  }




  export type FacebookPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacebookPostWhereInput
    orderBy?: FacebookPostOrderByWithAggregationInput | FacebookPostOrderByWithAggregationInput[]
    by: FacebookPostScalarFieldEnum[] | FacebookPostScalarFieldEnum
    having?: FacebookPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookPostCountAggregateInputType | true
    _min?: FacebookPostMinAggregateInputType
    _max?: FacebookPostMaxAggregateInputType
  }

  export type FacebookPostGroupByOutputType = {
    id: string
    message: string | null
    createdTime: Date
    permalinkUrl: string
    fullPicture: string
    fetchedAt: Date
    _count: FacebookPostCountAggregateOutputType | null
    _min: FacebookPostMinAggregateOutputType | null
    _max: FacebookPostMaxAggregateOutputType | null
  }

  type GetFacebookPostGroupByPayload<T extends FacebookPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacebookPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookPostGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookPostGroupByOutputType[P]>
        }
      >
    >


  export type FacebookPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    createdTime?: boolean
    permalinkUrl?: boolean
    fullPicture?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["facebookPost"]>

  export type FacebookPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    createdTime?: boolean
    permalinkUrl?: boolean
    fullPicture?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["facebookPost"]>

  export type FacebookPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    createdTime?: boolean
    permalinkUrl?: boolean
    fullPicture?: boolean
    fetchedAt?: boolean
  }, ExtArgs["result"]["facebookPost"]>

  export type FacebookPostSelectScalar = {
    id?: boolean
    message?: boolean
    createdTime?: boolean
    permalinkUrl?: boolean
    fullPicture?: boolean
    fetchedAt?: boolean
  }

  export type FacebookPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "createdTime" | "permalinkUrl" | "fullPicture" | "fetchedAt", ExtArgs["result"]["facebookPost"]>

  export type $FacebookPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacebookPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string | null
      createdTime: Date
      permalinkUrl: string
      fullPicture: string
      fetchedAt: Date
    }, ExtArgs["result"]["facebookPost"]>
    composites: {}
  }

  type FacebookPostGetPayload<S extends boolean | null | undefined | FacebookPostDefaultArgs> = $Result.GetResult<Prisma.$FacebookPostPayload, S>

  type FacebookPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacebookPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacebookPostCountAggregateInputType | true
    }

  export interface FacebookPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacebookPost'], meta: { name: 'FacebookPost' } }
    /**
     * Find zero or one FacebookPost that matches the filter.
     * @param {FacebookPostFindUniqueArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacebookPostFindUniqueArgs>(args: SelectSubset<T, FacebookPostFindUniqueArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacebookPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacebookPostFindUniqueOrThrowArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacebookPostFindUniqueOrThrowArgs>(args: SelectSubset<T, FacebookPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindFirstArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacebookPostFindFirstArgs>(args?: SelectSubset<T, FacebookPostFindFirstArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindFirstOrThrowArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacebookPostFindFirstOrThrowArgs>(args?: SelectSubset<T, FacebookPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacebookPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookPosts
     * const facebookPosts = await prisma.facebookPost.findMany()
     * 
     * // Get first 10 FacebookPosts
     * const facebookPosts = await prisma.facebookPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookPostWithIdOnly = await prisma.facebookPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacebookPostFindManyArgs>(args?: SelectSubset<T, FacebookPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacebookPost.
     * @param {FacebookPostCreateArgs} args - Arguments to create a FacebookPost.
     * @example
     * // Create one FacebookPost
     * const FacebookPost = await prisma.facebookPost.create({
     *   data: {
     *     // ... data to create a FacebookPost
     *   }
     * })
     * 
     */
    create<T extends FacebookPostCreateArgs>(args: SelectSubset<T, FacebookPostCreateArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacebookPosts.
     * @param {FacebookPostCreateManyArgs} args - Arguments to create many FacebookPosts.
     * @example
     * // Create many FacebookPosts
     * const facebookPost = await prisma.facebookPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacebookPostCreateManyArgs>(args?: SelectSubset<T, FacebookPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacebookPosts and returns the data saved in the database.
     * @param {FacebookPostCreateManyAndReturnArgs} args - Arguments to create many FacebookPosts.
     * @example
     * // Create many FacebookPosts
     * const facebookPost = await prisma.facebookPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacebookPosts and only return the `id`
     * const facebookPostWithIdOnly = await prisma.facebookPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacebookPostCreateManyAndReturnArgs>(args?: SelectSubset<T, FacebookPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacebookPost.
     * @param {FacebookPostDeleteArgs} args - Arguments to delete one FacebookPost.
     * @example
     * // Delete one FacebookPost
     * const FacebookPost = await prisma.facebookPost.delete({
     *   where: {
     *     // ... filter to delete one FacebookPost
     *   }
     * })
     * 
     */
    delete<T extends FacebookPostDeleteArgs>(args: SelectSubset<T, FacebookPostDeleteArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacebookPost.
     * @param {FacebookPostUpdateArgs} args - Arguments to update one FacebookPost.
     * @example
     * // Update one FacebookPost
     * const facebookPost = await prisma.facebookPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacebookPostUpdateArgs>(args: SelectSubset<T, FacebookPostUpdateArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacebookPosts.
     * @param {FacebookPostDeleteManyArgs} args - Arguments to filter FacebookPosts to delete.
     * @example
     * // Delete a few FacebookPosts
     * const { count } = await prisma.facebookPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacebookPostDeleteManyArgs>(args?: SelectSubset<T, FacebookPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookPosts
     * const facebookPost = await prisma.facebookPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacebookPostUpdateManyArgs>(args: SelectSubset<T, FacebookPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPosts and returns the data updated in the database.
     * @param {FacebookPostUpdateManyAndReturnArgs} args - Arguments to update many FacebookPosts.
     * @example
     * // Update many FacebookPosts
     * const facebookPost = await prisma.facebookPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacebookPosts and only return the `id`
     * const facebookPostWithIdOnly = await prisma.facebookPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacebookPostUpdateManyAndReturnArgs>(args: SelectSubset<T, FacebookPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacebookPost.
     * @param {FacebookPostUpsertArgs} args - Arguments to update or create a FacebookPost.
     * @example
     * // Update or create a FacebookPost
     * const facebookPost = await prisma.facebookPost.upsert({
     *   create: {
     *     // ... data to create a FacebookPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookPost we want to update
     *   }
     * })
     */
    upsert<T extends FacebookPostUpsertArgs>(args: SelectSubset<T, FacebookPostUpsertArgs<ExtArgs>>): Prisma__FacebookPostClient<$Result.GetResult<Prisma.$FacebookPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostCountArgs} args - Arguments to filter FacebookPosts to count.
     * @example
     * // Count the number of FacebookPosts
     * const count = await prisma.facebookPost.count({
     *   where: {
     *     // ... the filter for the FacebookPosts we want to count
     *   }
     * })
    **/
    count<T extends FacebookPostCountArgs>(
      args?: Subset<T, FacebookPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookPostAggregateArgs>(args: Subset<T, FacebookPostAggregateArgs>): Prisma.PrismaPromise<GetFacebookPostAggregateType<T>>

    /**
     * Group by FacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookPostGroupByArgs['orderBy'] }
        : { orderBy?: FacebookPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacebookPost model
   */
  readonly fields: FacebookPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacebookPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacebookPost model
   */
  interface FacebookPostFieldRefs {
    readonly id: FieldRef<"FacebookPost", 'String'>
    readonly message: FieldRef<"FacebookPost", 'String'>
    readonly createdTime: FieldRef<"FacebookPost", 'DateTime'>
    readonly permalinkUrl: FieldRef<"FacebookPost", 'String'>
    readonly fullPicture: FieldRef<"FacebookPost", 'String'>
    readonly fetchedAt: FieldRef<"FacebookPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacebookPost findUnique
   */
  export type FacebookPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where: FacebookPostWhereUniqueInput
  }

  /**
   * FacebookPost findUniqueOrThrow
   */
  export type FacebookPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where: FacebookPostWhereUniqueInput
  }

  /**
   * FacebookPost findFirst
   */
  export type FacebookPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: FacebookPostOrderByWithRelationInput | FacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPosts.
     */
    distinct?: FacebookPostScalarFieldEnum | FacebookPostScalarFieldEnum[]
  }

  /**
   * FacebookPost findFirstOrThrow
   */
  export type FacebookPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: FacebookPostOrderByWithRelationInput | FacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPosts.
     */
    distinct?: FacebookPostScalarFieldEnum | FacebookPostScalarFieldEnum[]
  }

  /**
   * FacebookPost findMany
   */
  export type FacebookPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter, which FacebookPosts to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: FacebookPostOrderByWithRelationInput | FacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    distinct?: FacebookPostScalarFieldEnum | FacebookPostScalarFieldEnum[]
  }

  /**
   * FacebookPost create
   */
  export type FacebookPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * The data needed to create a FacebookPost.
     */
    data: XOR<FacebookPostCreateInput, FacebookPostUncheckedCreateInput>
  }

  /**
   * FacebookPost createMany
   */
  export type FacebookPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacebookPosts.
     */
    data: FacebookPostCreateManyInput | FacebookPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacebookPost createManyAndReturn
   */
  export type FacebookPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * The data used to create many FacebookPosts.
     */
    data: FacebookPostCreateManyInput | FacebookPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacebookPost update
   */
  export type FacebookPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * The data needed to update a FacebookPost.
     */
    data: XOR<FacebookPostUpdateInput, FacebookPostUncheckedUpdateInput>
    /**
     * Choose, which FacebookPost to update.
     */
    where: FacebookPostWhereUniqueInput
  }

  /**
   * FacebookPost updateMany
   */
  export type FacebookPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacebookPosts.
     */
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPosts to update
     */
    where?: FacebookPostWhereInput
    /**
     * Limit how many FacebookPosts to update.
     */
    limit?: number
  }

  /**
   * FacebookPost updateManyAndReturn
   */
  export type FacebookPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * The data used to update FacebookPosts.
     */
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPosts to update
     */
    where?: FacebookPostWhereInput
    /**
     * Limit how many FacebookPosts to update.
     */
    limit?: number
  }

  /**
   * FacebookPost upsert
   */
  export type FacebookPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * The filter to search for the FacebookPost to update in case it exists.
     */
    where: FacebookPostWhereUniqueInput
    /**
     * In case the FacebookPost found by the `where` argument doesn't exist, create a new FacebookPost with this data.
     */
    create: XOR<FacebookPostCreateInput, FacebookPostUncheckedCreateInput>
    /**
     * In case the FacebookPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookPostUpdateInput, FacebookPostUncheckedUpdateInput>
  }

  /**
   * FacebookPost delete
   */
  export type FacebookPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
    /**
     * Filter which FacebookPost to delete.
     */
    where: FacebookPostWhereUniqueInput
  }

  /**
   * FacebookPost deleteMany
   */
  export type FacebookPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookPosts to delete
     */
    where?: FacebookPostWhereInput
    /**
     * Limit how many FacebookPosts to delete.
     */
    limit?: number
  }

  /**
   * FacebookPost without action
   */
  export type FacebookPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookPost
     */
    omit?: FacebookPostOmit<ExtArgs> | null
  }


  /**
   * Model FacebookCacheMeta
   */

  export type AggregateFacebookCacheMeta = {
    _count: FacebookCacheMetaCountAggregateOutputType | null
    _avg: FacebookCacheMetaAvgAggregateOutputType | null
    _sum: FacebookCacheMetaSumAggregateOutputType | null
    _min: FacebookCacheMetaMinAggregateOutputType | null
    _max: FacebookCacheMetaMaxAggregateOutputType | null
  }

  export type FacebookCacheMetaAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookCacheMetaSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookCacheMetaMinAggregateOutputType = {
    id: number | null
    lastFetched: Date | null
  }

  export type FacebookCacheMetaMaxAggregateOutputType = {
    id: number | null
    lastFetched: Date | null
  }

  export type FacebookCacheMetaCountAggregateOutputType = {
    id: number
    lastFetched: number
    _all: number
  }


  export type FacebookCacheMetaAvgAggregateInputType = {
    id?: true
  }

  export type FacebookCacheMetaSumAggregateInputType = {
    id?: true
  }

  export type FacebookCacheMetaMinAggregateInputType = {
    id?: true
    lastFetched?: true
  }

  export type FacebookCacheMetaMaxAggregateInputType = {
    id?: true
    lastFetched?: true
  }

  export type FacebookCacheMetaCountAggregateInputType = {
    id?: true
    lastFetched?: true
    _all?: true
  }

  export type FacebookCacheMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookCacheMeta to aggregate.
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCacheMetas to fetch.
     */
    orderBy?: FacebookCacheMetaOrderByWithRelationInput | FacebookCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookCacheMetas
    **/
    _count?: true | FacebookCacheMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookCacheMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookCacheMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookCacheMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookCacheMetaMaxAggregateInputType
  }

  export type GetFacebookCacheMetaAggregateType<T extends FacebookCacheMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookCacheMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookCacheMeta[P]>
      : GetScalarType<T[P], AggregateFacebookCacheMeta[P]>
  }




  export type FacebookCacheMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacebookCacheMetaWhereInput
    orderBy?: FacebookCacheMetaOrderByWithAggregationInput | FacebookCacheMetaOrderByWithAggregationInput[]
    by: FacebookCacheMetaScalarFieldEnum[] | FacebookCacheMetaScalarFieldEnum
    having?: FacebookCacheMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookCacheMetaCountAggregateInputType | true
    _avg?: FacebookCacheMetaAvgAggregateInputType
    _sum?: FacebookCacheMetaSumAggregateInputType
    _min?: FacebookCacheMetaMinAggregateInputType
    _max?: FacebookCacheMetaMaxAggregateInputType
  }

  export type FacebookCacheMetaGroupByOutputType = {
    id: number
    lastFetched: Date
    _count: FacebookCacheMetaCountAggregateOutputType | null
    _avg: FacebookCacheMetaAvgAggregateOutputType | null
    _sum: FacebookCacheMetaSumAggregateOutputType | null
    _min: FacebookCacheMetaMinAggregateOutputType | null
    _max: FacebookCacheMetaMaxAggregateOutputType | null
  }

  type GetFacebookCacheMetaGroupByPayload<T extends FacebookCacheMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacebookCacheMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookCacheMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookCacheMetaGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookCacheMetaGroupByOutputType[P]>
        }
      >
    >


  export type FacebookCacheMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["facebookCacheMeta"]>

  export type FacebookCacheMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["facebookCacheMeta"]>

  export type FacebookCacheMetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastFetched?: boolean
  }, ExtArgs["result"]["facebookCacheMeta"]>

  export type FacebookCacheMetaSelectScalar = {
    id?: boolean
    lastFetched?: boolean
  }

  export type FacebookCacheMetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastFetched", ExtArgs["result"]["facebookCacheMeta"]>

  export type $FacebookCacheMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacebookCacheMeta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lastFetched: Date
    }, ExtArgs["result"]["facebookCacheMeta"]>
    composites: {}
  }

  type FacebookCacheMetaGetPayload<S extends boolean | null | undefined | FacebookCacheMetaDefaultArgs> = $Result.GetResult<Prisma.$FacebookCacheMetaPayload, S>

  type FacebookCacheMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacebookCacheMetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacebookCacheMetaCountAggregateInputType | true
    }

  export interface FacebookCacheMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacebookCacheMeta'], meta: { name: 'FacebookCacheMeta' } }
    /**
     * Find zero or one FacebookCacheMeta that matches the filter.
     * @param {FacebookCacheMetaFindUniqueArgs} args - Arguments to find a FacebookCacheMeta
     * @example
     * // Get one FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacebookCacheMetaFindUniqueArgs>(args: SelectSubset<T, FacebookCacheMetaFindUniqueArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacebookCacheMeta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacebookCacheMetaFindUniqueOrThrowArgs} args - Arguments to find a FacebookCacheMeta
     * @example
     * // Get one FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacebookCacheMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, FacebookCacheMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookCacheMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaFindFirstArgs} args - Arguments to find a FacebookCacheMeta
     * @example
     * // Get one FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacebookCacheMetaFindFirstArgs>(args?: SelectSubset<T, FacebookCacheMetaFindFirstArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacebookCacheMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaFindFirstOrThrowArgs} args - Arguments to find a FacebookCacheMeta
     * @example
     * // Get one FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacebookCacheMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, FacebookCacheMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacebookCacheMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookCacheMetas
     * const facebookCacheMetas = await prisma.facebookCacheMeta.findMany()
     * 
     * // Get first 10 FacebookCacheMetas
     * const facebookCacheMetas = await prisma.facebookCacheMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookCacheMetaWithIdOnly = await prisma.facebookCacheMeta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacebookCacheMetaFindManyArgs>(args?: SelectSubset<T, FacebookCacheMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacebookCacheMeta.
     * @param {FacebookCacheMetaCreateArgs} args - Arguments to create a FacebookCacheMeta.
     * @example
     * // Create one FacebookCacheMeta
     * const FacebookCacheMeta = await prisma.facebookCacheMeta.create({
     *   data: {
     *     // ... data to create a FacebookCacheMeta
     *   }
     * })
     * 
     */
    create<T extends FacebookCacheMetaCreateArgs>(args: SelectSubset<T, FacebookCacheMetaCreateArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacebookCacheMetas.
     * @param {FacebookCacheMetaCreateManyArgs} args - Arguments to create many FacebookCacheMetas.
     * @example
     * // Create many FacebookCacheMetas
     * const facebookCacheMeta = await prisma.facebookCacheMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacebookCacheMetaCreateManyArgs>(args?: SelectSubset<T, FacebookCacheMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacebookCacheMetas and returns the data saved in the database.
     * @param {FacebookCacheMetaCreateManyAndReturnArgs} args - Arguments to create many FacebookCacheMetas.
     * @example
     * // Create many FacebookCacheMetas
     * const facebookCacheMeta = await prisma.facebookCacheMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacebookCacheMetas and only return the `id`
     * const facebookCacheMetaWithIdOnly = await prisma.facebookCacheMeta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacebookCacheMetaCreateManyAndReturnArgs>(args?: SelectSubset<T, FacebookCacheMetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacebookCacheMeta.
     * @param {FacebookCacheMetaDeleteArgs} args - Arguments to delete one FacebookCacheMeta.
     * @example
     * // Delete one FacebookCacheMeta
     * const FacebookCacheMeta = await prisma.facebookCacheMeta.delete({
     *   where: {
     *     // ... filter to delete one FacebookCacheMeta
     *   }
     * })
     * 
     */
    delete<T extends FacebookCacheMetaDeleteArgs>(args: SelectSubset<T, FacebookCacheMetaDeleteArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacebookCacheMeta.
     * @param {FacebookCacheMetaUpdateArgs} args - Arguments to update one FacebookCacheMeta.
     * @example
     * // Update one FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacebookCacheMetaUpdateArgs>(args: SelectSubset<T, FacebookCacheMetaUpdateArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacebookCacheMetas.
     * @param {FacebookCacheMetaDeleteManyArgs} args - Arguments to filter FacebookCacheMetas to delete.
     * @example
     * // Delete a few FacebookCacheMetas
     * const { count } = await prisma.facebookCacheMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacebookCacheMetaDeleteManyArgs>(args?: SelectSubset<T, FacebookCacheMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookCacheMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookCacheMetas
     * const facebookCacheMeta = await prisma.facebookCacheMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacebookCacheMetaUpdateManyArgs>(args: SelectSubset<T, FacebookCacheMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookCacheMetas and returns the data updated in the database.
     * @param {FacebookCacheMetaUpdateManyAndReturnArgs} args - Arguments to update many FacebookCacheMetas.
     * @example
     * // Update many FacebookCacheMetas
     * const facebookCacheMeta = await prisma.facebookCacheMeta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacebookCacheMetas and only return the `id`
     * const facebookCacheMetaWithIdOnly = await prisma.facebookCacheMeta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacebookCacheMetaUpdateManyAndReturnArgs>(args: SelectSubset<T, FacebookCacheMetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacebookCacheMeta.
     * @param {FacebookCacheMetaUpsertArgs} args - Arguments to update or create a FacebookCacheMeta.
     * @example
     * // Update or create a FacebookCacheMeta
     * const facebookCacheMeta = await prisma.facebookCacheMeta.upsert({
     *   create: {
     *     // ... data to create a FacebookCacheMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookCacheMeta we want to update
     *   }
     * })
     */
    upsert<T extends FacebookCacheMetaUpsertArgs>(args: SelectSubset<T, FacebookCacheMetaUpsertArgs<ExtArgs>>): Prisma__FacebookCacheMetaClient<$Result.GetResult<Prisma.$FacebookCacheMetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacebookCacheMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaCountArgs} args - Arguments to filter FacebookCacheMetas to count.
     * @example
     * // Count the number of FacebookCacheMetas
     * const count = await prisma.facebookCacheMeta.count({
     *   where: {
     *     // ... the filter for the FacebookCacheMetas we want to count
     *   }
     * })
    **/
    count<T extends FacebookCacheMetaCountArgs>(
      args?: Subset<T, FacebookCacheMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookCacheMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookCacheMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookCacheMetaAggregateArgs>(args: Subset<T, FacebookCacheMetaAggregateArgs>): Prisma.PrismaPromise<GetFacebookCacheMetaAggregateType<T>>

    /**
     * Group by FacebookCacheMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCacheMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookCacheMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookCacheMetaGroupByArgs['orderBy'] }
        : { orderBy?: FacebookCacheMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookCacheMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookCacheMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacebookCacheMeta model
   */
  readonly fields: FacebookCacheMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookCacheMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacebookCacheMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacebookCacheMeta model
   */
  interface FacebookCacheMetaFieldRefs {
    readonly id: FieldRef<"FacebookCacheMeta", 'Int'>
    readonly lastFetched: FieldRef<"FacebookCacheMeta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacebookCacheMeta findUnique
   */
  export type FacebookCacheMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which FacebookCacheMeta to fetch.
     */
    where: FacebookCacheMetaWhereUniqueInput
  }

  /**
   * FacebookCacheMeta findUniqueOrThrow
   */
  export type FacebookCacheMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which FacebookCacheMeta to fetch.
     */
    where: FacebookCacheMetaWhereUniqueInput
  }

  /**
   * FacebookCacheMeta findFirst
   */
  export type FacebookCacheMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which FacebookCacheMeta to fetch.
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCacheMetas to fetch.
     */
    orderBy?: FacebookCacheMetaOrderByWithRelationInput | FacebookCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookCacheMetas.
     */
    cursor?: FacebookCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookCacheMetas.
     */
    distinct?: FacebookCacheMetaScalarFieldEnum | FacebookCacheMetaScalarFieldEnum[]
  }

  /**
   * FacebookCacheMeta findFirstOrThrow
   */
  export type FacebookCacheMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which FacebookCacheMeta to fetch.
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCacheMetas to fetch.
     */
    orderBy?: FacebookCacheMetaOrderByWithRelationInput | FacebookCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookCacheMetas.
     */
    cursor?: FacebookCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCacheMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookCacheMetas.
     */
    distinct?: FacebookCacheMetaScalarFieldEnum | FacebookCacheMetaScalarFieldEnum[]
  }

  /**
   * FacebookCacheMeta findMany
   */
  export type FacebookCacheMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter, which FacebookCacheMetas to fetch.
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCacheMetas to fetch.
     */
    orderBy?: FacebookCacheMetaOrderByWithRelationInput | FacebookCacheMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookCacheMetas.
     */
    cursor?: FacebookCacheMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCacheMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCacheMetas.
     */
    skip?: number
    distinct?: FacebookCacheMetaScalarFieldEnum | FacebookCacheMetaScalarFieldEnum[]
  }

  /**
   * FacebookCacheMeta create
   */
  export type FacebookCacheMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * The data needed to create a FacebookCacheMeta.
     */
    data: XOR<FacebookCacheMetaCreateInput, FacebookCacheMetaUncheckedCreateInput>
  }

  /**
   * FacebookCacheMeta createMany
   */
  export type FacebookCacheMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacebookCacheMetas.
     */
    data: FacebookCacheMetaCreateManyInput | FacebookCacheMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacebookCacheMeta createManyAndReturn
   */
  export type FacebookCacheMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * The data used to create many FacebookCacheMetas.
     */
    data: FacebookCacheMetaCreateManyInput | FacebookCacheMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacebookCacheMeta update
   */
  export type FacebookCacheMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * The data needed to update a FacebookCacheMeta.
     */
    data: XOR<FacebookCacheMetaUpdateInput, FacebookCacheMetaUncheckedUpdateInput>
    /**
     * Choose, which FacebookCacheMeta to update.
     */
    where: FacebookCacheMetaWhereUniqueInput
  }

  /**
   * FacebookCacheMeta updateMany
   */
  export type FacebookCacheMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacebookCacheMetas.
     */
    data: XOR<FacebookCacheMetaUpdateManyMutationInput, FacebookCacheMetaUncheckedUpdateManyInput>
    /**
     * Filter which FacebookCacheMetas to update
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * Limit how many FacebookCacheMetas to update.
     */
    limit?: number
  }

  /**
   * FacebookCacheMeta updateManyAndReturn
   */
  export type FacebookCacheMetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * The data used to update FacebookCacheMetas.
     */
    data: XOR<FacebookCacheMetaUpdateManyMutationInput, FacebookCacheMetaUncheckedUpdateManyInput>
    /**
     * Filter which FacebookCacheMetas to update
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * Limit how many FacebookCacheMetas to update.
     */
    limit?: number
  }

  /**
   * FacebookCacheMeta upsert
   */
  export type FacebookCacheMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * The filter to search for the FacebookCacheMeta to update in case it exists.
     */
    where: FacebookCacheMetaWhereUniqueInput
    /**
     * In case the FacebookCacheMeta found by the `where` argument doesn't exist, create a new FacebookCacheMeta with this data.
     */
    create: XOR<FacebookCacheMetaCreateInput, FacebookCacheMetaUncheckedCreateInput>
    /**
     * In case the FacebookCacheMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookCacheMetaUpdateInput, FacebookCacheMetaUncheckedUpdateInput>
  }

  /**
   * FacebookCacheMeta delete
   */
  export type FacebookCacheMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
    /**
     * Filter which FacebookCacheMeta to delete.
     */
    where: FacebookCacheMetaWhereUniqueInput
  }

  /**
   * FacebookCacheMeta deleteMany
   */
  export type FacebookCacheMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacebookCacheMetas to delete
     */
    where?: FacebookCacheMetaWhereInput
    /**
     * Limit how many FacebookCacheMetas to delete.
     */
    limit?: number
  }

  /**
   * FacebookCacheMeta without action
   */
  export type FacebookCacheMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacebookCacheMeta
     */
    select?: FacebookCacheMetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacebookCacheMeta
     */
    omit?: FacebookCacheMetaOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    images: 'images',
    projectStatus: 'projectStatus',
    publishStatus: 'publishStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const HomePageScalarFieldEnum: {
    id: 'id',
    heroVideo: 'heroVideo',
    vision: 'vision',
    mission: 'mission',
    focus: 'focus',
    coreValues: 'coreValues',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HomePageScalarFieldEnum = (typeof HomePageScalarFieldEnum)[keyof typeof HomePageScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    affiliated: 'affiliated',
    name: 'name',
    content: 'content',
    nameImageUrl: 'nameImageUrl',
    messageImageUrl: 'messageImageUrl',
    messageStatus: 'messageStatus',
    messageCategory: 'messageCategory',
    senderEmail: 'senderEmail',
    senderIp: 'senderIp',
    allowResponses: 'allowResponses',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById',
    beneficiaryId: 'beneficiaryId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    images: 'images',
    files: 'files',
    publishStatus: 'publishStatus',
    accessCount: 'accessCount',
    downloadCount: 'downloadCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById',
    projectId: 'projectId'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    password: 'password',
    email: 'email',
    image: 'image',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    about: 'about',
    lastLogin: 'lastLogin',
    loginStatus: 'loginStatus',
    failedLoginCount: 'failedLoginCount',
    lockedUntil: 'lockedUntil'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt'
  };

  export type PasswordHistoryScalarFieldEnum = (typeof PasswordHistoryScalarFieldEnum)[keyof typeof PasswordHistoryScalarFieldEnum]


  export const PasswordChangeLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    changedBy: 'changedBy',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type PasswordChangeLogScalarFieldEnum = (typeof PasswordChangeLogScalarFieldEnum)[keyof typeof PasswordChangeLogScalarFieldEnum]


  export const FailedLoginAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ip: 'ip',
    createdAt: 'createdAt'
  };

  export type FailedLoginAttemptScalarFieldEnum = (typeof FailedLoginAttemptScalarFieldEnum)[keyof typeof FailedLoginAttemptScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startedAt: 'startedAt',
    lastSeenAt: 'lastSeenAt',
    endedAt: 'endedAt',
    ip: 'ip',
    userAgent: 'userAgent',
    active: 'active'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    eventTitle: 'eventTitle',
    eventDescription: 'eventDescription',
    eventDetails: 'eventDetails',
    eventLocation: 'eventLocation',
    eventBanner: 'eventBanner',
    eventImages: 'eventImages',
    eventFile: 'eventFile',
    eventStartDate: 'eventStartDate',
    eventEndDate: 'eventEndDate',
    eventTags: 'eventTags',
    eventStatus: 'eventStatus',
    publishStatus: 'publishStatus',
    eventAttendance: 'eventAttendance',
    maxAttendees: 'maxAttendees',
    accessCount: 'accessCount',
    downloadCount: 'downloadCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    projectId: 'projectId',
    reportId: 'reportId'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    publishedAt: 'publishedAt',
    viewCount: 'viewCount',
    likeCount: 'likeCount',
    duration: 'duration',
    fetchedAt: 'fetchedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const YouTubeCacheMetaScalarFieldEnum: {
    id: 'id',
    lastFetched: 'lastFetched'
  };

  export type YouTubeCacheMetaScalarFieldEnum = (typeof YouTubeCacheMetaScalarFieldEnum)[keyof typeof YouTubeCacheMetaScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    logo: 'logo',
    institutionImages: 'institutionImages',
    headName: 'headName',
    institutionType: 'institutionType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    locationName: 'locationName',
    latitude: 'latitude',
    longitude: 'longitude',
    institutionId: 'institutionId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const BeneficiaryScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    image: 'image',
    images: 'images',
    gender: 'gender',
    email: 'email',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    beneficiaryStatus: 'beneficiaryStatus',
    institutionId: 'institutionId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById'
  };

  export type BeneficiaryScalarFieldEnum = (typeof BeneficiaryScalarFieldEnum)[keyof typeof BeneficiaryScalarFieldEnum]


  export const ResponseScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    responderType: 'responderType',
    responderUserId: 'responderUserId',
    responderBeneficiaryId: 'responderBeneficiaryId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResponseScalarFieldEnum = (typeof ResponseScalarFieldEnum)[keyof typeof ResponseScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    publishStatus: 'publishStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    approvedById: 'approvedById'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const FacebookPostScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdTime: 'createdTime',
    permalinkUrl: 'permalinkUrl',
    fullPicture: 'fullPicture',
    fetchedAt: 'fetchedAt'
  };

  export type FacebookPostScalarFieldEnum = (typeof FacebookPostScalarFieldEnum)[keyof typeof FacebookPostScalarFieldEnum]


  export const FacebookCacheMetaScalarFieldEnum: {
    id: 'id',
    lastFetched: 'lastFetched'
  };

  export type FacebookCacheMetaScalarFieldEnum = (typeof FacebookCacheMetaScalarFieldEnum)[keyof typeof FacebookCacheMetaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'PublishStatus'
   */
  export type EnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus'>
    


  /**
   * Reference to a field of type 'PublishStatus[]'
   */
  export type ListEnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MessageCategory'
   */
  export type EnumMessageCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageCategory'>
    


  /**
   * Reference to a field of type 'MessageCategory[]'
   */
  export type ListEnumMessageCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'LoginStatus'
   */
  export type EnumLoginStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginStatus'>
    


  /**
   * Reference to a field of type 'LoginStatus[]'
   */
  export type ListEnumLoginStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginStatus[]'>
    


  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


  /**
   * Reference to a field of type 'EventStatus[]'
   */
  export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceType'
   */
  export type EnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType'>
    


  /**
   * Reference to a field of type 'AttendanceType[]'
   */
  export type ListEnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType[]'>
    


  /**
   * Reference to a field of type 'InstitutionType'
   */
  export type EnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType'>
    


  /**
   * Reference to a field of type 'InstitutionType[]'
   */
  export type ListEnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GenderType'
   */
  export type EnumGenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderType'>
    


  /**
   * Reference to a field of type 'GenderType[]'
   */
  export type ListEnumGenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderType[]'>
    


  /**
   * Reference to a field of type 'ResponderType'
   */
  export type EnumResponderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponderType'>
    


  /**
   * Reference to a field of type 'ResponderType[]'
   */
  export type ListEnumResponderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResponderType[]'>
    


  /**
   * Reference to a field of type 'FAQCategory'
   */
  export type EnumFAQCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FAQCategory'>
    


  /**
   * Reference to a field of type 'FAQCategory[]'
   */
  export type ListEnumFAQCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FAQCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    content?: JsonFilter<"Project">
    images?: StringNullableListFilter<"Project">
    projectStatus?: EnumStatusFilter<"Project"> | $Enums.Status
    publishStatus?: EnumPublishStatusFilter<"Project"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdById?: StringFilter<"Project"> | string
    updatedById?: StringNullableFilter<"Project"> | string | null
    approvedById?: StringNullableFilter<"Project"> | string | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reports?: ReportListRelationFilter
    events?: EventListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    images?: SortOrder
    projectStatus?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedBy?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    content?: JsonFilter<"Project">
    images?: StringNullableListFilter<"Project">
    projectStatus?: EnumStatusFilter<"Project"> | $Enums.Status
    publishStatus?: EnumPublishStatusFilter<"Project"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdById?: StringFilter<"Project"> | string
    updatedById?: StringNullableFilter<"Project"> | string | null
    approvedById?: StringNullableFilter<"Project"> | string | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reports?: ReportListRelationFilter
    events?: EventListRelationFilter
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    images?: SortOrder
    projectStatus?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    title?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    content?: JsonWithAggregatesFilter<"Project">
    images?: StringNullableListFilter<"Project">
    projectStatus?: EnumStatusWithAggregatesFilter<"Project"> | $Enums.Status
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"Project"> | $Enums.PublishStatus
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    createdById?: StringWithAggregatesFilter<"Project"> | string
    updatedById?: StringNullableWithAggregatesFilter<"Project"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type HomePageWhereInput = {
    AND?: HomePageWhereInput | HomePageWhereInput[]
    OR?: HomePageWhereInput[]
    NOT?: HomePageWhereInput | HomePageWhereInput[]
    id?: IntFilter<"HomePage"> | number
    heroVideo?: StringFilter<"HomePage"> | string
    vision?: StringFilter<"HomePage"> | string
    mission?: StringFilter<"HomePage"> | string
    focus?: StringFilter<"HomePage"> | string
    coreValues?: StringFilter<"HomePage"> | string
    createdAt?: DateTimeFilter<"HomePage"> | Date | string
    updatedAt?: DateTimeFilter<"HomePage"> | Date | string
  }

  export type HomePageOrderByWithRelationInput = {
    id?: SortOrder
    heroVideo?: SortOrder
    vision?: SortOrder
    mission?: SortOrder
    focus?: SortOrder
    coreValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HomePageWhereInput | HomePageWhereInput[]
    OR?: HomePageWhereInput[]
    NOT?: HomePageWhereInput | HomePageWhereInput[]
    heroVideo?: StringFilter<"HomePage"> | string
    vision?: StringFilter<"HomePage"> | string
    mission?: StringFilter<"HomePage"> | string
    focus?: StringFilter<"HomePage"> | string
    coreValues?: StringFilter<"HomePage"> | string
    createdAt?: DateTimeFilter<"HomePage"> | Date | string
    updatedAt?: DateTimeFilter<"HomePage"> | Date | string
  }, "id">

  export type HomePageOrderByWithAggregationInput = {
    id?: SortOrder
    heroVideo?: SortOrder
    vision?: SortOrder
    mission?: SortOrder
    focus?: SortOrder
    coreValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HomePageCountOrderByAggregateInput
    _avg?: HomePageAvgOrderByAggregateInput
    _max?: HomePageMaxOrderByAggregateInput
    _min?: HomePageMinOrderByAggregateInput
    _sum?: HomePageSumOrderByAggregateInput
  }

  export type HomePageScalarWhereWithAggregatesInput = {
    AND?: HomePageScalarWhereWithAggregatesInput | HomePageScalarWhereWithAggregatesInput[]
    OR?: HomePageScalarWhereWithAggregatesInput[]
    NOT?: HomePageScalarWhereWithAggregatesInput | HomePageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HomePage"> | number
    heroVideo?: StringWithAggregatesFilter<"HomePage"> | string
    vision?: StringWithAggregatesFilter<"HomePage"> | string
    mission?: StringWithAggregatesFilter<"HomePage"> | string
    focus?: StringWithAggregatesFilter<"HomePage"> | string
    coreValues?: StringWithAggregatesFilter<"HomePage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HomePage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomePage"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    title?: StringNullableFilter<"Message"> | string | null
    affiliated?: StringNullableFilter<"Message"> | string | null
    name?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    nameImageUrl?: StringNullableFilter<"Message"> | string | null
    messageImageUrl?: StringNullableFilter<"Message"> | string | null
    messageStatus?: EnumPublishStatusFilter<"Message"> | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFilter<"Message"> | $Enums.MessageCategory
    senderEmail?: StringNullableFilter<"Message"> | string | null
    senderIp?: StringNullableFilter<"Message"> | string | null
    allowResponses?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    createdById?: StringNullableFilter<"Message"> | string | null
    updatedById?: StringNullableFilter<"Message"> | string | null
    approvedById?: StringNullableFilter<"Message"> | string | null
    beneficiaryId?: StringNullableFilter<"Message"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    beneficiary?: XOR<BeneficiaryNullableScalarRelationFilter, BeneficiaryWhereInput> | null
    responses?: ResponseListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    affiliated?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    content?: SortOrder
    nameImageUrl?: SortOrderInput | SortOrder
    messageImageUrl?: SortOrderInput | SortOrder
    messageStatus?: SortOrder
    messageCategory?: SortOrder
    senderEmail?: SortOrderInput | SortOrder
    senderIp?: SortOrderInput | SortOrder
    allowResponses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    beneficiaryId?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    beneficiary?: BeneficiaryOrderByWithRelationInput
    responses?: ResponseOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    title?: StringNullableFilter<"Message"> | string | null
    affiliated?: StringNullableFilter<"Message"> | string | null
    name?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    nameImageUrl?: StringNullableFilter<"Message"> | string | null
    messageImageUrl?: StringNullableFilter<"Message"> | string | null
    messageStatus?: EnumPublishStatusFilter<"Message"> | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFilter<"Message"> | $Enums.MessageCategory
    senderEmail?: StringNullableFilter<"Message"> | string | null
    senderIp?: StringNullableFilter<"Message"> | string | null
    allowResponses?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    createdById?: StringNullableFilter<"Message"> | string | null
    updatedById?: StringNullableFilter<"Message"> | string | null
    approvedById?: StringNullableFilter<"Message"> | string | null
    beneficiaryId?: StringNullableFilter<"Message"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    beneficiary?: XOR<BeneficiaryNullableScalarRelationFilter, BeneficiaryWhereInput> | null
    responses?: ResponseListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    affiliated?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    content?: SortOrder
    nameImageUrl?: SortOrderInput | SortOrder
    messageImageUrl?: SortOrderInput | SortOrder
    messageStatus?: SortOrder
    messageCategory?: SortOrder
    senderEmail?: SortOrderInput | SortOrder
    senderIp?: SortOrderInput | SortOrder
    allowResponses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    beneficiaryId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    title?: StringNullableWithAggregatesFilter<"Message"> | string | null
    affiliated?: StringNullableWithAggregatesFilter<"Message"> | string | null
    name?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: JsonWithAggregatesFilter<"Message">
    nameImageUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageImageUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageStatus?: EnumPublishStatusWithAggregatesFilter<"Message"> | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryWithAggregatesFilter<"Message"> | $Enums.MessageCategory
    senderEmail?: StringNullableWithAggregatesFilter<"Message"> | string | null
    senderIp?: StringNullableWithAggregatesFilter<"Message"> | string | null
    allowResponses?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Message"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Message"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Message"> | string | null
    beneficiaryId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    title?: StringFilter<"Report"> | string
    slug?: StringFilter<"Report"> | string
    images?: StringNullableListFilter<"Report">
    files?: StringNullableListFilter<"Report">
    publishStatus?: EnumPublishStatusFilter<"Report"> | $Enums.PublishStatus
    accessCount?: IntFilter<"Report"> | number
    downloadCount?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    createdById?: StringFilter<"Report"> | string
    updatedById?: StringNullableFilter<"Report"> | string | null
    approvedById?: StringNullableFilter<"Report"> | string | null
    projectId?: IntNullableFilter<"Report"> | number | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    events?: EventListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    images?: SortOrder
    files?: SortOrder
    publishStatus?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    approvedBy?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    title?: StringFilter<"Report"> | string
    images?: StringNullableListFilter<"Report">
    files?: StringNullableListFilter<"Report">
    publishStatus?: EnumPublishStatusFilter<"Report"> | $Enums.PublishStatus
    accessCount?: IntFilter<"Report"> | number
    downloadCount?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    createdById?: StringFilter<"Report"> | string
    updatedById?: StringNullableFilter<"Report"> | string | null
    approvedById?: StringNullableFilter<"Report"> | string | null
    projectId?: IntNullableFilter<"Report"> | number | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    events?: EventListRelationFilter
  }, "id" | "slug">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    images?: SortOrder
    files?: SortOrder
    publishStatus?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    title?: StringWithAggregatesFilter<"Report"> | string
    slug?: StringWithAggregatesFilter<"Report"> | string
    images?: StringNullableListFilter<"Report">
    files?: StringNullableListFilter<"Report">
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"Report"> | $Enums.PublishStatus
    accessCount?: IntWithAggregatesFilter<"Report"> | number
    downloadCount?: IntWithAggregatesFilter<"Report"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    createdById?: StringWithAggregatesFilter<"Report"> | string
    updatedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    projectId?: IntNullableWithAggregatesFilter<"Report"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    about?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    loginStatus?: EnumLoginStatusFilter<"User"> | $Enums.LoginStatus
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordChangeLog?: PasswordChangeLogListRelationFilter
    failedLogins?: FailedLoginAttemptListRelationFilter
    sessions?: SessionListRelationFilter
    approvedMessages?: MessageListRelationFilter
    createdMessages?: MessageListRelationFilter
    updatedMessages?: MessageListRelationFilter
    responses?: ResponseListRelationFilter
    approvedProjects?: ProjectListRelationFilter
    createdProjects?: ProjectListRelationFilter
    updatedProjects?: ProjectListRelationFilter
    approvedReports?: ReportListRelationFilter
    createdReports?: ReportListRelationFilter
    updatedReports?: ReportListRelationFilter
    createdEvents?: EventListRelationFilter
    updatedEvents?: EventListRelationFilter
    createdBeneficiaries?: BeneficiaryListRelationFilter
    updatedBeneficiaries?: BeneficiaryListRelationFilter
    approvedBeneficiaries?: BeneficiaryListRelationFilter
    createdInstitutions?: InstitutionListRelationFilter
    updatedInstitutions?: InstitutionListRelationFilter
    approvedInstitutions?: InstitutionListRelationFilter
    createdFaqs?: FAQListRelationFilter
    updatedFaqs?: FAQListRelationFilter
    approvedFaqs?: FAQListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    about?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    loginStatus?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    passwordHistory?: PasswordHistoryOrderByRelationAggregateInput
    passwordChangeLog?: PasswordChangeLogOrderByRelationAggregateInput
    failedLogins?: FailedLoginAttemptOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    approvedMessages?: MessageOrderByRelationAggregateInput
    createdMessages?: MessageOrderByRelationAggregateInput
    updatedMessages?: MessageOrderByRelationAggregateInput
    responses?: ResponseOrderByRelationAggregateInput
    approvedProjects?: ProjectOrderByRelationAggregateInput
    createdProjects?: ProjectOrderByRelationAggregateInput
    updatedProjects?: ProjectOrderByRelationAggregateInput
    approvedReports?: ReportOrderByRelationAggregateInput
    createdReports?: ReportOrderByRelationAggregateInput
    updatedReports?: ReportOrderByRelationAggregateInput
    createdEvents?: EventOrderByRelationAggregateInput
    updatedEvents?: EventOrderByRelationAggregateInput
    createdBeneficiaries?: BeneficiaryOrderByRelationAggregateInput
    updatedBeneficiaries?: BeneficiaryOrderByRelationAggregateInput
    approvedBeneficiaries?: BeneficiaryOrderByRelationAggregateInput
    createdInstitutions?: InstitutionOrderByRelationAggregateInput
    updatedInstitutions?: InstitutionOrderByRelationAggregateInput
    approvedInstitutions?: InstitutionOrderByRelationAggregateInput
    createdFaqs?: FAQOrderByRelationAggregateInput
    updatedFaqs?: FAQOrderByRelationAggregateInput
    approvedFaqs?: FAQOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    about?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    loginStatus?: EnumLoginStatusFilter<"User"> | $Enums.LoginStatus
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHistory?: PasswordHistoryListRelationFilter
    passwordChangeLog?: PasswordChangeLogListRelationFilter
    failedLogins?: FailedLoginAttemptListRelationFilter
    sessions?: SessionListRelationFilter
    approvedMessages?: MessageListRelationFilter
    createdMessages?: MessageListRelationFilter
    updatedMessages?: MessageListRelationFilter
    responses?: ResponseListRelationFilter
    approvedProjects?: ProjectListRelationFilter
    createdProjects?: ProjectListRelationFilter
    updatedProjects?: ProjectListRelationFilter
    approvedReports?: ReportListRelationFilter
    createdReports?: ReportListRelationFilter
    updatedReports?: ReportListRelationFilter
    createdEvents?: EventListRelationFilter
    updatedEvents?: EventListRelationFilter
    createdBeneficiaries?: BeneficiaryListRelationFilter
    updatedBeneficiaries?: BeneficiaryListRelationFilter
    approvedBeneficiaries?: BeneficiaryListRelationFilter
    createdInstitutions?: InstitutionListRelationFilter
    updatedInstitutions?: InstitutionListRelationFilter
    approvedInstitutions?: InstitutionListRelationFilter
    createdFaqs?: FAQListRelationFilter
    updatedFaqs?: FAQListRelationFilter
    approvedFaqs?: FAQListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    about?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    loginStatus?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    about?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginStatus?: EnumLoginStatusWithAggregatesFilter<"User"> | $Enums.LoginStatus
    failedLoginCount?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type PasswordHistoryWhereInput = {
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    userId?: StringFilter<"PasswordHistory"> | string
    passwordHash?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    OR?: PasswordHistoryWhereInput[]
    NOT?: PasswordHistoryWhereInput | PasswordHistoryWhereInput[]
    userId?: StringFilter<"PasswordHistory"> | string
    passwordHash?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordHistoryCountOrderByAggregateInput
    _max?: PasswordHistoryMaxOrderByAggregateInput
    _min?: PasswordHistoryMinOrderByAggregateInput
  }

  export type PasswordHistoryScalarWhereWithAggregatesInput = {
    AND?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    OR?: PasswordHistoryScalarWhereWithAggregatesInput[]
    NOT?: PasswordHistoryScalarWhereWithAggregatesInput | PasswordHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordHistory"> | string
    userId?: StringWithAggregatesFilter<"PasswordHistory"> | string
    passwordHash?: StringWithAggregatesFilter<"PasswordHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordChangeLogWhereInput = {
    AND?: PasswordChangeLogWhereInput | PasswordChangeLogWhereInput[]
    OR?: PasswordChangeLogWhereInput[]
    NOT?: PasswordChangeLogWhereInput | PasswordChangeLogWhereInput[]
    id?: StringFilter<"PasswordChangeLog"> | string
    userId?: StringFilter<"PasswordChangeLog"> | string
    changedBy?: StringNullableFilter<"PasswordChangeLog"> | string | null
    ip?: StringNullableFilter<"PasswordChangeLog"> | string | null
    userAgent?: StringNullableFilter<"PasswordChangeLog"> | string | null
    createdAt?: DateTimeFilter<"PasswordChangeLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordChangeLogWhereInput | PasswordChangeLogWhereInput[]
    OR?: PasswordChangeLogWhereInput[]
    NOT?: PasswordChangeLogWhereInput | PasswordChangeLogWhereInput[]
    userId?: StringFilter<"PasswordChangeLog"> | string
    changedBy?: StringNullableFilter<"PasswordChangeLog"> | string | null
    ip?: StringNullableFilter<"PasswordChangeLog"> | string | null
    userAgent?: StringNullableFilter<"PasswordChangeLog"> | string | null
    createdAt?: DateTimeFilter<"PasswordChangeLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordChangeLogCountOrderByAggregateInput
    _max?: PasswordChangeLogMaxOrderByAggregateInput
    _min?: PasswordChangeLogMinOrderByAggregateInput
  }

  export type PasswordChangeLogScalarWhereWithAggregatesInput = {
    AND?: PasswordChangeLogScalarWhereWithAggregatesInput | PasswordChangeLogScalarWhereWithAggregatesInput[]
    OR?: PasswordChangeLogScalarWhereWithAggregatesInput[]
    NOT?: PasswordChangeLogScalarWhereWithAggregatesInput | PasswordChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordChangeLog"> | string
    userId?: StringWithAggregatesFilter<"PasswordChangeLog"> | string
    changedBy?: StringNullableWithAggregatesFilter<"PasswordChangeLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"PasswordChangeLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PasswordChangeLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordChangeLog"> | Date | string
  }

  export type FailedLoginAttemptWhereInput = {
    AND?: FailedLoginAttemptWhereInput | FailedLoginAttemptWhereInput[]
    OR?: FailedLoginAttemptWhereInput[]
    NOT?: FailedLoginAttemptWhereInput | FailedLoginAttemptWhereInput[]
    id?: StringFilter<"FailedLoginAttempt"> | string
    userId?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    ip?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    createdAt?: DateTimeFilter<"FailedLoginAttempt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FailedLoginAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FailedLoginAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FailedLoginAttemptWhereInput | FailedLoginAttemptWhereInput[]
    OR?: FailedLoginAttemptWhereInput[]
    NOT?: FailedLoginAttemptWhereInput | FailedLoginAttemptWhereInput[]
    userId?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    ip?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    createdAt?: DateTimeFilter<"FailedLoginAttempt"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FailedLoginAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FailedLoginAttemptCountOrderByAggregateInput
    _max?: FailedLoginAttemptMaxOrderByAggregateInput
    _min?: FailedLoginAttemptMinOrderByAggregateInput
  }

  export type FailedLoginAttemptScalarWhereWithAggregatesInput = {
    AND?: FailedLoginAttemptScalarWhereWithAggregatesInput | FailedLoginAttemptScalarWhereWithAggregatesInput[]
    OR?: FailedLoginAttemptScalarWhereWithAggregatesInput[]
    NOT?: FailedLoginAttemptScalarWhereWithAggregatesInput | FailedLoginAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FailedLoginAttempt"> | string
    userId?: StringNullableWithAggregatesFilter<"FailedLoginAttempt"> | string | null
    ip?: StringNullableWithAggregatesFilter<"FailedLoginAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FailedLoginAttempt"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    startedAt?: DateTimeFilter<"Session"> | Date | string
    lastSeenAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    lastSeenAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    active?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    startedAt?: DateTimeFilter<"Session"> | Date | string
    lastSeenAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    lastSeenAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    startedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    ip?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    active?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    slug?: StringFilter<"Event"> | string
    eventTitle?: StringFilter<"Event"> | string
    eventDescription?: JsonFilter<"Event">
    eventDetails?: JsonNullableFilter<"Event">
    eventLocation?: StringNullableFilter<"Event"> | string | null
    eventBanner?: StringFilter<"Event"> | string
    eventImages?: StringNullableListFilter<"Event">
    eventFile?: StringFilter<"Event"> | string
    eventStartDate?: DateTimeFilter<"Event"> | Date | string
    eventEndDate?: DateTimeFilter<"Event"> | Date | string
    eventTags?: StringNullableListFilter<"Event">
    eventStatus?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFilter<"Event"> | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFilter<"Event"> | $Enums.AttendanceType
    maxAttendees?: IntNullableFilter<"Event"> | number | null
    accessCount?: IntFilter<"Event"> | number
    downloadCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    createdById?: StringFilter<"Event"> | string
    updatedById?: StringFilter<"Event"> | string
    projectId?: IntNullableFilter<"Event"> | number | null
    reportId?: IntNullableFilter<"Event"> | number | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    eventDetails?: SortOrderInput | SortOrder
    eventLocation?: SortOrderInput | SortOrder
    eventBanner?: SortOrder
    eventImages?: SortOrder
    eventFile?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTags?: SortOrder
    eventStatus?: SortOrder
    publishStatus?: SortOrder
    eventAttendance?: SortOrder
    maxAttendees?: SortOrderInput | SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    projectId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    report?: ReportOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    eventTitle?: StringFilter<"Event"> | string
    eventDescription?: JsonFilter<"Event">
    eventDetails?: JsonNullableFilter<"Event">
    eventLocation?: StringNullableFilter<"Event"> | string | null
    eventBanner?: StringFilter<"Event"> | string
    eventImages?: StringNullableListFilter<"Event">
    eventFile?: StringFilter<"Event"> | string
    eventStartDate?: DateTimeFilter<"Event"> | Date | string
    eventEndDate?: DateTimeFilter<"Event"> | Date | string
    eventTags?: StringNullableListFilter<"Event">
    eventStatus?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFilter<"Event"> | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFilter<"Event"> | $Enums.AttendanceType
    maxAttendees?: IntNullableFilter<"Event"> | number | null
    accessCount?: IntFilter<"Event"> | number
    downloadCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    createdById?: StringFilter<"Event"> | string
    updatedById?: StringFilter<"Event"> | string
    projectId?: IntNullableFilter<"Event"> | number | null
    reportId?: IntNullableFilter<"Event"> | number | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }, "id" | "slug">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    eventDetails?: SortOrderInput | SortOrder
    eventLocation?: SortOrderInput | SortOrder
    eventBanner?: SortOrder
    eventImages?: SortOrder
    eventFile?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTags?: SortOrder
    eventStatus?: SortOrder
    publishStatus?: SortOrder
    eventAttendance?: SortOrder
    maxAttendees?: SortOrderInput | SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    projectId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    slug?: StringWithAggregatesFilter<"Event"> | string
    eventTitle?: StringWithAggregatesFilter<"Event"> | string
    eventDescription?: JsonWithAggregatesFilter<"Event">
    eventDetails?: JsonNullableWithAggregatesFilter<"Event">
    eventLocation?: StringNullableWithAggregatesFilter<"Event"> | string | null
    eventBanner?: StringWithAggregatesFilter<"Event"> | string
    eventImages?: StringNullableListFilter<"Event">
    eventFile?: StringWithAggregatesFilter<"Event"> | string
    eventStartDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    eventEndDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    eventTags?: StringNullableListFilter<"Event">
    eventStatus?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"Event"> | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeWithAggregatesFilter<"Event"> | $Enums.AttendanceType
    maxAttendees?: IntNullableWithAggregatesFilter<"Event"> | number | null
    accessCount?: IntWithAggregatesFilter<"Event"> | number
    downloadCount?: IntWithAggregatesFilter<"Event"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"Event"> | string
    updatedById?: StringWithAggregatesFilter<"Event"> | string
    projectId?: IntNullableWithAggregatesFilter<"Event"> | number | null
    reportId?: IntNullableWithAggregatesFilter<"Event"> | number | null
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    title?: StringFilter<"Video"> | string
    description?: StringFilter<"Video"> | string
    thumbnail?: StringFilter<"Video"> | string
    publishedAt?: DateTimeFilter<"Video"> | Date | string
    viewCount?: IntNullableFilter<"Video"> | number | null
    likeCount?: IntNullableFilter<"Video"> | number | null
    duration?: StringFilter<"Video"> | string
    fetchedAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    duration?: SortOrder
    fetchedAt?: SortOrder
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    title?: StringFilter<"Video"> | string
    description?: StringFilter<"Video"> | string
    thumbnail?: StringFilter<"Video"> | string
    publishedAt?: DateTimeFilter<"Video"> | Date | string
    viewCount?: IntNullableFilter<"Video"> | number | null
    likeCount?: IntNullableFilter<"Video"> | number | null
    duration?: StringFilter<"Video"> | string
    fetchedAt?: DateTimeFilter<"Video"> | Date | string
  }, "id">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    duration?: SortOrder
    fetchedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    title?: StringWithAggregatesFilter<"Video"> | string
    description?: StringWithAggregatesFilter<"Video"> | string
    thumbnail?: StringWithAggregatesFilter<"Video"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    viewCount?: IntNullableWithAggregatesFilter<"Video"> | number | null
    likeCount?: IntNullableWithAggregatesFilter<"Video"> | number | null
    duration?: StringWithAggregatesFilter<"Video"> | string
    fetchedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type YouTubeCacheMetaWhereInput = {
    AND?: YouTubeCacheMetaWhereInput | YouTubeCacheMetaWhereInput[]
    OR?: YouTubeCacheMetaWhereInput[]
    NOT?: YouTubeCacheMetaWhereInput | YouTubeCacheMetaWhereInput[]
    id?: IntFilter<"YouTubeCacheMeta"> | number
    lastFetched?: DateTimeFilter<"YouTubeCacheMeta"> | Date | string
  }

  export type YouTubeCacheMetaOrderByWithRelationInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type YouTubeCacheMetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: YouTubeCacheMetaWhereInput | YouTubeCacheMetaWhereInput[]
    OR?: YouTubeCacheMetaWhereInput[]
    NOT?: YouTubeCacheMetaWhereInput | YouTubeCacheMetaWhereInput[]
    lastFetched?: DateTimeFilter<"YouTubeCacheMeta"> | Date | string
  }, "id">

  export type YouTubeCacheMetaOrderByWithAggregationInput = {
    id?: SortOrder
    lastFetched?: SortOrder
    _count?: YouTubeCacheMetaCountOrderByAggregateInput
    _avg?: YouTubeCacheMetaAvgOrderByAggregateInput
    _max?: YouTubeCacheMetaMaxOrderByAggregateInput
    _min?: YouTubeCacheMetaMinOrderByAggregateInput
    _sum?: YouTubeCacheMetaSumOrderByAggregateInput
  }

  export type YouTubeCacheMetaScalarWhereWithAggregatesInput = {
    AND?: YouTubeCacheMetaScalarWhereWithAggregatesInput | YouTubeCacheMetaScalarWhereWithAggregatesInput[]
    OR?: YouTubeCacheMetaScalarWhereWithAggregatesInput[]
    NOT?: YouTubeCacheMetaScalarWhereWithAggregatesInput | YouTubeCacheMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YouTubeCacheMeta"> | number
    lastFetched?: DateTimeWithAggregatesFilter<"YouTubeCacheMeta"> | Date | string
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    email?: StringNullableFilter<"Institution"> | string | null
    phone?: StringNullableFilter<"Institution"> | string | null
    logo?: StringNullableFilter<"Institution"> | string | null
    institutionImages?: StringNullableListFilter<"Institution">
    headName?: StringNullableFilter<"Institution"> | string | null
    institutionType?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    updatedAt?: DateTimeFilter<"Institution"> | Date | string
    createdById?: StringFilter<"Institution"> | string
    updatedById?: StringNullableFilter<"Institution"> | string | null
    approvedById?: StringNullableFilter<"Institution"> | string | null
    locations?: LocationListRelationFilter
    beneficiaries?: BeneficiaryListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    institutionImages?: SortOrder
    headName?: SortOrderInput | SortOrder
    institutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    locations?: LocationOrderByRelationAggregateInput
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    name?: StringFilter<"Institution"> | string
    logo?: StringNullableFilter<"Institution"> | string | null
    institutionImages?: StringNullableListFilter<"Institution">
    headName?: StringNullableFilter<"Institution"> | string | null
    institutionType?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    updatedAt?: DateTimeFilter<"Institution"> | Date | string
    createdById?: StringFilter<"Institution"> | string
    updatedById?: StringNullableFilter<"Institution"> | string | null
    approvedById?: StringNullableFilter<"Institution"> | string | null
    locations?: LocationListRelationFilter
    beneficiaries?: BeneficiaryListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "email" | "phone">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    institutionImages?: SortOrder
    headName?: SortOrderInput | SortOrder
    institutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    email?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    institutionImages?: StringNullableListFilter<"Institution">
    headName?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    institutionType?: EnumInstitutionTypeWithAggregatesFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
    createdById?: StringWithAggregatesFilter<"Institution"> | string
    updatedById?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Institution"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    locationName?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    institutionId?: StringFilter<"Location"> | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    locationName?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    institutionId?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    locationName?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    institutionId?: StringFilter<"Location"> | string
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    locationName?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    institutionId?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    locationName?: StringNullableWithAggregatesFilter<"Location"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    institutionId?: StringWithAggregatesFilter<"Location"> | string
  }

  export type BeneficiaryWhereInput = {
    AND?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    OR?: BeneficiaryWhereInput[]
    NOT?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    id?: StringFilter<"Beneficiary"> | string
    firstName?: StringFilter<"Beneficiary"> | string
    lastName?: StringFilter<"Beneficiary"> | string
    image?: StringNullableFilter<"Beneficiary"> | string | null
    images?: StringNullableListFilter<"Beneficiary">
    gender?: EnumGenderTypeFilter<"Beneficiary"> | $Enums.GenderType
    email?: StringNullableFilter<"Beneficiary"> | string | null
    phone?: StringNullableFilter<"Beneficiary"> | string | null
    dateOfBirth?: DateTimeFilter<"Beneficiary"> | Date | string
    createdAt?: DateTimeFilter<"Beneficiary"> | Date | string
    updatedAt?: DateTimeFilter<"Beneficiary"> | Date | string
    beneficiaryStatus?: EnumPublishStatusFilter<"Beneficiary"> | $Enums.PublishStatus
    institutionId?: StringNullableFilter<"Beneficiary"> | string | null
    createdById?: StringFilter<"Beneficiary"> | string
    updatedById?: StringNullableFilter<"Beneficiary"> | string | null
    approvedById?: StringNullableFilter<"Beneficiary"> | string | null
    messages?: MessageListRelationFilter
    responses?: ResponseListRelationFilter
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BeneficiaryOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaryStatus?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    messages?: MessageOrderByRelationAggregateInput
    responses?: ResponseOrderByRelationAggregateInput
    institution?: InstitutionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type BeneficiaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    OR?: BeneficiaryWhereInput[]
    NOT?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    firstName?: StringFilter<"Beneficiary"> | string
    lastName?: StringFilter<"Beneficiary"> | string
    image?: StringNullableFilter<"Beneficiary"> | string | null
    images?: StringNullableListFilter<"Beneficiary">
    gender?: EnumGenderTypeFilter<"Beneficiary"> | $Enums.GenderType
    dateOfBirth?: DateTimeFilter<"Beneficiary"> | Date | string
    createdAt?: DateTimeFilter<"Beneficiary"> | Date | string
    updatedAt?: DateTimeFilter<"Beneficiary"> | Date | string
    beneficiaryStatus?: EnumPublishStatusFilter<"Beneficiary"> | $Enums.PublishStatus
    institutionId?: StringNullableFilter<"Beneficiary"> | string | null
    createdById?: StringFilter<"Beneficiary"> | string
    updatedById?: StringNullableFilter<"Beneficiary"> | string | null
    approvedById?: StringNullableFilter<"Beneficiary"> | string | null
    messages?: MessageListRelationFilter
    responses?: ResponseListRelationFilter
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "email" | "phone">

  export type BeneficiaryOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrderInput | SortOrder
    images?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaryStatus?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    _count?: BeneficiaryCountOrderByAggregateInput
    _max?: BeneficiaryMaxOrderByAggregateInput
    _min?: BeneficiaryMinOrderByAggregateInput
  }

  export type BeneficiaryScalarWhereWithAggregatesInput = {
    AND?: BeneficiaryScalarWhereWithAggregatesInput | BeneficiaryScalarWhereWithAggregatesInput[]
    OR?: BeneficiaryScalarWhereWithAggregatesInput[]
    NOT?: BeneficiaryScalarWhereWithAggregatesInput | BeneficiaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Beneficiary"> | string
    firstName?: StringWithAggregatesFilter<"Beneficiary"> | string
    lastName?: StringWithAggregatesFilter<"Beneficiary"> | string
    image?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    images?: StringNullableListFilter<"Beneficiary">
    gender?: EnumGenderTypeWithAggregatesFilter<"Beneficiary"> | $Enums.GenderType
    email?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"Beneficiary"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Beneficiary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Beneficiary"> | Date | string
    beneficiaryStatus?: EnumPublishStatusWithAggregatesFilter<"Beneficiary"> | $Enums.PublishStatus
    institutionId?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    createdById?: StringWithAggregatesFilter<"Beneficiary"> | string
    updatedById?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
  }

  export type ResponseWhereInput = {
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    id?: StringFilter<"Response"> | string
    messageId?: IntFilter<"Response"> | number
    responderType?: EnumResponderTypeFilter<"Response"> | $Enums.ResponderType
    responderUserId?: StringNullableFilter<"Response"> | string | null
    responderBeneficiaryId?: StringNullableFilter<"Response"> | string | null
    content?: JsonFilter<"Response">
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    responderUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    responderBeneficiary?: XOR<BeneficiaryNullableScalarRelationFilter, BeneficiaryWhereInput> | null
  }

  export type ResponseOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    responderType?: SortOrder
    responderUserId?: SortOrderInput | SortOrder
    responderBeneficiaryId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    responderUser?: UserOrderByWithRelationInput
    responderBeneficiary?: BeneficiaryOrderByWithRelationInput
  }

  export type ResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    messageId?: IntFilter<"Response"> | number
    responderType?: EnumResponderTypeFilter<"Response"> | $Enums.ResponderType
    responderUserId?: StringNullableFilter<"Response"> | string | null
    responderBeneficiaryId?: StringNullableFilter<"Response"> | string | null
    content?: JsonFilter<"Response">
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    responderUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    responderBeneficiary?: XOR<BeneficiaryNullableScalarRelationFilter, BeneficiaryWhereInput> | null
  }, "id">

  export type ResponseOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    responderType?: SortOrder
    responderUserId?: SortOrderInput | SortOrder
    responderBeneficiaryId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResponseCountOrderByAggregateInput
    _avg?: ResponseAvgOrderByAggregateInput
    _max?: ResponseMaxOrderByAggregateInput
    _min?: ResponseMinOrderByAggregateInput
    _sum?: ResponseSumOrderByAggregateInput
  }

  export type ResponseScalarWhereWithAggregatesInput = {
    AND?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    OR?: ResponseScalarWhereWithAggregatesInput[]
    NOT?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Response"> | string
    messageId?: IntWithAggregatesFilter<"Response"> | number
    responderType?: EnumResponderTypeWithAggregatesFilter<"Response"> | $Enums.ResponderType
    responderUserId?: StringNullableWithAggregatesFilter<"Response"> | string | null
    responderBeneficiaryId?: StringNullableWithAggregatesFilter<"Response"> | string | null
    content?: JsonWithAggregatesFilter<"Response">
    createdAt?: DateTimeWithAggregatesFilter<"Response"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Response"> | Date | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: IntFilter<"FAQ"> | number
    question?: JsonFilter<"FAQ">
    answer?: JsonFilter<"FAQ">
    category?: EnumFAQCategoryFilter<"FAQ"> | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFilter<"FAQ"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
    createdById?: StringFilter<"FAQ"> | string
    updatedById?: StringFilter<"FAQ"> | string
    approvedById?: StringFilter<"FAQ"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: JsonFilter<"FAQ">
    answer?: JsonFilter<"FAQ">
    category?: EnumFAQCategoryFilter<"FAQ"> | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFilter<"FAQ"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
    createdById?: StringFilter<"FAQ"> | string
    updatedById?: StringFilter<"FAQ"> | string
    approvedById?: StringFilter<"FAQ"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _avg?: FAQAvgOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
    _sum?: FAQSumOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FAQ"> | number
    question?: JsonWithAggregatesFilter<"FAQ">
    answer?: JsonWithAggregatesFilter<"FAQ">
    category?: EnumFAQCategoryWithAggregatesFilter<"FAQ"> | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"FAQ"> | $Enums.PublishStatus
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    createdById?: StringWithAggregatesFilter<"FAQ"> | string
    updatedById?: StringWithAggregatesFilter<"FAQ"> | string
    approvedById?: StringWithAggregatesFilter<"FAQ"> | string
  }

  export type FacebookPostWhereInput = {
    AND?: FacebookPostWhereInput | FacebookPostWhereInput[]
    OR?: FacebookPostWhereInput[]
    NOT?: FacebookPostWhereInput | FacebookPostWhereInput[]
    id?: StringFilter<"FacebookPost"> | string
    message?: StringNullableFilter<"FacebookPost"> | string | null
    createdTime?: DateTimeFilter<"FacebookPost"> | Date | string
    permalinkUrl?: StringFilter<"FacebookPost"> | string
    fullPicture?: StringFilter<"FacebookPost"> | string
    fetchedAt?: DateTimeFilter<"FacebookPost"> | Date | string
  }

  export type FacebookPostOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    createdTime?: SortOrder
    permalinkUrl?: SortOrder
    fullPicture?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FacebookPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacebookPostWhereInput | FacebookPostWhereInput[]
    OR?: FacebookPostWhereInput[]
    NOT?: FacebookPostWhereInput | FacebookPostWhereInput[]
    message?: StringNullableFilter<"FacebookPost"> | string | null
    createdTime?: DateTimeFilter<"FacebookPost"> | Date | string
    permalinkUrl?: StringFilter<"FacebookPost"> | string
    fullPicture?: StringFilter<"FacebookPost"> | string
    fetchedAt?: DateTimeFilter<"FacebookPost"> | Date | string
  }, "id">

  export type FacebookPostOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    createdTime?: SortOrder
    permalinkUrl?: SortOrder
    fullPicture?: SortOrder
    fetchedAt?: SortOrder
    _count?: FacebookPostCountOrderByAggregateInput
    _max?: FacebookPostMaxOrderByAggregateInput
    _min?: FacebookPostMinOrderByAggregateInput
  }

  export type FacebookPostScalarWhereWithAggregatesInput = {
    AND?: FacebookPostScalarWhereWithAggregatesInput | FacebookPostScalarWhereWithAggregatesInput[]
    OR?: FacebookPostScalarWhereWithAggregatesInput[]
    NOT?: FacebookPostScalarWhereWithAggregatesInput | FacebookPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacebookPost"> | string
    message?: StringNullableWithAggregatesFilter<"FacebookPost"> | string | null
    createdTime?: DateTimeWithAggregatesFilter<"FacebookPost"> | Date | string
    permalinkUrl?: StringWithAggregatesFilter<"FacebookPost"> | string
    fullPicture?: StringWithAggregatesFilter<"FacebookPost"> | string
    fetchedAt?: DateTimeWithAggregatesFilter<"FacebookPost"> | Date | string
  }

  export type FacebookCacheMetaWhereInput = {
    AND?: FacebookCacheMetaWhereInput | FacebookCacheMetaWhereInput[]
    OR?: FacebookCacheMetaWhereInput[]
    NOT?: FacebookCacheMetaWhereInput | FacebookCacheMetaWhereInput[]
    id?: IntFilter<"FacebookCacheMeta"> | number
    lastFetched?: DateTimeFilter<"FacebookCacheMeta"> | Date | string
  }

  export type FacebookCacheMetaOrderByWithRelationInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type FacebookCacheMetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FacebookCacheMetaWhereInput | FacebookCacheMetaWhereInput[]
    OR?: FacebookCacheMetaWhereInput[]
    NOT?: FacebookCacheMetaWhereInput | FacebookCacheMetaWhereInput[]
    lastFetched?: DateTimeFilter<"FacebookCacheMeta"> | Date | string
  }, "id">

  export type FacebookCacheMetaOrderByWithAggregationInput = {
    id?: SortOrder
    lastFetched?: SortOrder
    _count?: FacebookCacheMetaCountOrderByAggregateInput
    _avg?: FacebookCacheMetaAvgOrderByAggregateInput
    _max?: FacebookCacheMetaMaxOrderByAggregateInput
    _min?: FacebookCacheMetaMinOrderByAggregateInput
    _sum?: FacebookCacheMetaSumOrderByAggregateInput
  }

  export type FacebookCacheMetaScalarWhereWithAggregatesInput = {
    AND?: FacebookCacheMetaScalarWhereWithAggregatesInput | FacebookCacheMetaScalarWhereWithAggregatesInput[]
    OR?: FacebookCacheMetaScalarWhereWithAggregatesInput[]
    NOT?: FacebookCacheMetaScalarWhereWithAggregatesInput | FacebookCacheMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacebookCacheMeta"> | number
    lastFetched?: DateTimeWithAggregatesFilter<"FacebookCacheMeta"> | Date | string
  }

  export type ProjectCreateInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedProjectsInput
    createdBy: UserCreateNestedOneWithoutCreatedProjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedProjectsInput
    reports?: ReportCreateNestedManyWithoutProjectInput
    events?: EventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutProjectInput
    events?: EventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedProjectsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedProjectsNestedInput
    reports?: ReportUpdateManyWithoutProjectNestedInput
    events?: EventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutProjectNestedInput
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomePageCreateInput = {
    heroVideo: string
    vision: string
    mission: string
    focus: string
    coreValues: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageUncheckedCreateInput = {
    id?: number
    heroVideo: string
    vision: string
    mission: string
    focus: string
    coreValues: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageUpdateInput = {
    heroVideo?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    mission?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    coreValues?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroVideo?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    mission?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    coreValues?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageCreateManyInput = {
    id?: number
    heroVideo: string
    vision: string
    mission: string
    focus: string
    coreValues: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageUpdateManyMutationInput = {
    heroVideo?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    mission?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    coreValues?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroVideo?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    mission?: StringFieldUpdateOperationsInput | string
    focus?: StringFieldUpdateOperationsInput | string
    coreValues?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedMessagesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMessagesInput
    approver?: UserCreateNestedOneWithoutApprovedMessagesInput
    beneficiary?: BeneficiaryCreateNestedOneWithoutMessagesInput
    responses?: ResponseCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedMessagesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMessagesNestedInput
    approver?: UserUpdateOneWithoutApprovedMessagesNestedInput
    beneficiary?: BeneficiaryUpdateOneWithoutMessagesNestedInput
    responses?: ResponseUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedReportsInput
    createdBy: UserCreateNestedOneWithoutCreatedReportsInput
    project?: ProjectCreateNestedOneWithoutReportsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedReportsInput
    events?: EventCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    projectId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedReportsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
    project?: ProjectUpdateOneWithoutReportsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedReportsNestedInput
    events?: EventUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    projectId?: number | null
  }

  export type ReportUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordHistoryCreateInput = {
    id?: string
    passwordHash: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordHistoryInput
  }

  export type PasswordHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordHistoryNestedInput
  }

  export type PasswordHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryCreateManyInput = {
    id?: string
    userId: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogCreateInput = {
    id?: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordChangeLogInput
  }

  export type PasswordChangeLogUncheckedCreateInput = {
    id?: string
    userId: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordChangeLogNestedInput
  }

  export type PasswordChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogCreateManyInput = {
    id?: string
    userId: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptCreateInput = {
    id?: string
    ip?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutFailedLoginsInput
  }

  export type FailedLoginAttemptUncheckedCreateInput = {
    id?: string
    userId?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type FailedLoginAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutFailedLoginsNestedInput
  }

  export type FailedLoginAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptCreateManyInput = {
    id?: string
    userId?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type FailedLoginAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateInput = {
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedEventsInput
    updatedBy: UserCreateNestedOneWithoutUpdatedEventsInput
    project?: ProjectCreateNestedOneWithoutEventsInput
    report?: ReportCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type EventUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedEventsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedEventsNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
    report?: ReportUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventCreateManyInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type EventUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoCreateInput = {
    id: string
    title: string
    description: string
    thumbnail: string
    publishedAt: Date | string
    viewCount?: number | null
    likeCount?: number | null
    duration: string
    fetchedAt?: Date | string
  }

  export type VideoUncheckedCreateInput = {
    id: string
    title: string
    description: string
    thumbnail: string
    publishedAt: Date | string
    viewCount?: number | null
    likeCount?: number | null
    duration: string
    fetchedAt?: Date | string
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id: string
    title: string
    description: string
    thumbnail: string
    publishedAt: Date | string
    viewCount?: number | null
    likeCount?: number | null
    duration: string
    fetchedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: NullableIntFieldUpdateOperationsInput | number | null
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeCacheMetaCreateInput = {
    id?: number
    lastFetched: Date | string
  }

  export type YouTubeCacheMetaUncheckedCreateInput = {
    id?: number
    lastFetched: Date | string
  }

  export type YouTubeCacheMetaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeCacheMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeCacheMetaCreateManyInput = {
    id?: number
    lastFetched: Date | string
  }

  export type YouTubeCacheMetaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeCacheMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutInstitutionInput
    createdBy: UserCreateNestedOneWithoutCreatedInstitutionsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedInstitutionsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedInstitutionsInput
  }

  export type InstitutionUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutInstitutionNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedInstitutionsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type InstitutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
    institution: InstitutionCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
    institutionId: string
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    institution?: InstitutionUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateManyInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
    institutionId: string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type BeneficiaryCreateInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type BeneficiaryCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type BeneficiaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
  }

  export type BeneficiaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseCreateInput = {
    id?: string
    responderType?: $Enums.ResponderType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutResponsesInput
    responderUser?: UserCreateNestedOneWithoutResponsesInput
    responderBeneficiary?: BeneficiaryCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutResponsesNestedInput
    responderUser?: UserUpdateOneWithoutResponsesNestedInput
    responderBeneficiary?: BeneficiaryUpdateOneWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseCreateManyInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateInput = {
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedFaqsInput
    updatedBy: UserCreateNestedOneWithoutUpdatedFaqsInput
    approvedBy: UserCreateNestedOneWithoutApprovedFaqsInput
  }

  export type FAQUncheckedCreateInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    approvedById: string
  }

  export type FAQUpdateInput = {
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedFaqsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedFaqsNestedInput
    approvedBy?: UserUpdateOneRequiredWithoutApprovedFaqsNestedInput
  }

  export type FAQUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQCreateManyInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    approvedById: string
  }

  export type FAQUpdateManyMutationInput = {
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FacebookPostCreateInput = {
    id: string
    message?: string | null
    createdTime: Date | string
    permalinkUrl: string
    fullPicture: string
    fetchedAt?: Date | string
  }

  export type FacebookPostUncheckedCreateInput = {
    id: string
    message?: string | null
    createdTime: Date | string
    permalinkUrl: string
    fullPicture: string
    fetchedAt?: Date | string
  }

  export type FacebookPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: DateTimeFieldUpdateOperationsInput | Date | string
    permalinkUrl?: StringFieldUpdateOperationsInput | string
    fullPicture?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: DateTimeFieldUpdateOperationsInput | Date | string
    permalinkUrl?: StringFieldUpdateOperationsInput | string
    fullPicture?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostCreateManyInput = {
    id: string
    message?: string | null
    createdTime: Date | string
    permalinkUrl: string
    fullPicture: string
    fetchedAt?: Date | string
  }

  export type FacebookPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: DateTimeFieldUpdateOperationsInput | Date | string
    permalinkUrl?: StringFieldUpdateOperationsInput | string
    fullPicture?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: DateTimeFieldUpdateOperationsInput | Date | string
    permalinkUrl?: StringFieldUpdateOperationsInput | string
    fullPicture?: StringFieldUpdateOperationsInput | string
    fetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCacheMetaCreateInput = {
    id?: number
    lastFetched: Date | string
  }

  export type FacebookCacheMetaUncheckedCreateInput = {
    id?: number
    lastFetched: Date | string
  }

  export type FacebookCacheMetaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCacheMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCacheMetaCreateManyInput = {
    id?: number
    lastFetched: Date | string
  }

  export type FacebookCacheMetaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCacheMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastFetched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    images?: SortOrder
    projectStatus?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    projectStatus?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    projectStatus?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type HomePageCountOrderByAggregateInput = {
    id?: SortOrder
    heroVideo?: SortOrder
    vision?: SortOrder
    mission?: SortOrder
    focus?: SortOrder
    coreValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HomePageMaxOrderByAggregateInput = {
    id?: SortOrder
    heroVideo?: SortOrder
    vision?: SortOrder
    mission?: SortOrder
    focus?: SortOrder
    coreValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageMinOrderByAggregateInput = {
    id?: SortOrder
    heroVideo?: SortOrder
    vision?: SortOrder
    mission?: SortOrder
    focus?: SortOrder
    coreValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumMessageCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageCategory | EnumMessageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageCategoryFilter<$PrismaModel> | $Enums.MessageCategory
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BeneficiaryNullableScalarRelationFilter = {
    is?: BeneficiaryWhereInput | null
    isNot?: BeneficiaryWhereInput | null
  }

  export type ResponseListRelationFilter = {
    every?: ResponseWhereInput
    some?: ResponseWhereInput
    none?: ResponseWhereInput
  }

  export type ResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    affiliated?: SortOrder
    name?: SortOrder
    content?: SortOrder
    nameImageUrl?: SortOrder
    messageImageUrl?: SortOrder
    messageStatus?: SortOrder
    messageCategory?: SortOrder
    senderEmail?: SortOrder
    senderIp?: SortOrder
    allowResponses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    beneficiaryId?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    affiliated?: SortOrder
    name?: SortOrder
    nameImageUrl?: SortOrder
    messageImageUrl?: SortOrder
    messageStatus?: SortOrder
    messageCategory?: SortOrder
    senderEmail?: SortOrder
    senderIp?: SortOrder
    allowResponses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    beneficiaryId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    affiliated?: SortOrder
    name?: SortOrder
    nameImageUrl?: SortOrder
    messageImageUrl?: SortOrder
    messageStatus?: SortOrder
    messageCategory?: SortOrder
    senderEmail?: SortOrder
    senderIp?: SortOrder
    allowResponses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    beneficiaryId?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumMessageCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageCategory | EnumMessageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MessageCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageCategoryFilter<$PrismaModel>
    _max?: NestedEnumMessageCategoryFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    images?: SortOrder
    files?: SortOrder
    publishStatus?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    projectId?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    projectId?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    publishStatus?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    projectId?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    publishStatus?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
    projectId?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    projectId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumLoginStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginStatus | EnumLoginStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginStatusFilter<$PrismaModel> | $Enums.LoginStatus
  }

  export type PasswordHistoryListRelationFilter = {
    every?: PasswordHistoryWhereInput
    some?: PasswordHistoryWhereInput
    none?: PasswordHistoryWhereInput
  }

  export type PasswordChangeLogListRelationFilter = {
    every?: PasswordChangeLogWhereInput
    some?: PasswordChangeLogWhereInput
    none?: PasswordChangeLogWhereInput
  }

  export type FailedLoginAttemptListRelationFilter = {
    every?: FailedLoginAttemptWhereInput
    some?: FailedLoginAttemptWhereInput
    none?: FailedLoginAttemptWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type BeneficiaryListRelationFilter = {
    every?: BeneficiaryWhereInput
    some?: BeneficiaryWhereInput
    none?: BeneficiaryWhereInput
  }

  export type InstitutionListRelationFilter = {
    every?: InstitutionWhereInput
    some?: InstitutionWhereInput
    none?: InstitutionWhereInput
  }

  export type FAQListRelationFilter = {
    every?: FAQWhereInput
    some?: FAQWhereInput
    none?: FAQWhereInput
  }

  export type PasswordHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FailedLoginAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BeneficiaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FAQOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    about?: SortOrder
    lastLogin?: SortOrder
    loginStatus?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    about?: SortOrder
    lastLogin?: SortOrder
    loginStatus?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    about?: SortOrder
    lastLogin?: SortOrder
    loginStatus?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginCount?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLoginStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginStatus | EnumLoginStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoginStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginStatusFilter<$PrismaModel>
    _max?: NestedEnumLoginStatusFilter<$PrismaModel>
  }

  export type PasswordHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type FailedLoginAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type FailedLoginAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type FailedLoginAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    lastSeenAt?: SortOrder
    endedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    active?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    lastSeenAt?: SortOrder
    endedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    active?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    lastSeenAt?: SortOrder
    endedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    active?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type EnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }

  export type ReportNullableScalarRelationFilter = {
    is?: ReportWhereInput | null
    isNot?: ReportWhereInput | null
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    eventDetails?: SortOrder
    eventLocation?: SortOrder
    eventBanner?: SortOrder
    eventImages?: SortOrder
    eventFile?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTags?: SortOrder
    eventStatus?: SortOrder
    publishStatus?: SortOrder
    eventAttendance?: SortOrder
    maxAttendees?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    projectId?: SortOrder
    reportId?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    maxAttendees?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    projectId?: SortOrder
    reportId?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    eventTitle?: SortOrder
    eventLocation?: SortOrder
    eventBanner?: SortOrder
    eventFile?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventStatus?: SortOrder
    publishStatus?: SortOrder
    eventAttendance?: SortOrder
    maxAttendees?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    projectId?: SortOrder
    reportId?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    eventTitle?: SortOrder
    eventLocation?: SortOrder
    eventBanner?: SortOrder
    eventFile?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventStatus?: SortOrder
    publishStatus?: SortOrder
    eventAttendance?: SortOrder
    maxAttendees?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    projectId?: SortOrder
    reportId?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    maxAttendees?: SortOrder
    accessCount?: SortOrder
    downloadCount?: SortOrder
    projectId?: SortOrder
    reportId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type EnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    duration?: SortOrder
    fetchedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    duration?: SortOrder
    fetchedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    duration?: SortOrder
    fetchedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
  }

  export type YouTubeCacheMetaCountOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type YouTubeCacheMetaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YouTubeCacheMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type YouTubeCacheMetaMinOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type YouTubeCacheMetaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    logo?: SortOrder
    institutionImages?: SortOrder
    headName?: SortOrder
    institutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    logo?: SortOrder
    headName?: SortOrder
    institutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    logo?: SortOrder
    headName?: SortOrder
    institutionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type InstitutionScalarRelationFilter = {
    is?: InstitutionWhereInput
    isNot?: InstitutionWhereInput
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    institutionId?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    institutionId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    locationName?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    institutionId?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderType | EnumGenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderTypeFilter<$PrismaModel> | $Enums.GenderType
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
  }

  export type BeneficiaryCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    images?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaryStatus?: SortOrder
    institutionId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type BeneficiaryMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaryStatus?: SortOrder
    institutionId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type BeneficiaryMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaryStatus?: SortOrder
    institutionId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumGenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderType | EnumGenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.GenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderTypeFilter<$PrismaModel>
    _max?: NestedEnumGenderTypeFilter<$PrismaModel>
  }

  export type EnumResponderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponderType | EnumResponderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResponderTypeFilter<$PrismaModel> | $Enums.ResponderType
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ResponseCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    responderType?: SortOrder
    responderUserId?: SortOrder
    responderBeneficiaryId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseAvgOrderByAggregateInput = {
    messageId?: SortOrder
  }

  export type ResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    responderType?: SortOrder
    responderUserId?: SortOrder
    responderBeneficiaryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    responderType?: SortOrder
    responderUserId?: SortOrder
    responderBeneficiaryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseSumOrderByAggregateInput = {
    messageId?: SortOrder
  }

  export type EnumResponderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponderType | EnumResponderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResponderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResponderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResponderTypeFilter<$PrismaModel>
    _max?: NestedEnumResponderTypeFilter<$PrismaModel>
  }

  export type EnumFAQCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FAQCategory | EnumFAQCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFAQCategoryFilter<$PrismaModel> | $Enums.FAQCategory
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type FAQAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    publishStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    approvedById?: SortOrder
  }

  export type FAQSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumFAQCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FAQCategory | EnumFAQCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFAQCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FAQCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFAQCategoryFilter<$PrismaModel>
    _max?: NestedEnumFAQCategoryFilter<$PrismaModel>
  }

  export type FacebookPostCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdTime?: SortOrder
    permalinkUrl?: SortOrder
    fullPicture?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FacebookPostMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdTime?: SortOrder
    permalinkUrl?: SortOrder
    fullPicture?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FacebookPostMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdTime?: SortOrder
    permalinkUrl?: SortOrder
    fullPicture?: SortOrder
    fetchedAt?: SortOrder
  }

  export type FacebookCacheMetaCountOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type FacebookCacheMetaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookCacheMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type FacebookCacheMetaMinOrderByAggregateInput = {
    id?: SortOrder
    lastFetched?: SortOrder
  }

  export type FacebookCacheMetaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectCreateimagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutApprovedProjectsInput = {
    create?: XOR<UserCreateWithoutApprovedProjectsInput, UserUncheckedCreateWithoutApprovedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedProjectsInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedProjectsInput = {
    create?: XOR<UserCreateWithoutUpdatedProjectsInput, UserUncheckedCreateWithoutUpdatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput> | ReportCreateWithoutProjectInput[] | ReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutProjectInput | ReportCreateOrConnectWithoutProjectInput[]
    createMany?: ReportCreateManyProjectInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutProjectInput = {
    create?: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput> | EventCreateWithoutProjectInput[] | EventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProjectInput | EventCreateOrConnectWithoutProjectInput[]
    createMany?: EventCreateManyProjectInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput> | ReportCreateWithoutProjectInput[] | ReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutProjectInput | ReportCreateOrConnectWithoutProjectInput[]
    createMany?: ReportCreateManyProjectInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput> | EventCreateWithoutProjectInput[] | EventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProjectInput | EventCreateOrConnectWithoutProjectInput[]
    createMany?: EventCreateManyProjectInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProjectUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type EnumPublishStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutApprovedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedProjectsInput, UserUncheckedCreateWithoutApprovedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedProjectsInput
    upsert?: UserUpsertWithoutApprovedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedProjectsInput, UserUpdateWithoutApprovedProjectsInput>, UserUncheckedUpdateWithoutApprovedProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    upsert?: UserUpsertWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProjectsInput, UserUpdateWithoutCreatedProjectsInput>, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateOneWithoutUpdatedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedProjectsInput, UserUncheckedCreateWithoutUpdatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedProjectsInput
    upsert?: UserUpsertWithoutUpdatedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedProjectsInput, UserUpdateWithoutUpdatedProjectsInput>, UserUncheckedUpdateWithoutUpdatedProjectsInput>
  }

  export type ReportUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput> | ReportCreateWithoutProjectInput[] | ReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutProjectInput | ReportCreateOrConnectWithoutProjectInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutProjectInput | ReportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReportCreateManyProjectInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutProjectInput | ReportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutProjectInput | ReportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput> | EventCreateWithoutProjectInput[] | EventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProjectInput | EventCreateOrConnectWithoutProjectInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutProjectInput | EventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EventCreateManyProjectInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutProjectInput | EventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EventUpdateManyWithWhereWithoutProjectInput | EventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ReportUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput> | ReportCreateWithoutProjectInput[] | ReportUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutProjectInput | ReportCreateOrConnectWithoutProjectInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutProjectInput | ReportUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReportCreateManyProjectInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutProjectInput | ReportUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutProjectInput | ReportUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput> | EventCreateWithoutProjectInput[] | EventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProjectInput | EventCreateOrConnectWithoutProjectInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutProjectInput | EventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EventCreateManyProjectInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutProjectInput | EventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EventUpdateManyWithWhereWithoutProjectInput | EventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedMessagesInput = {
    create?: XOR<UserCreateWithoutCreatedMessagesInput, UserUncheckedCreateWithoutCreatedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedMessagesInput = {
    create?: XOR<UserCreateWithoutUpdatedMessagesInput, UserUncheckedCreateWithoutUpdatedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedMessagesInput = {
    create?: XOR<UserCreateWithoutApprovedMessagesInput, UserUncheckedCreateWithoutApprovedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type BeneficiaryCreateNestedOneWithoutMessagesInput = {
    create?: XOR<BeneficiaryCreateWithoutMessagesInput, BeneficiaryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutMessagesInput
    connect?: BeneficiaryWhereUniqueInput
  }

  export type ResponseCreateNestedManyWithoutMessageInput = {
    create?: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput> | ResponseCreateWithoutMessageInput[] | ResponseUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutMessageInput | ResponseCreateOrConnectWithoutMessageInput[]
    createMany?: ResponseCreateManyMessageInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput> | ResponseCreateWithoutMessageInput[] | ResponseUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutMessageInput | ResponseCreateOrConnectWithoutMessageInput[]
    createMany?: ResponseCreateManyMessageInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type EnumMessageCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MessageCategory
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutCreatedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedMessagesInput, UserUncheckedCreateWithoutCreatedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMessagesInput
    upsert?: UserUpsertWithoutCreatedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedMessagesInput, UserUpdateWithoutCreatedMessagesInput>, UserUncheckedUpdateWithoutCreatedMessagesInput>
  }

  export type UserUpdateOneWithoutUpdatedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedMessagesInput, UserUncheckedCreateWithoutUpdatedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedMessagesInput
    upsert?: UserUpsertWithoutUpdatedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedMessagesInput, UserUpdateWithoutUpdatedMessagesInput>, UserUncheckedUpdateWithoutUpdatedMessagesInput>
  }

  export type UserUpdateOneWithoutApprovedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedMessagesInput, UserUncheckedCreateWithoutApprovedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedMessagesInput
    upsert?: UserUpsertWithoutApprovedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedMessagesInput, UserUpdateWithoutApprovedMessagesInput>, UserUncheckedUpdateWithoutApprovedMessagesInput>
  }

  export type BeneficiaryUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutMessagesInput, BeneficiaryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutMessagesInput
    upsert?: BeneficiaryUpsertWithoutMessagesInput
    disconnect?: BeneficiaryWhereInput | boolean
    delete?: BeneficiaryWhereInput | boolean
    connect?: BeneficiaryWhereUniqueInput
    update?: XOR<XOR<BeneficiaryUpdateToOneWithWhereWithoutMessagesInput, BeneficiaryUpdateWithoutMessagesInput>, BeneficiaryUncheckedUpdateWithoutMessagesInput>
  }

  export type ResponseUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput> | ResponseCreateWithoutMessageInput[] | ResponseUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutMessageInput | ResponseCreateOrConnectWithoutMessageInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutMessageInput | ResponseUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ResponseCreateManyMessageInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutMessageInput | ResponseUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutMessageInput | ResponseUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput> | ResponseCreateWithoutMessageInput[] | ResponseUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutMessageInput | ResponseCreateOrConnectWithoutMessageInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutMessageInput | ResponseUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ResponseCreateManyMessageInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutMessageInput | ResponseUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutMessageInput | ResponseUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ReportCreateimagesInput = {
    set: string[]
  }

  export type ReportCreatefilesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutApprovedReportsInput = {
    create?: XOR<UserCreateWithoutApprovedReportsInput, UserUncheckedCreateWithoutApprovedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedReportsInput = {
    create?: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutReportsInput = {
    create?: XOR<ProjectCreateWithoutReportsInput, ProjectUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReportsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedReportsInput = {
    create?: XOR<UserCreateWithoutUpdatedReportsInput, UserUncheckedCreateWithoutUpdatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutReportInput = {
    create?: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput> | EventCreateWithoutReportInput[] | EventUncheckedCreateWithoutReportInput[]
    connectOrCreate?: EventCreateOrConnectWithoutReportInput | EventCreateOrConnectWithoutReportInput[]
    createMany?: EventCreateManyReportInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput> | EventCreateWithoutReportInput[] | EventUncheckedCreateWithoutReportInput[]
    connectOrCreate?: EventCreateOrConnectWithoutReportInput | EventCreateOrConnectWithoutReportInput[]
    createMany?: EventCreateManyReportInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ReportUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReportUpdatefilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutApprovedReportsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedReportsInput, UserUncheckedCreateWithoutApprovedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedReportsInput
    upsert?: UserUpsertWithoutApprovedReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedReportsInput, UserUpdateWithoutApprovedReportsInput>, UserUncheckedUpdateWithoutApprovedReportsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedReportsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportsInput
    upsert?: UserUpsertWithoutCreatedReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedReportsInput, UserUpdateWithoutCreatedReportsInput>, UserUncheckedUpdateWithoutCreatedReportsInput>
  }

  export type ProjectUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ProjectCreateWithoutReportsInput, ProjectUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReportsInput
    upsert?: ProjectUpsertWithoutReportsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutReportsInput, ProjectUpdateWithoutReportsInput>, ProjectUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneWithoutUpdatedReportsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedReportsInput, UserUncheckedCreateWithoutUpdatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedReportsInput
    upsert?: UserUpsertWithoutUpdatedReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedReportsInput, UserUpdateWithoutUpdatedReportsInput>, UserUncheckedUpdateWithoutUpdatedReportsInput>
  }

  export type EventUpdateManyWithoutReportNestedInput = {
    create?: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput> | EventCreateWithoutReportInput[] | EventUncheckedCreateWithoutReportInput[]
    connectOrCreate?: EventCreateOrConnectWithoutReportInput | EventCreateOrConnectWithoutReportInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutReportInput | EventUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: EventCreateManyReportInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutReportInput | EventUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: EventUpdateManyWithWhereWithoutReportInput | EventUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput> | EventCreateWithoutReportInput[] | EventUncheckedCreateWithoutReportInput[]
    connectOrCreate?: EventCreateOrConnectWithoutReportInput | EventCreateOrConnectWithoutReportInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutReportInput | EventUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: EventCreateManyReportInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutReportInput | EventUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: EventUpdateManyWithWhereWithoutReportInput | EventUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PasswordHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput> | PasswordHistoryCreateWithoutUserInput[] | PasswordHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutUserInput | PasswordHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PasswordHistoryCreateManyUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput> | PasswordChangeLogCreateWithoutUserInput[] | PasswordChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordChangeLogCreateOrConnectWithoutUserInput | PasswordChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: PasswordChangeLogCreateManyUserInputEnvelope
    connect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
  }

  export type FailedLoginAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput> | FailedLoginAttemptCreateWithoutUserInput[] | FailedLoginAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FailedLoginAttemptCreateOrConnectWithoutUserInput | FailedLoginAttemptCreateOrConnectWithoutUserInput[]
    createMany?: FailedLoginAttemptCreateManyUserInputEnvelope
    connect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutApproverInput = {
    create?: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput> | MessageCreateWithoutApproverInput[] | MessageUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutApproverInput | MessageCreateOrConnectWithoutApproverInput[]
    createMany?: MessageCreateManyApproverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput> | MessageCreateWithoutUpdatedByInput[] | MessageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUpdatedByInput | MessageCreateOrConnectWithoutUpdatedByInput[]
    createMany?: MessageCreateManyUpdatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ResponseCreateNestedManyWithoutResponderUserInput = {
    create?: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput> | ResponseCreateWithoutResponderUserInput[] | ResponseUncheckedCreateWithoutResponderUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderUserInput | ResponseCreateOrConnectWithoutResponderUserInput[]
    createMany?: ResponseCreateManyResponderUserInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput> | ProjectCreateWithoutApprovedByInput[] | ProjectUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovedByInput | ProjectCreateOrConnectWithoutApprovedByInput[]
    createMany?: ProjectCreateManyApprovedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput> | ProjectCreateWithoutUpdatedByInput[] | ProjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatedByInput | ProjectCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ProjectCreateManyUpdatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput> | ReportCreateWithoutApprovedByInput[] | ReportUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutApprovedByInput | ReportCreateOrConnectWithoutApprovedByInput[]
    createMany?: ReportCreateManyApprovedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput> | ReportCreateWithoutUpdatedByInput[] | ReportUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUpdatedByInput | ReportCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ReportCreateManyUpdatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput> | EventCreateWithoutUpdatedByInput[] | EventUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUpdatedByInput | EventCreateOrConnectWithoutUpdatedByInput[]
    createMany?: EventCreateManyUpdatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput> | BeneficiaryCreateWithoutCreatedByInput[] | BeneficiaryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCreatedByInput | BeneficiaryCreateOrConnectWithoutCreatedByInput[]
    createMany?: BeneficiaryCreateManyCreatedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput> | BeneficiaryCreateWithoutUpdatedByInput[] | BeneficiaryUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutUpdatedByInput | BeneficiaryCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BeneficiaryCreateManyUpdatedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput> | BeneficiaryCreateWithoutApprovedByInput[] | BeneficiaryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutApprovedByInput | BeneficiaryCreateOrConnectWithoutApprovedByInput[]
    createMany?: BeneficiaryCreateManyApprovedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type InstitutionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput> | InstitutionCreateWithoutCreatedByInput[] | InstitutionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutCreatedByInput | InstitutionCreateOrConnectWithoutCreatedByInput[]
    createMany?: InstitutionCreateManyCreatedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput> | InstitutionCreateWithoutUpdatedByInput[] | InstitutionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutUpdatedByInput | InstitutionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: InstitutionCreateManyUpdatedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput> | InstitutionCreateWithoutApprovedByInput[] | InstitutionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutApprovedByInput | InstitutionCreateOrConnectWithoutApprovedByInput[]
    createMany?: InstitutionCreateManyApprovedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type FAQCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput> | FAQCreateWithoutCreatedByInput[] | FAQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutCreatedByInput | FAQCreateOrConnectWithoutCreatedByInput[]
    createMany?: FAQCreateManyCreatedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type FAQCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput> | FAQCreateWithoutUpdatedByInput[] | FAQUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutUpdatedByInput | FAQCreateOrConnectWithoutUpdatedByInput[]
    createMany?: FAQCreateManyUpdatedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type FAQCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput> | FAQCreateWithoutApprovedByInput[] | FAQUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutApprovedByInput | FAQCreateOrConnectWithoutApprovedByInput[]
    createMany?: FAQCreateManyApprovedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type PasswordHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput> | PasswordHistoryCreateWithoutUserInput[] | PasswordHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutUserInput | PasswordHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PasswordHistoryCreateManyUserInputEnvelope
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
  }

  export type PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput> | PasswordChangeLogCreateWithoutUserInput[] | PasswordChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordChangeLogCreateOrConnectWithoutUserInput | PasswordChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: PasswordChangeLogCreateManyUserInputEnvelope
    connect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
  }

  export type FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput> | FailedLoginAttemptCreateWithoutUserInput[] | FailedLoginAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FailedLoginAttemptCreateOrConnectWithoutUserInput | FailedLoginAttemptCreateOrConnectWithoutUserInput[]
    createMany?: FailedLoginAttemptCreateManyUserInputEnvelope
    connect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput> | MessageCreateWithoutApproverInput[] | MessageUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutApproverInput | MessageCreateOrConnectWithoutApproverInput[]
    createMany?: MessageCreateManyApproverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput> | MessageCreateWithoutUpdatedByInput[] | MessageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUpdatedByInput | MessageCreateOrConnectWithoutUpdatedByInput[]
    createMany?: MessageCreateManyUpdatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutResponderUserInput = {
    create?: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput> | ResponseCreateWithoutResponderUserInput[] | ResponseUncheckedCreateWithoutResponderUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderUserInput | ResponseCreateOrConnectWithoutResponderUserInput[]
    createMany?: ResponseCreateManyResponderUserInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput> | ProjectCreateWithoutApprovedByInput[] | ProjectUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovedByInput | ProjectCreateOrConnectWithoutApprovedByInput[]
    createMany?: ProjectCreateManyApprovedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput> | ProjectCreateWithoutUpdatedByInput[] | ProjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatedByInput | ProjectCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ProjectCreateManyUpdatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput> | ReportCreateWithoutApprovedByInput[] | ReportUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutApprovedByInput | ReportCreateOrConnectWithoutApprovedByInput[]
    createMany?: ReportCreateManyApprovedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput> | ReportCreateWithoutUpdatedByInput[] | ReportUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUpdatedByInput | ReportCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ReportCreateManyUpdatedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput> | EventCreateWithoutUpdatedByInput[] | EventUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUpdatedByInput | EventCreateOrConnectWithoutUpdatedByInput[]
    createMany?: EventCreateManyUpdatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput> | BeneficiaryCreateWithoutCreatedByInput[] | BeneficiaryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCreatedByInput | BeneficiaryCreateOrConnectWithoutCreatedByInput[]
    createMany?: BeneficiaryCreateManyCreatedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput> | BeneficiaryCreateWithoutUpdatedByInput[] | BeneficiaryUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutUpdatedByInput | BeneficiaryCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BeneficiaryCreateManyUpdatedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput> | BeneficiaryCreateWithoutApprovedByInput[] | BeneficiaryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutApprovedByInput | BeneficiaryCreateOrConnectWithoutApprovedByInput[]
    createMany?: BeneficiaryCreateManyApprovedByInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type InstitutionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput> | InstitutionCreateWithoutCreatedByInput[] | InstitutionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutCreatedByInput | InstitutionCreateOrConnectWithoutCreatedByInput[]
    createMany?: InstitutionCreateManyCreatedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput> | InstitutionCreateWithoutUpdatedByInput[] | InstitutionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutUpdatedByInput | InstitutionCreateOrConnectWithoutUpdatedByInput[]
    createMany?: InstitutionCreateManyUpdatedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type InstitutionUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput> | InstitutionCreateWithoutApprovedByInput[] | InstitutionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutApprovedByInput | InstitutionCreateOrConnectWithoutApprovedByInput[]
    createMany?: InstitutionCreateManyApprovedByInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type FAQUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput> | FAQCreateWithoutCreatedByInput[] | FAQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutCreatedByInput | FAQCreateOrConnectWithoutCreatedByInput[]
    createMany?: FAQCreateManyCreatedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type FAQUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput> | FAQCreateWithoutUpdatedByInput[] | FAQUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutUpdatedByInput | FAQCreateOrConnectWithoutUpdatedByInput[]
    createMany?: FAQCreateManyUpdatedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type FAQUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput> | FAQCreateWithoutApprovedByInput[] | FAQUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutApprovedByInput | FAQCreateOrConnectWithoutApprovedByInput[]
    createMany?: FAQCreateManyApprovedByInputEnvelope
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumLoginStatusFieldUpdateOperationsInput = {
    set?: $Enums.LoginStatus
  }

  export type PasswordHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput> | PasswordHistoryCreateWithoutUserInput[] | PasswordHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutUserInput | PasswordHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordHistoryCreateManyUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutUserInput | PasswordHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput> | PasswordChangeLogCreateWithoutUserInput[] | PasswordChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordChangeLogCreateOrConnectWithoutUserInput | PasswordChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: PasswordChangeLogUpsertWithWhereUniqueWithoutUserInput | PasswordChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordChangeLogCreateManyUserInputEnvelope
    set?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    disconnect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    delete?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    connect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    update?: PasswordChangeLogUpdateWithWhereUniqueWithoutUserInput | PasswordChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordChangeLogUpdateManyWithWhereWithoutUserInput | PasswordChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordChangeLogScalarWhereInput | PasswordChangeLogScalarWhereInput[]
  }

  export type FailedLoginAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput> | FailedLoginAttemptCreateWithoutUserInput[] | FailedLoginAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FailedLoginAttemptCreateOrConnectWithoutUserInput | FailedLoginAttemptCreateOrConnectWithoutUserInput[]
    upsert?: FailedLoginAttemptUpsertWithWhereUniqueWithoutUserInput | FailedLoginAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FailedLoginAttemptCreateManyUserInputEnvelope
    set?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    disconnect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    delete?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    connect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    update?: FailedLoginAttemptUpdateWithWhereUniqueWithoutUserInput | FailedLoginAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FailedLoginAttemptUpdateManyWithWhereWithoutUserInput | FailedLoginAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FailedLoginAttemptScalarWhereInput | FailedLoginAttemptScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput> | MessageCreateWithoutApproverInput[] | MessageUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutApproverInput | MessageCreateOrConnectWithoutApproverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutApproverInput | MessageUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MessageCreateManyApproverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutApproverInput | MessageUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutApproverInput | MessageUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCreatedByInput | MessageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCreatedByInput | MessageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCreatedByInput | MessageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput> | MessageCreateWithoutUpdatedByInput[] | MessageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUpdatedByInput | MessageCreateOrConnectWithoutUpdatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUpdatedByInput | MessageUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: MessageCreateManyUpdatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUpdatedByInput | MessageUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUpdatedByInput | MessageUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ResponseUpdateManyWithoutResponderUserNestedInput = {
    create?: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput> | ResponseCreateWithoutResponderUserInput[] | ResponseUncheckedCreateWithoutResponderUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderUserInput | ResponseCreateOrConnectWithoutResponderUserInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutResponderUserInput | ResponseUpsertWithWhereUniqueWithoutResponderUserInput[]
    createMany?: ResponseCreateManyResponderUserInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutResponderUserInput | ResponseUpdateWithWhereUniqueWithoutResponderUserInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutResponderUserInput | ResponseUpdateManyWithWhereWithoutResponderUserInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput> | ProjectCreateWithoutApprovedByInput[] | ProjectUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovedByInput | ProjectCreateOrConnectWithoutApprovedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutApprovedByInput | ProjectUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ProjectCreateManyApprovedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutApprovedByInput | ProjectUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutApprovedByInput | ProjectUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatedByInput | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatedByInput | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatedByInput | ProjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput> | ProjectCreateWithoutUpdatedByInput[] | ProjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatedByInput | ProjectCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUpdatedByInput | ProjectUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ProjectCreateManyUpdatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUpdatedByInput | ProjectUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUpdatedByInput | ProjectUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput> | ReportCreateWithoutApprovedByInput[] | ReportUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutApprovedByInput | ReportCreateOrConnectWithoutApprovedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutApprovedByInput | ReportUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ReportCreateManyApprovedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutApprovedByInput | ReportUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutApprovedByInput | ReportUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput> | ReportCreateWithoutUpdatedByInput[] | ReportUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUpdatedByInput | ReportCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUpdatedByInput | ReportUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ReportCreateManyUpdatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUpdatedByInput | ReportUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUpdatedByInput | ReportUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput> | EventCreateWithoutUpdatedByInput[] | EventUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUpdatedByInput | EventCreateOrConnectWithoutUpdatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUpdatedByInput | EventUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: EventCreateManyUpdatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUpdatedByInput | EventUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUpdatedByInput | EventUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BeneficiaryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput> | BeneficiaryCreateWithoutCreatedByInput[] | BeneficiaryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCreatedByInput | BeneficiaryCreateOrConnectWithoutCreatedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutCreatedByInput | BeneficiaryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BeneficiaryCreateManyCreatedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutCreatedByInput | BeneficiaryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutCreatedByInput | BeneficiaryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BeneficiaryUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput> | BeneficiaryCreateWithoutUpdatedByInput[] | BeneficiaryUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutUpdatedByInput | BeneficiaryCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutUpdatedByInput | BeneficiaryUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BeneficiaryCreateManyUpdatedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutUpdatedByInput | BeneficiaryUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutUpdatedByInput | BeneficiaryUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BeneficiaryUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput> | BeneficiaryCreateWithoutApprovedByInput[] | BeneficiaryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutApprovedByInput | BeneficiaryCreateOrConnectWithoutApprovedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutApprovedByInput | BeneficiaryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: BeneficiaryCreateManyApprovedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutApprovedByInput | BeneficiaryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutApprovedByInput | BeneficiaryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type InstitutionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput> | InstitutionCreateWithoutCreatedByInput[] | InstitutionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutCreatedByInput | InstitutionCreateOrConnectWithoutCreatedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutCreatedByInput | InstitutionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InstitutionCreateManyCreatedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutCreatedByInput | InstitutionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutCreatedByInput | InstitutionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput> | InstitutionCreateWithoutUpdatedByInput[] | InstitutionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutUpdatedByInput | InstitutionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutUpdatedByInput | InstitutionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: InstitutionCreateManyUpdatedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutUpdatedByInput | InstitutionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutUpdatedByInput | InstitutionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput> | InstitutionCreateWithoutApprovedByInput[] | InstitutionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutApprovedByInput | InstitutionCreateOrConnectWithoutApprovedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutApprovedByInput | InstitutionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: InstitutionCreateManyApprovedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutApprovedByInput | InstitutionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutApprovedByInput | InstitutionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type FAQUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput> | FAQCreateWithoutCreatedByInput[] | FAQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutCreatedByInput | FAQCreateOrConnectWithoutCreatedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutCreatedByInput | FAQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FAQCreateManyCreatedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutCreatedByInput | FAQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutCreatedByInput | FAQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type FAQUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput> | FAQCreateWithoutUpdatedByInput[] | FAQUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutUpdatedByInput | FAQCreateOrConnectWithoutUpdatedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutUpdatedByInput | FAQUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: FAQCreateManyUpdatedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutUpdatedByInput | FAQUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutUpdatedByInput | FAQUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type FAQUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput> | FAQCreateWithoutApprovedByInput[] | FAQUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutApprovedByInput | FAQCreateOrConnectWithoutApprovedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutApprovedByInput | FAQUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: FAQCreateManyApprovedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutApprovedByInput | FAQUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutApprovedByInput | FAQUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput> | PasswordHistoryCreateWithoutUserInput[] | PasswordHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordHistoryCreateOrConnectWithoutUserInput | PasswordHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PasswordHistoryUpsertWithWhereUniqueWithoutUserInput | PasswordHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordHistoryCreateManyUserInputEnvelope
    set?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    disconnect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    delete?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    connect?: PasswordHistoryWhereUniqueInput | PasswordHistoryWhereUniqueInput[]
    update?: PasswordHistoryUpdateWithWhereUniqueWithoutUserInput | PasswordHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordHistoryUpdateManyWithWhereWithoutUserInput | PasswordHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
  }

  export type PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput> | PasswordChangeLogCreateWithoutUserInput[] | PasswordChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordChangeLogCreateOrConnectWithoutUserInput | PasswordChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: PasswordChangeLogUpsertWithWhereUniqueWithoutUserInput | PasswordChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordChangeLogCreateManyUserInputEnvelope
    set?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    disconnect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    delete?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    connect?: PasswordChangeLogWhereUniqueInput | PasswordChangeLogWhereUniqueInput[]
    update?: PasswordChangeLogUpdateWithWhereUniqueWithoutUserInput | PasswordChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordChangeLogUpdateManyWithWhereWithoutUserInput | PasswordChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordChangeLogScalarWhereInput | PasswordChangeLogScalarWhereInput[]
  }

  export type FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput> | FailedLoginAttemptCreateWithoutUserInput[] | FailedLoginAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FailedLoginAttemptCreateOrConnectWithoutUserInput | FailedLoginAttemptCreateOrConnectWithoutUserInput[]
    upsert?: FailedLoginAttemptUpsertWithWhereUniqueWithoutUserInput | FailedLoginAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FailedLoginAttemptCreateManyUserInputEnvelope
    set?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    disconnect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    delete?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    connect?: FailedLoginAttemptWhereUniqueInput | FailedLoginAttemptWhereUniqueInput[]
    update?: FailedLoginAttemptUpdateWithWhereUniqueWithoutUserInput | FailedLoginAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FailedLoginAttemptUpdateManyWithWhereWithoutUserInput | FailedLoginAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FailedLoginAttemptScalarWhereInput | FailedLoginAttemptScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput> | MessageCreateWithoutApproverInput[] | MessageUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutApproverInput | MessageCreateOrConnectWithoutApproverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutApproverInput | MessageUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MessageCreateManyApproverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutApproverInput | MessageUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutApproverInput | MessageUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCreatedByInput | MessageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCreatedByInput | MessageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCreatedByInput | MessageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput> | MessageCreateWithoutUpdatedByInput[] | MessageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUpdatedByInput | MessageCreateOrConnectWithoutUpdatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUpdatedByInput | MessageUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: MessageCreateManyUpdatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUpdatedByInput | MessageUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUpdatedByInput | MessageUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutResponderUserNestedInput = {
    create?: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput> | ResponseCreateWithoutResponderUserInput[] | ResponseUncheckedCreateWithoutResponderUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderUserInput | ResponseCreateOrConnectWithoutResponderUserInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutResponderUserInput | ResponseUpsertWithWhereUniqueWithoutResponderUserInput[]
    createMany?: ResponseCreateManyResponderUserInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutResponderUserInput | ResponseUpdateWithWhereUniqueWithoutResponderUserInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutResponderUserInput | ResponseUpdateManyWithWhereWithoutResponderUserInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput> | ProjectCreateWithoutApprovedByInput[] | ProjectUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovedByInput | ProjectCreateOrConnectWithoutApprovedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutApprovedByInput | ProjectUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ProjectCreateManyApprovedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutApprovedByInput | ProjectUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutApprovedByInput | ProjectUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatedByInput | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatedByInput | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatedByInput | ProjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput> | ProjectCreateWithoutUpdatedByInput[] | ProjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatedByInput | ProjectCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUpdatedByInput | ProjectUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ProjectCreateManyUpdatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUpdatedByInput | ProjectUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUpdatedByInput | ProjectUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput> | ReportCreateWithoutApprovedByInput[] | ReportUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutApprovedByInput | ReportCreateOrConnectWithoutApprovedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutApprovedByInput | ReportUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ReportCreateManyApprovedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutApprovedByInput | ReportUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutApprovedByInput | ReportUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput> | ReportCreateWithoutCreatedByInput[] | ReportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatedByInput | ReportCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatedByInput | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReportCreateManyCreatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatedByInput | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatedByInput | ReportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput> | ReportCreateWithoutUpdatedByInput[] | ReportUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUpdatedByInput | ReportCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUpdatedByInput | ReportUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ReportCreateManyUpdatedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUpdatedByInput | ReportUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUpdatedByInput | ReportUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput> | EventCreateWithoutUpdatedByInput[] | EventUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUpdatedByInput | EventCreateOrConnectWithoutUpdatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUpdatedByInput | EventUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: EventCreateManyUpdatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUpdatedByInput | EventUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUpdatedByInput | EventUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput> | BeneficiaryCreateWithoutCreatedByInput[] | BeneficiaryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCreatedByInput | BeneficiaryCreateOrConnectWithoutCreatedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutCreatedByInput | BeneficiaryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BeneficiaryCreateManyCreatedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutCreatedByInput | BeneficiaryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutCreatedByInput | BeneficiaryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput> | BeneficiaryCreateWithoutUpdatedByInput[] | BeneficiaryUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutUpdatedByInput | BeneficiaryCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutUpdatedByInput | BeneficiaryUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BeneficiaryCreateManyUpdatedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutUpdatedByInput | BeneficiaryUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutUpdatedByInput | BeneficiaryUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput> | BeneficiaryCreateWithoutApprovedByInput[] | BeneficiaryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutApprovedByInput | BeneficiaryCreateOrConnectWithoutApprovedByInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutApprovedByInput | BeneficiaryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: BeneficiaryCreateManyApprovedByInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutApprovedByInput | BeneficiaryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutApprovedByInput | BeneficiaryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput> | InstitutionCreateWithoutCreatedByInput[] | InstitutionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutCreatedByInput | InstitutionCreateOrConnectWithoutCreatedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutCreatedByInput | InstitutionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InstitutionCreateManyCreatedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutCreatedByInput | InstitutionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutCreatedByInput | InstitutionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput> | InstitutionCreateWithoutUpdatedByInput[] | InstitutionUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutUpdatedByInput | InstitutionCreateOrConnectWithoutUpdatedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutUpdatedByInput | InstitutionUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: InstitutionCreateManyUpdatedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutUpdatedByInput | InstitutionUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutUpdatedByInput | InstitutionUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput> | InstitutionCreateWithoutApprovedByInput[] | InstitutionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutApprovedByInput | InstitutionCreateOrConnectWithoutApprovedByInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutApprovedByInput | InstitutionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: InstitutionCreateManyApprovedByInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutApprovedByInput | InstitutionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutApprovedByInput | InstitutionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type FAQUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput> | FAQCreateWithoutCreatedByInput[] | FAQUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutCreatedByInput | FAQCreateOrConnectWithoutCreatedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutCreatedByInput | FAQUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FAQCreateManyCreatedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutCreatedByInput | FAQUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutCreatedByInput | FAQUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type FAQUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput> | FAQCreateWithoutUpdatedByInput[] | FAQUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutUpdatedByInput | FAQCreateOrConnectWithoutUpdatedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutUpdatedByInput | FAQUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: FAQCreateManyUpdatedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutUpdatedByInput | FAQUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutUpdatedByInput | FAQUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type FAQUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput> | FAQCreateWithoutApprovedByInput[] | FAQUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: FAQCreateOrConnectWithoutApprovedByInput | FAQCreateOrConnectWithoutApprovedByInput[]
    upsert?: FAQUpsertWithWhereUniqueWithoutApprovedByInput | FAQUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: FAQCreateManyApprovedByInputEnvelope
    set?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    disconnect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    delete?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    connect?: FAQWhereUniqueInput | FAQWhereUniqueInput[]
    update?: FAQUpdateWithWhereUniqueWithoutApprovedByInput | FAQUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: FAQUpdateManyWithWhereWithoutApprovedByInput | FAQUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: FAQScalarWhereInput | FAQScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPasswordHistoryInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordHistoryInput
    upsert?: UserUpsertWithoutPasswordHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordHistoryInput, UserUpdateWithoutPasswordHistoryInput>, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type UserCreateNestedOneWithoutPasswordChangeLogInput = {
    create?: XOR<UserCreateWithoutPasswordChangeLogInput, UserUncheckedCreateWithoutPasswordChangeLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordChangeLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordChangeLogNestedInput = {
    create?: XOR<UserCreateWithoutPasswordChangeLogInput, UserUncheckedCreateWithoutPasswordChangeLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordChangeLogInput
    upsert?: UserUpsertWithoutPasswordChangeLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordChangeLogInput, UserUpdateWithoutPasswordChangeLogInput>, UserUncheckedUpdateWithoutPasswordChangeLogInput>
  }

  export type UserCreateNestedOneWithoutFailedLoginsInput = {
    create?: XOR<UserCreateWithoutFailedLoginsInput, UserUncheckedCreateWithoutFailedLoginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFailedLoginsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutFailedLoginsNestedInput = {
    create?: XOR<UserCreateWithoutFailedLoginsInput, UserUncheckedCreateWithoutFailedLoginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFailedLoginsInput
    upsert?: UserUpsertWithoutFailedLoginsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFailedLoginsInput, UserUpdateWithoutFailedLoginsInput>, UserUncheckedUpdateWithoutFailedLoginsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type EventCreateeventImagesInput = {
    set: string[]
  }

  export type EventCreateeventTagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedEventsInput = {
    create?: XOR<UserCreateWithoutCreatedEventsInput, UserUncheckedCreateWithoutCreatedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedEventsInput = {
    create?: XOR<UserCreateWithoutUpdatedEventsInput, UserUncheckedCreateWithoutUpdatedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutEventsInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ReportCreateNestedOneWithoutEventsInput = {
    create?: XOR<ReportCreateWithoutEventsInput, ReportUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutEventsInput
    connect?: ReportWhereUniqueInput
  }

  export type EventUpdateeventImagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EventUpdateeventTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus
  }

  export type EnumAttendanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceType
  }

  export type UserUpdateOneRequiredWithoutCreatedEventsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedEventsInput, UserUncheckedCreateWithoutCreatedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEventsInput
    upsert?: UserUpsertWithoutCreatedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedEventsInput, UserUpdateWithoutCreatedEventsInput>, UserUncheckedUpdateWithoutCreatedEventsInput>
  }

  export type UserUpdateOneRequiredWithoutUpdatedEventsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedEventsInput, UserUncheckedCreateWithoutUpdatedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedEventsInput
    upsert?: UserUpsertWithoutUpdatedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedEventsInput, UserUpdateWithoutUpdatedEventsInput>, UserUncheckedUpdateWithoutUpdatedEventsInput>
  }

  export type ProjectUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEventsInput
    upsert?: ProjectUpsertWithoutEventsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEventsInput, ProjectUpdateWithoutEventsInput>, ProjectUncheckedUpdateWithoutEventsInput>
  }

  export type ReportUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ReportCreateWithoutEventsInput, ReportUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutEventsInput
    upsert?: ReportUpsertWithoutEventsInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutEventsInput, ReportUpdateWithoutEventsInput>, ReportUncheckedUpdateWithoutEventsInput>
  }

  export type InstitutionCreateinstitutionImagesInput = {
    set: string[]
  }

  export type LocationCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput> | LocationCreateWithoutInstitutionInput[] | LocationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutInstitutionInput | LocationCreateOrConnectWithoutInstitutionInput[]
    createMany?: LocationCreateManyInstitutionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput> | BeneficiaryCreateWithoutInstitutionInput[] | BeneficiaryUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutInstitutionInput | BeneficiaryCreateOrConnectWithoutInstitutionInput[]
    createMany?: BeneficiaryCreateManyInstitutionInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedInstitutionsInput = {
    create?: XOR<UserCreateWithoutCreatedInstitutionsInput, UserUncheckedCreateWithoutCreatedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInstitutionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedInstitutionsInput = {
    create?: XOR<UserCreateWithoutUpdatedInstitutionsInput, UserUncheckedCreateWithoutUpdatedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedInstitutionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedInstitutionsInput = {
    create?: XOR<UserCreateWithoutApprovedInstitutionsInput, UserUncheckedCreateWithoutApprovedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedInstitutionsInput
    connect?: UserWhereUniqueInput
  }

  export type LocationUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput> | LocationCreateWithoutInstitutionInput[] | LocationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutInstitutionInput | LocationCreateOrConnectWithoutInstitutionInput[]
    createMany?: LocationCreateManyInstitutionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput> | BeneficiaryCreateWithoutInstitutionInput[] | BeneficiaryUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutInstitutionInput | BeneficiaryCreateOrConnectWithoutInstitutionInput[]
    createMany?: BeneficiaryCreateManyInstitutionInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type InstitutionUpdateinstitutionImagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumInstitutionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InstitutionType
  }

  export type LocationUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput> | LocationCreateWithoutInstitutionInput[] | LocationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutInstitutionInput | LocationCreateOrConnectWithoutInstitutionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutInstitutionInput | LocationUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: LocationCreateManyInstitutionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutInstitutionInput | LocationUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutInstitutionInput | LocationUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type BeneficiaryUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput> | BeneficiaryCreateWithoutInstitutionInput[] | BeneficiaryUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutInstitutionInput | BeneficiaryCreateOrConnectWithoutInstitutionInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutInstitutionInput | BeneficiaryUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: BeneficiaryCreateManyInstitutionInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutInstitutionInput | BeneficiaryUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutInstitutionInput | BeneficiaryUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInstitutionsInput, UserUncheckedCreateWithoutCreatedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInstitutionsInput
    upsert?: UserUpsertWithoutCreatedInstitutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInstitutionsInput, UserUpdateWithoutCreatedInstitutionsInput>, UserUncheckedUpdateWithoutCreatedInstitutionsInput>
  }

  export type UserUpdateOneWithoutUpdatedInstitutionsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedInstitutionsInput, UserUncheckedCreateWithoutUpdatedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedInstitutionsInput
    upsert?: UserUpsertWithoutUpdatedInstitutionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedInstitutionsInput, UserUpdateWithoutUpdatedInstitutionsInput>, UserUncheckedUpdateWithoutUpdatedInstitutionsInput>
  }

  export type UserUpdateOneWithoutApprovedInstitutionsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedInstitutionsInput, UserUncheckedCreateWithoutApprovedInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedInstitutionsInput
    upsert?: UserUpsertWithoutApprovedInstitutionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedInstitutionsInput, UserUpdateWithoutApprovedInstitutionsInput>, UserUncheckedUpdateWithoutApprovedInstitutionsInput>
  }

  export type LocationUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput> | LocationCreateWithoutInstitutionInput[] | LocationUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutInstitutionInput | LocationCreateOrConnectWithoutInstitutionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutInstitutionInput | LocationUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: LocationCreateManyInstitutionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutInstitutionInput | LocationUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutInstitutionInput | LocationUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput> | BeneficiaryCreateWithoutInstitutionInput[] | BeneficiaryUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutInstitutionInput | BeneficiaryCreateOrConnectWithoutInstitutionInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutInstitutionInput | BeneficiaryUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: BeneficiaryCreateManyInstitutionInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutInstitutionInput | BeneficiaryUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutInstitutionInput | BeneficiaryUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type InstitutionCreateNestedOneWithoutLocationsInput = {
    create?: XOR<InstitutionCreateWithoutLocationsInput, InstitutionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutLocationsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InstitutionUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<InstitutionCreateWithoutLocationsInput, InstitutionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutLocationsInput
    upsert?: InstitutionUpsertWithoutLocationsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutLocationsInput, InstitutionUpdateWithoutLocationsInput>, InstitutionUncheckedUpdateWithoutLocationsInput>
  }

  export type BeneficiaryCreateimagesInput = {
    set: string[]
  }

  export type MessageCreateNestedManyWithoutBeneficiaryInput = {
    create?: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput> | MessageCreateWithoutBeneficiaryInput[] | MessageUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBeneficiaryInput | MessageCreateOrConnectWithoutBeneficiaryInput[]
    createMany?: MessageCreateManyBeneficiaryInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ResponseCreateNestedManyWithoutResponderBeneficiaryInput = {
    create?: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput> | ResponseCreateWithoutResponderBeneficiaryInput[] | ResponseUncheckedCreateWithoutResponderBeneficiaryInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderBeneficiaryInput | ResponseCreateOrConnectWithoutResponderBeneficiaryInput[]
    createMany?: ResponseCreateManyResponderBeneficiaryInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type InstitutionCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<InstitutionCreateWithoutBeneficiariesInput, InstitutionUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutBeneficiariesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedBeneficiariesInput = {
    create?: XOR<UserCreateWithoutCreatedBeneficiariesInput, UserUncheckedCreateWithoutCreatedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBeneficiariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedBeneficiariesInput = {
    create?: XOR<UserCreateWithoutUpdatedBeneficiariesInput, UserUncheckedCreateWithoutUpdatedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBeneficiariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedBeneficiariesInput = {
    create?: XOR<UserCreateWithoutApprovedBeneficiariesInput, UserUncheckedCreateWithoutApprovedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedBeneficiariesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutBeneficiaryInput = {
    create?: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput> | MessageCreateWithoutBeneficiaryInput[] | MessageUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBeneficiaryInput | MessageCreateOrConnectWithoutBeneficiaryInput[]
    createMany?: MessageCreateManyBeneficiaryInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput = {
    create?: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput> | ResponseCreateWithoutResponderBeneficiaryInput[] | ResponseUncheckedCreateWithoutResponderBeneficiaryInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderBeneficiaryInput | ResponseCreateOrConnectWithoutResponderBeneficiaryInput[]
    createMany?: ResponseCreateManyResponderBeneficiaryInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type BeneficiaryUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumGenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.GenderType
  }

  export type MessageUpdateManyWithoutBeneficiaryNestedInput = {
    create?: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput> | MessageCreateWithoutBeneficiaryInput[] | MessageUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBeneficiaryInput | MessageCreateOrConnectWithoutBeneficiaryInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBeneficiaryInput | MessageUpsertWithWhereUniqueWithoutBeneficiaryInput[]
    createMany?: MessageCreateManyBeneficiaryInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBeneficiaryInput | MessageUpdateWithWhereUniqueWithoutBeneficiaryInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBeneficiaryInput | MessageUpdateManyWithWhereWithoutBeneficiaryInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ResponseUpdateManyWithoutResponderBeneficiaryNestedInput = {
    create?: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput> | ResponseCreateWithoutResponderBeneficiaryInput[] | ResponseUncheckedCreateWithoutResponderBeneficiaryInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderBeneficiaryInput | ResponseCreateOrConnectWithoutResponderBeneficiaryInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutResponderBeneficiaryInput | ResponseUpsertWithWhereUniqueWithoutResponderBeneficiaryInput[]
    createMany?: ResponseCreateManyResponderBeneficiaryInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutResponderBeneficiaryInput | ResponseUpdateWithWhereUniqueWithoutResponderBeneficiaryInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutResponderBeneficiaryInput | ResponseUpdateManyWithWhereWithoutResponderBeneficiaryInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type InstitutionUpdateOneWithoutBeneficiariesNestedInput = {
    create?: XOR<InstitutionCreateWithoutBeneficiariesInput, InstitutionUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutBeneficiariesInput
    upsert?: InstitutionUpsertWithoutBeneficiariesInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutBeneficiariesInput, InstitutionUpdateWithoutBeneficiariesInput>, InstitutionUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBeneficiariesInput, UserUncheckedCreateWithoutCreatedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBeneficiariesInput
    upsert?: UserUpsertWithoutCreatedBeneficiariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBeneficiariesInput, UserUpdateWithoutCreatedBeneficiariesInput>, UserUncheckedUpdateWithoutCreatedBeneficiariesInput>
  }

  export type UserUpdateOneWithoutUpdatedBeneficiariesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedBeneficiariesInput, UserUncheckedCreateWithoutUpdatedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBeneficiariesInput
    upsert?: UserUpsertWithoutUpdatedBeneficiariesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedBeneficiariesInput, UserUpdateWithoutUpdatedBeneficiariesInput>, UserUncheckedUpdateWithoutUpdatedBeneficiariesInput>
  }

  export type UserUpdateOneWithoutApprovedBeneficiariesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedBeneficiariesInput, UserUncheckedCreateWithoutApprovedBeneficiariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedBeneficiariesInput
    upsert?: UserUpsertWithoutApprovedBeneficiariesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedBeneficiariesInput, UserUpdateWithoutApprovedBeneficiariesInput>, UserUncheckedUpdateWithoutApprovedBeneficiariesInput>
  }

  export type MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput = {
    create?: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput> | MessageCreateWithoutBeneficiaryInput[] | MessageUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBeneficiaryInput | MessageCreateOrConnectWithoutBeneficiaryInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBeneficiaryInput | MessageUpsertWithWhereUniqueWithoutBeneficiaryInput[]
    createMany?: MessageCreateManyBeneficiaryInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBeneficiaryInput | MessageUpdateWithWhereUniqueWithoutBeneficiaryInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBeneficiaryInput | MessageUpdateManyWithWhereWithoutBeneficiaryInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput = {
    create?: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput> | ResponseCreateWithoutResponderBeneficiaryInput[] | ResponseUncheckedCreateWithoutResponderBeneficiaryInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutResponderBeneficiaryInput | ResponseCreateOrConnectWithoutResponderBeneficiaryInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutResponderBeneficiaryInput | ResponseUpsertWithWhereUniqueWithoutResponderBeneficiaryInput[]
    createMany?: ResponseCreateManyResponderBeneficiaryInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutResponderBeneficiaryInput | ResponseUpdateWithWhereUniqueWithoutResponderBeneficiaryInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutResponderBeneficiaryInput | ResponseUpdateManyWithWhereWithoutResponderBeneficiaryInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutResponsesInput = {
    create?: XOR<MessageCreateWithoutResponsesInput, MessageUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutResponsesInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponsesInput = {
    create?: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type BeneficiaryCreateNestedOneWithoutResponsesInput = {
    create?: XOR<BeneficiaryCreateWithoutResponsesInput, BeneficiaryUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutResponsesInput
    connect?: BeneficiaryWhereUniqueInput
  }

  export type EnumResponderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResponderType
  }

  export type MessageUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<MessageCreateWithoutResponsesInput, MessageUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutResponsesInput
    upsert?: MessageUpsertWithoutResponsesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutResponsesInput, MessageUpdateWithoutResponsesInput>, MessageUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneWithoutResponsesNestedInput = {
    create?: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsesInput
    upsert?: UserUpsertWithoutResponsesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponsesInput, UserUpdateWithoutResponsesInput>, UserUncheckedUpdateWithoutResponsesInput>
  }

  export type BeneficiaryUpdateOneWithoutResponsesNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutResponsesInput, BeneficiaryUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutResponsesInput
    upsert?: BeneficiaryUpsertWithoutResponsesInput
    disconnect?: BeneficiaryWhereInput | boolean
    delete?: BeneficiaryWhereInput | boolean
    connect?: BeneficiaryWhereUniqueInput
    update?: XOR<XOR<BeneficiaryUpdateToOneWithWhereWithoutResponsesInput, BeneficiaryUpdateWithoutResponsesInput>, BeneficiaryUncheckedUpdateWithoutResponsesInput>
  }

  export type UserCreateNestedOneWithoutCreatedFaqsInput = {
    create?: XOR<UserCreateWithoutCreatedFaqsInput, UserUncheckedCreateWithoutCreatedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFaqsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedFaqsInput = {
    create?: XOR<UserCreateWithoutUpdatedFaqsInput, UserUncheckedCreateWithoutUpdatedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedFaqsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedFaqsInput = {
    create?: XOR<UserCreateWithoutApprovedFaqsInput, UserUncheckedCreateWithoutApprovedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFaqsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFAQCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FAQCategory
  }

  export type UserUpdateOneRequiredWithoutCreatedFaqsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFaqsInput, UserUncheckedCreateWithoutCreatedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFaqsInput
    upsert?: UserUpsertWithoutCreatedFaqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFaqsInput, UserUpdateWithoutCreatedFaqsInput>, UserUncheckedUpdateWithoutCreatedFaqsInput>
  }

  export type UserUpdateOneRequiredWithoutUpdatedFaqsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedFaqsInput, UserUncheckedCreateWithoutUpdatedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedFaqsInput
    upsert?: UserUpsertWithoutUpdatedFaqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedFaqsInput, UserUpdateWithoutUpdatedFaqsInput>, UserUncheckedUpdateWithoutUpdatedFaqsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovedFaqsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedFaqsInput, UserUncheckedCreateWithoutApprovedFaqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFaqsInput
    upsert?: UserUpsertWithoutApprovedFaqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedFaqsInput, UserUpdateWithoutApprovedFaqsInput>, UserUncheckedUpdateWithoutApprovedFaqsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMessageCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageCategory | EnumMessageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageCategoryFilter<$PrismaModel> | $Enums.MessageCategory
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumMessageCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageCategory | EnumMessageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageCategory[] | ListEnumMessageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MessageCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageCategoryFilter<$PrismaModel>
    _max?: NestedEnumMessageCategoryFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumLoginStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginStatus | EnumLoginStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginStatusFilter<$PrismaModel> | $Enums.LoginStatus
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLoginStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginStatus | EnumLoginStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginStatus[] | ListEnumLoginStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginStatusWithAggregatesFilter<$PrismaModel> | $Enums.LoginStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginStatusFilter<$PrismaModel>
    _max?: NestedEnumLoginStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type NestedEnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderType | EnumGenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderTypeFilter<$PrismaModel> | $Enums.GenderType
  }

  export type NestedEnumGenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderType | EnumGenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenderType[] | ListEnumGenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.GenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderTypeFilter<$PrismaModel>
    _max?: NestedEnumGenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumResponderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponderType | EnumResponderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResponderTypeFilter<$PrismaModel> | $Enums.ResponderType
  }

  export type NestedEnumResponderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResponderType | EnumResponderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResponderType[] | ListEnumResponderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResponderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResponderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResponderTypeFilter<$PrismaModel>
    _max?: NestedEnumResponderTypeFilter<$PrismaModel>
  }

  export type NestedEnumFAQCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FAQCategory | EnumFAQCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFAQCategoryFilter<$PrismaModel> | $Enums.FAQCategory
  }

  export type NestedEnumFAQCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FAQCategory | EnumFAQCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FAQCategory[] | ListEnumFAQCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFAQCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FAQCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFAQCategoryFilter<$PrismaModel>
    _max?: NestedEnumFAQCategoryFilter<$PrismaModel>
  }

  export type UserCreateWithoutApprovedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedProjectsInput, UserUncheckedCreateWithoutApprovedProjectsInput>
  }

  export type UserCreateWithoutCreatedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
  }

  export type UserCreateWithoutUpdatedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedProjectsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedProjectsInput, UserUncheckedCreateWithoutUpdatedProjectsInput>
  }

  export type ReportCreateWithoutProjectInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedReportsInput
    createdBy: UserCreateNestedOneWithoutCreatedReportsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedReportsInput
    events?: EventCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    events?: EventUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutProjectInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput>
  }

  export type ReportCreateManyProjectInputEnvelope = {
    data: ReportCreateManyProjectInput | ReportCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutProjectInput = {
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedEventsInput
    updatedBy: UserCreateNestedOneWithoutUpdatedEventsInput
    report?: ReportCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutProjectInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    reportId?: number | null
  }

  export type EventCreateOrConnectWithoutProjectInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
  }

  export type EventCreateManyProjectInputEnvelope = {
    data: EventCreateManyProjectInput | EventCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApprovedProjectsInput = {
    update: XOR<UserUpdateWithoutApprovedProjectsInput, UserUncheckedUpdateWithoutApprovedProjectsInput>
    create: XOR<UserCreateWithoutApprovedProjectsInput, UserUncheckedCreateWithoutApprovedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedProjectsInput, UserUncheckedUpdateWithoutApprovedProjectsInput>
  }

  export type UserUpdateWithoutApprovedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutCreatedProjectsInput = {
    update: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedProjectsInput = {
    update: XOR<UserUpdateWithoutUpdatedProjectsInput, UserUncheckedUpdateWithoutUpdatedProjectsInput>
    create: XOR<UserCreateWithoutUpdatedProjectsInput, UserUncheckedCreateWithoutUpdatedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedProjectsInput, UserUncheckedUpdateWithoutUpdatedProjectsInput>
  }

  export type UserUpdateWithoutUpdatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutProjectInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutProjectInput, ReportUncheckedUpdateWithoutProjectInput>
    create: XOR<ReportCreateWithoutProjectInput, ReportUncheckedCreateWithoutProjectInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutProjectInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutProjectInput, ReportUncheckedUpdateWithoutProjectInput>
  }

  export type ReportUpdateManyWithWhereWithoutProjectInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutProjectInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    title?: StringFilter<"Report"> | string
    slug?: StringFilter<"Report"> | string
    images?: StringNullableListFilter<"Report">
    files?: StringNullableListFilter<"Report">
    publishStatus?: EnumPublishStatusFilter<"Report"> | $Enums.PublishStatus
    accessCount?: IntFilter<"Report"> | number
    downloadCount?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    createdById?: StringFilter<"Report"> | string
    updatedById?: StringNullableFilter<"Report"> | string | null
    approvedById?: StringNullableFilter<"Report"> | string | null
    projectId?: IntNullableFilter<"Report"> | number | null
  }

  export type EventUpsertWithWhereUniqueWithoutProjectInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutProjectInput, EventUncheckedUpdateWithoutProjectInput>
    create: XOR<EventCreateWithoutProjectInput, EventUncheckedCreateWithoutProjectInput>
  }

  export type EventUpdateWithWhereUniqueWithoutProjectInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutProjectInput, EventUncheckedUpdateWithoutProjectInput>
  }

  export type EventUpdateManyWithWhereWithoutProjectInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutProjectInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: IntFilter<"Event"> | number
    slug?: StringFilter<"Event"> | string
    eventTitle?: StringFilter<"Event"> | string
    eventDescription?: JsonFilter<"Event">
    eventDetails?: JsonNullableFilter<"Event">
    eventLocation?: StringNullableFilter<"Event"> | string | null
    eventBanner?: StringFilter<"Event"> | string
    eventImages?: StringNullableListFilter<"Event">
    eventFile?: StringFilter<"Event"> | string
    eventStartDate?: DateTimeFilter<"Event"> | Date | string
    eventEndDate?: DateTimeFilter<"Event"> | Date | string
    eventTags?: StringNullableListFilter<"Event">
    eventStatus?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFilter<"Event"> | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFilter<"Event"> | $Enums.AttendanceType
    maxAttendees?: IntNullableFilter<"Event"> | number | null
    accessCount?: IntFilter<"Event"> | number
    downloadCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    createdById?: StringFilter<"Event"> | string
    updatedById?: StringFilter<"Event"> | string
    projectId?: IntNullableFilter<"Event"> | number | null
    reportId?: IntNullableFilter<"Event"> | number | null
  }

  export type UserCreateWithoutCreatedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedMessagesInput, UserUncheckedCreateWithoutCreatedMessagesInput>
  }

  export type UserCreateWithoutUpdatedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedMessagesInput, UserUncheckedCreateWithoutUpdatedMessagesInput>
  }

  export type UserCreateWithoutApprovedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovedMessagesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedMessagesInput, UserUncheckedCreateWithoutApprovedMessagesInput>
  }

  export type BeneficiaryCreateWithoutMessagesInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutMessagesInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutMessagesInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutMessagesInput, BeneficiaryUncheckedCreateWithoutMessagesInput>
  }

  export type ResponseCreateWithoutMessageInput = {
    id?: string
    responderType?: $Enums.ResponderType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    responderUser?: UserCreateNestedOneWithoutResponsesInput
    responderBeneficiary?: BeneficiaryCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutMessageInput = {
    id?: string
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseCreateOrConnectWithoutMessageInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput>
  }

  export type ResponseCreateManyMessageInputEnvelope = {
    data: ResponseCreateManyMessageInput | ResponseCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedMessagesInput = {
    update: XOR<UserUpdateWithoutCreatedMessagesInput, UserUncheckedUpdateWithoutCreatedMessagesInput>
    create: XOR<UserCreateWithoutCreatedMessagesInput, UserUncheckedCreateWithoutCreatedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedMessagesInput, UserUncheckedUpdateWithoutCreatedMessagesInput>
  }

  export type UserUpdateWithoutCreatedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedMessagesInput = {
    update: XOR<UserUpdateWithoutUpdatedMessagesInput, UserUncheckedUpdateWithoutUpdatedMessagesInput>
    create: XOR<UserCreateWithoutUpdatedMessagesInput, UserUncheckedCreateWithoutUpdatedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedMessagesInput, UserUncheckedUpdateWithoutUpdatedMessagesInput>
  }

  export type UserUpdateWithoutUpdatedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutApprovedMessagesInput = {
    update: XOR<UserUpdateWithoutApprovedMessagesInput, UserUncheckedUpdateWithoutApprovedMessagesInput>
    create: XOR<UserCreateWithoutApprovedMessagesInput, UserUncheckedCreateWithoutApprovedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedMessagesInput, UserUncheckedUpdateWithoutApprovedMessagesInput>
  }

  export type UserUpdateWithoutApprovedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type BeneficiaryUpsertWithoutMessagesInput = {
    update: XOR<BeneficiaryUpdateWithoutMessagesInput, BeneficiaryUncheckedUpdateWithoutMessagesInput>
    create: XOR<BeneficiaryCreateWithoutMessagesInput, BeneficiaryUncheckedCreateWithoutMessagesInput>
    where?: BeneficiaryWhereInput
  }

  export type BeneficiaryUpdateToOneWithWhereWithoutMessagesInput = {
    where?: BeneficiaryWhereInput
    data: XOR<BeneficiaryUpdateWithoutMessagesInput, BeneficiaryUncheckedUpdateWithoutMessagesInput>
  }

  export type BeneficiaryUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type ResponseUpsertWithWhereUniqueWithoutMessageInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutMessageInput, ResponseUncheckedUpdateWithoutMessageInput>
    create: XOR<ResponseCreateWithoutMessageInput, ResponseUncheckedCreateWithoutMessageInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutMessageInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutMessageInput, ResponseUncheckedUpdateWithoutMessageInput>
  }

  export type ResponseUpdateManyWithWhereWithoutMessageInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutMessageInput>
  }

  export type ResponseScalarWhereInput = {
    AND?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    OR?: ResponseScalarWhereInput[]
    NOT?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    id?: StringFilter<"Response"> | string
    messageId?: IntFilter<"Response"> | number
    responderType?: EnumResponderTypeFilter<"Response"> | $Enums.ResponderType
    responderUserId?: StringNullableFilter<"Response"> | string | null
    responderBeneficiaryId?: StringNullableFilter<"Response"> | string | null
    content?: JsonFilter<"Response">
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
  }

  export type UserCreateWithoutApprovedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedReportsInput, UserUncheckedCreateWithoutApprovedReportsInput>
  }

  export type UserCreateWithoutCreatedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
  }

  export type ProjectCreateWithoutReportsInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedProjectsInput
    createdBy: UserCreateNestedOneWithoutCreatedProjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedProjectsInput
    events?: EventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutReportsInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    events?: EventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutReportsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutReportsInput, ProjectUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutUpdatedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedReportsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedReportsInput, UserUncheckedCreateWithoutUpdatedReportsInput>
  }

  export type EventCreateWithoutReportInput = {
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedEventsInput
    updatedBy: UserCreateNestedOneWithoutUpdatedEventsInput
    project?: ProjectCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutReportInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    projectId?: number | null
  }

  export type EventCreateOrConnectWithoutReportInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput>
  }

  export type EventCreateManyReportInputEnvelope = {
    data: EventCreateManyReportInput | EventCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApprovedReportsInput = {
    update: XOR<UserUpdateWithoutApprovedReportsInput, UserUncheckedUpdateWithoutApprovedReportsInput>
    create: XOR<UserCreateWithoutApprovedReportsInput, UserUncheckedCreateWithoutApprovedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedReportsInput, UserUncheckedUpdateWithoutApprovedReportsInput>
  }

  export type UserUpdateWithoutApprovedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutCreatedReportsInput = {
    update: XOR<UserUpdateWithoutCreatedReportsInput, UserUncheckedUpdateWithoutCreatedReportsInput>
    create: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedReportsInput, UserUncheckedUpdateWithoutCreatedReportsInput>
  }

  export type UserUpdateWithoutCreatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ProjectUpsertWithoutReportsInput = {
    update: XOR<ProjectUpdateWithoutReportsInput, ProjectUncheckedUpdateWithoutReportsInput>
    create: XOR<ProjectCreateWithoutReportsInput, ProjectUncheckedCreateWithoutReportsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutReportsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutReportsInput, ProjectUncheckedUpdateWithoutReportsInput>
  }

  export type ProjectUpdateWithoutReportsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedProjectsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedProjectsNestedInput
    events?: EventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutUpdatedReportsInput = {
    update: XOR<UserUpdateWithoutUpdatedReportsInput, UserUncheckedUpdateWithoutUpdatedReportsInput>
    create: XOR<UserCreateWithoutUpdatedReportsInput, UserUncheckedCreateWithoutUpdatedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedReportsInput, UserUncheckedUpdateWithoutUpdatedReportsInput>
  }

  export type UserUpdateWithoutUpdatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutReportInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutReportInput, EventUncheckedUpdateWithoutReportInput>
    create: XOR<EventCreateWithoutReportInput, EventUncheckedCreateWithoutReportInput>
  }

  export type EventUpdateWithWhereUniqueWithoutReportInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutReportInput, EventUncheckedUpdateWithoutReportInput>
  }

  export type EventUpdateManyWithWhereWithoutReportInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutReportInput>
  }

  export type PasswordHistoryCreateWithoutUserInput = {
    id?: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type PasswordHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type PasswordHistoryCreateOrConnectWithoutUserInput = {
    where: PasswordHistoryWhereUniqueInput
    create: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput>
  }

  export type PasswordHistoryCreateManyUserInputEnvelope = {
    data: PasswordHistoryCreateManyUserInput | PasswordHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordChangeLogCreateWithoutUserInput = {
    id?: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordChangeLogUncheckedCreateWithoutUserInput = {
    id?: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordChangeLogCreateOrConnectWithoutUserInput = {
    where: PasswordChangeLogWhereUniqueInput
    create: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput>
  }

  export type PasswordChangeLogCreateManyUserInputEnvelope = {
    data: PasswordChangeLogCreateManyUserInput | PasswordChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FailedLoginAttemptCreateWithoutUserInput = {
    id?: string
    ip?: string | null
    createdAt?: Date | string
  }

  export type FailedLoginAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    ip?: string | null
    createdAt?: Date | string
  }

  export type FailedLoginAttemptCreateOrConnectWithoutUserInput = {
    where: FailedLoginAttemptWhereUniqueInput
    create: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput>
  }

  export type FailedLoginAttemptCreateManyUserInputEnvelope = {
    data: FailedLoginAttemptCreateManyUserInput | FailedLoginAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutApproverInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedMessagesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMessagesInput
    beneficiary?: BeneficiaryCreateNestedOneWithoutMessagesInput
    responses?: ResponseCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutApproverInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    beneficiaryId?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutApproverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput>
  }

  export type MessageCreateManyApproverInputEnvelope = {
    data: MessageCreateManyApproverInput | MessageCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutCreatedByInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutUpdatedMessagesInput
    approver?: UserCreateNestedOneWithoutApprovedMessagesInput
    beneficiary?: BeneficiaryCreateNestedOneWithoutMessagesInput
    responses?: ResponseCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput>
  }

  export type MessageCreateManyCreatedByInputEnvelope = {
    data: MessageCreateManyCreatedByInput | MessageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUpdatedByInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedMessagesInput
    approver?: UserCreateNestedOneWithoutApprovedMessagesInput
    beneficiary?: BeneficiaryCreateNestedOneWithoutMessagesInput
    responses?: ResponseCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutUpdatedByInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput>
  }

  export type MessageCreateManyUpdatedByInputEnvelope = {
    data: MessageCreateManyUpdatedByInput | MessageCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type ResponseCreateWithoutResponderUserInput = {
    id?: string
    responderType?: $Enums.ResponderType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutResponsesInput
    responderBeneficiary?: BeneficiaryCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutResponderUserInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseCreateOrConnectWithoutResponderUserInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput>
  }

  export type ResponseCreateManyResponderUserInputEnvelope = {
    data: ResponseCreateManyResponderUserInput | ResponseCreateManyResponderUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutApprovedByInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedProjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedProjectsInput
    reports?: ReportCreateNestedManyWithoutProjectInput
    events?: EventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApprovedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutProjectInput
    events?: EventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApprovedByInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput>
  }

  export type ProjectCreateManyApprovedByInputEnvelope = {
    data: ProjectCreateManyApprovedByInput | ProjectCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCreatedByInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedProjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedProjectsInput
    reports?: ReportCreateNestedManyWithoutProjectInput
    events?: EventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutProjectInput
    events?: EventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
  }

  export type ProjectCreateManyCreatedByInputEnvelope = {
    data: ProjectCreateManyCreatedByInput | ProjectCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUpdatedByInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedProjectsInput
    createdBy: UserCreateNestedOneWithoutCreatedProjectsInput
    reports?: ReportCreateNestedManyWithoutProjectInput
    events?: EventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutProjectInput
    events?: EventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUpdatedByInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput>
  }

  export type ProjectCreateManyUpdatedByInputEnvelope = {
    data: ProjectCreateManyUpdatedByInput | ProjectCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutApprovedByInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedReportsInput
    project?: ProjectCreateNestedOneWithoutReportsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedReportsInput
    events?: EventCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutApprovedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    projectId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutApprovedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput>
  }

  export type ReportCreateManyApprovedByInputEnvelope = {
    data: ReportCreateManyApprovedByInput | ReportCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCreatedByInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedReportsInput
    project?: ProjectCreateNestedOneWithoutReportsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedReportsInput
    events?: EventCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    projectId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportCreateManyCreatedByInputEnvelope = {
    data: ReportCreateManyCreatedByInput | ReportCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutUpdatedByInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedReportsInput
    createdBy: UserCreateNestedOneWithoutCreatedReportsInput
    project?: ProjectCreateNestedOneWithoutReportsInput
    events?: EventCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
    projectId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutUpdatedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput>
  }

  export type ReportCreateManyUpdatedByInputEnvelope = {
    data: ReportCreateManyUpdatedByInput | ReportCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatedByInput = {
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    updatedBy: UserCreateNestedOneWithoutUpdatedEventsInput
    project?: ProjectCreateNestedOneWithoutEventsInput
    report?: ReportCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutCreatedByInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    updatedById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type EventCreateOrConnectWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventCreateManyCreatedByInputEnvelope = {
    data: EventCreateManyCreatedByInput | EventCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutUpdatedByInput = {
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedEventsInput
    project?: ProjectCreateNestedOneWithoutEventsInput
    report?: ReportCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type EventCreateOrConnectWithoutUpdatedByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput>
  }

  export type EventCreateManyUpdatedByInputEnvelope = {
    data: EventCreateManyUpdatedByInput | EventCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutCreatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutCreatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    updatedById?: string | null
    approvedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutCreatedByInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput>
  }

  export type BeneficiaryCreateManyCreatedByInputEnvelope = {
    data: BeneficiaryCreateManyCreatedByInput | BeneficiaryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutUpdatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    approvedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutUpdatedByInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput>
  }

  export type BeneficiaryCreateManyUpdatedByInputEnvelope = {
    data: BeneficiaryCreateManyUpdatedByInput | BeneficiaryCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutApprovedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutApprovedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutApprovedByInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput>
  }

  export type BeneficiaryCreateManyApprovedByInputEnvelope = {
    data: BeneficiaryCreateManyApprovedByInput | BeneficiaryCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutInstitutionInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedInstitutionsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedInstitutionsInput
  }

  export type InstitutionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutCreatedByInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput>
  }

  export type InstitutionCreateManyCreatedByInputEnvelope = {
    data: InstitutionCreateManyCreatedByInput | InstitutionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutInstitutionInput
    createdBy: UserCreateNestedOneWithoutCreatedInstitutionsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedInstitutionsInput
  }

  export type InstitutionUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutUpdatedByInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput>
  }

  export type InstitutionCreateManyUpdatedByInputEnvelope = {
    data: InstitutionCreateManyUpdatedByInput | InstitutionCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionCreateWithoutApprovedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutInstitutionInput
    createdBy: UserCreateNestedOneWithoutCreatedInstitutionsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedInstitutionsInput
  }

  export type InstitutionUncheckedCreateWithoutApprovedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutInstitutionInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutApprovedByInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput>
  }

  export type InstitutionCreateManyApprovedByInputEnvelope = {
    data: InstitutionCreateManyApprovedByInput | InstitutionCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type FAQCreateWithoutCreatedByInput = {
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: UserCreateNestedOneWithoutUpdatedFaqsInput
    approvedBy: UserCreateNestedOneWithoutApprovedFaqsInput
  }

  export type FAQUncheckedCreateWithoutCreatedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    approvedById: string
  }

  export type FAQCreateOrConnectWithoutCreatedByInput = {
    where: FAQWhereUniqueInput
    create: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput>
  }

  export type FAQCreateManyCreatedByInputEnvelope = {
    data: FAQCreateManyCreatedByInput | FAQCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type FAQCreateWithoutUpdatedByInput = {
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedFaqsInput
    approvedBy: UserCreateNestedOneWithoutApprovedFaqsInput
  }

  export type FAQUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById: string
  }

  export type FAQCreateOrConnectWithoutUpdatedByInput = {
    where: FAQWhereUniqueInput
    create: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput>
  }

  export type FAQCreateManyUpdatedByInputEnvelope = {
    data: FAQCreateManyUpdatedByInput | FAQCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type FAQCreateWithoutApprovedByInput = {
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedFaqsInput
    updatedBy: UserCreateNestedOneWithoutUpdatedFaqsInput
  }

  export type FAQUncheckedCreateWithoutApprovedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
  }

  export type FAQCreateOrConnectWithoutApprovedByInput = {
    where: FAQWhereUniqueInput
    create: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput>
  }

  export type FAQCreateManyApprovedByInputEnvelope = {
    data: FAQCreateManyApprovedByInput | FAQCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordHistoryWhereUniqueInput
    update: XOR<PasswordHistoryUpdateWithoutUserInput, PasswordHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordHistoryCreateWithoutUserInput, PasswordHistoryUncheckedCreateWithoutUserInput>
  }

  export type PasswordHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordHistoryWhereUniqueInput
    data: XOR<PasswordHistoryUpdateWithoutUserInput, PasswordHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PasswordHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PasswordHistoryScalarWhereInput
    data: XOR<PasswordHistoryUpdateManyMutationInput, PasswordHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordHistoryScalarWhereInput = {
    AND?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    OR?: PasswordHistoryScalarWhereInput[]
    NOT?: PasswordHistoryScalarWhereInput | PasswordHistoryScalarWhereInput[]
    id?: StringFilter<"PasswordHistory"> | string
    userId?: StringFilter<"PasswordHistory"> | string
    passwordHash?: StringFilter<"PasswordHistory"> | string
    createdAt?: DateTimeFilter<"PasswordHistory"> | Date | string
  }

  export type PasswordChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordChangeLogWhereUniqueInput
    update: XOR<PasswordChangeLogUpdateWithoutUserInput, PasswordChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordChangeLogCreateWithoutUserInput, PasswordChangeLogUncheckedCreateWithoutUserInput>
  }

  export type PasswordChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordChangeLogWhereUniqueInput
    data: XOR<PasswordChangeLogUpdateWithoutUserInput, PasswordChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type PasswordChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: PasswordChangeLogScalarWhereInput
    data: XOR<PasswordChangeLogUpdateManyMutationInput, PasswordChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordChangeLogScalarWhereInput = {
    AND?: PasswordChangeLogScalarWhereInput | PasswordChangeLogScalarWhereInput[]
    OR?: PasswordChangeLogScalarWhereInput[]
    NOT?: PasswordChangeLogScalarWhereInput | PasswordChangeLogScalarWhereInput[]
    id?: StringFilter<"PasswordChangeLog"> | string
    userId?: StringFilter<"PasswordChangeLog"> | string
    changedBy?: StringNullableFilter<"PasswordChangeLog"> | string | null
    ip?: StringNullableFilter<"PasswordChangeLog"> | string | null
    userAgent?: StringNullableFilter<"PasswordChangeLog"> | string | null
    createdAt?: DateTimeFilter<"PasswordChangeLog"> | Date | string
  }

  export type FailedLoginAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: FailedLoginAttemptWhereUniqueInput
    update: XOR<FailedLoginAttemptUpdateWithoutUserInput, FailedLoginAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<FailedLoginAttemptCreateWithoutUserInput, FailedLoginAttemptUncheckedCreateWithoutUserInput>
  }

  export type FailedLoginAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: FailedLoginAttemptWhereUniqueInput
    data: XOR<FailedLoginAttemptUpdateWithoutUserInput, FailedLoginAttemptUncheckedUpdateWithoutUserInput>
  }

  export type FailedLoginAttemptUpdateManyWithWhereWithoutUserInput = {
    where: FailedLoginAttemptScalarWhereInput
    data: XOR<FailedLoginAttemptUpdateManyMutationInput, FailedLoginAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type FailedLoginAttemptScalarWhereInput = {
    AND?: FailedLoginAttemptScalarWhereInput | FailedLoginAttemptScalarWhereInput[]
    OR?: FailedLoginAttemptScalarWhereInput[]
    NOT?: FailedLoginAttemptScalarWhereInput | FailedLoginAttemptScalarWhereInput[]
    id?: StringFilter<"FailedLoginAttempt"> | string
    userId?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    ip?: StringNullableFilter<"FailedLoginAttempt"> | string | null
    createdAt?: DateTimeFilter<"FailedLoginAttempt"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    startedAt?: DateTimeFilter<"Session"> | Date | string
    lastSeenAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutApproverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutApproverInput, MessageUncheckedUpdateWithoutApproverInput>
    create: XOR<MessageCreateWithoutApproverInput, MessageUncheckedCreateWithoutApproverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutApproverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutApproverInput, MessageUncheckedUpdateWithoutApproverInput>
  }

  export type MessageUpdateManyWithWhereWithoutApproverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutApproverInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    title?: StringNullableFilter<"Message"> | string | null
    affiliated?: StringNullableFilter<"Message"> | string | null
    name?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    nameImageUrl?: StringNullableFilter<"Message"> | string | null
    messageImageUrl?: StringNullableFilter<"Message"> | string | null
    messageStatus?: EnumPublishStatusFilter<"Message"> | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFilter<"Message"> | $Enums.MessageCategory
    senderEmail?: StringNullableFilter<"Message"> | string | null
    senderIp?: StringNullableFilter<"Message"> | string | null
    allowResponses?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    createdById?: StringNullableFilter<"Message"> | string | null
    updatedById?: StringNullableFilter<"Message"> | string | null
    approvedById?: StringNullableFilter<"Message"> | string | null
    beneficiaryId?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCreatedByInput, MessageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCreatedByInput, MessageUncheckedUpdateWithoutCreatedByInput>
  }

  export type MessageUpdateManyWithWhereWithoutCreatedByInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUpdatedByInput, MessageUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<MessageCreateWithoutUpdatedByInput, MessageUncheckedCreateWithoutUpdatedByInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUpdatedByInput, MessageUncheckedUpdateWithoutUpdatedByInput>
  }

  export type MessageUpdateManyWithWhereWithoutUpdatedByInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type ResponseUpsertWithWhereUniqueWithoutResponderUserInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutResponderUserInput, ResponseUncheckedUpdateWithoutResponderUserInput>
    create: XOR<ResponseCreateWithoutResponderUserInput, ResponseUncheckedCreateWithoutResponderUserInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutResponderUserInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutResponderUserInput, ResponseUncheckedUpdateWithoutResponderUserInput>
  }

  export type ResponseUpdateManyWithWhereWithoutResponderUserInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutResponderUserInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutApprovedByInput, ProjectUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ProjectCreateWithoutApprovedByInput, ProjectUncheckedCreateWithoutApprovedByInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutApprovedByInput, ProjectUncheckedUpdateWithoutApprovedByInput>
  }

  export type ProjectUpdateManyWithWhereWithoutApprovedByInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    content?: JsonFilter<"Project">
    images?: StringNullableListFilter<"Project">
    projectStatus?: EnumStatusFilter<"Project"> | $Enums.Status
    publishStatus?: EnumPublishStatusFilter<"Project"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdById?: StringFilter<"Project"> | string
    updatedById?: StringNullableFilter<"Project"> | string | null
    approvedById?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUpdatedByInput, ProjectUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<ProjectCreateWithoutUpdatedByInput, ProjectUncheckedCreateWithoutUpdatedByInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUpdatedByInput, ProjectUncheckedUpdateWithoutUpdatedByInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUpdatedByInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutApprovedByInput, ReportUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ReportCreateWithoutApprovedByInput, ReportUncheckedCreateWithoutApprovedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutApprovedByInput, ReportUncheckedUpdateWithoutApprovedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutApprovedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReportCreateWithoutCreatedByInput, ReportUncheckedCreateWithoutCreatedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCreatedByInput, ReportUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUpdatedByInput, ReportUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<ReportCreateWithoutUpdatedByInput, ReportUncheckedCreateWithoutUpdatedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUpdatedByInput, ReportUncheckedUpdateWithoutUpdatedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutUpdatedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type EventUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatedByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EventUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUpdatedByInput, EventUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<EventCreateWithoutUpdatedByInput, EventUncheckedCreateWithoutUpdatedByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUpdatedByInput, EventUncheckedUpdateWithoutUpdatedByInput>
  }

  export type EventUpdateManyWithWhereWithoutUpdatedByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutCreatedByInput, BeneficiaryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BeneficiaryCreateWithoutCreatedByInput, BeneficiaryUncheckedCreateWithoutCreatedByInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutCreatedByInput, BeneficiaryUncheckedUpdateWithoutCreatedByInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutCreatedByInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BeneficiaryScalarWhereInput = {
    AND?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
    OR?: BeneficiaryScalarWhereInput[]
    NOT?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
    id?: StringFilter<"Beneficiary"> | string
    firstName?: StringFilter<"Beneficiary"> | string
    lastName?: StringFilter<"Beneficiary"> | string
    image?: StringNullableFilter<"Beneficiary"> | string | null
    images?: StringNullableListFilter<"Beneficiary">
    gender?: EnumGenderTypeFilter<"Beneficiary"> | $Enums.GenderType
    email?: StringNullableFilter<"Beneficiary"> | string | null
    phone?: StringNullableFilter<"Beneficiary"> | string | null
    dateOfBirth?: DateTimeFilter<"Beneficiary"> | Date | string
    createdAt?: DateTimeFilter<"Beneficiary"> | Date | string
    updatedAt?: DateTimeFilter<"Beneficiary"> | Date | string
    beneficiaryStatus?: EnumPublishStatusFilter<"Beneficiary"> | $Enums.PublishStatus
    institutionId?: StringNullableFilter<"Beneficiary"> | string | null
    createdById?: StringFilter<"Beneficiary"> | string
    updatedById?: StringNullableFilter<"Beneficiary"> | string | null
    approvedById?: StringNullableFilter<"Beneficiary"> | string | null
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutUpdatedByInput, BeneficiaryUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<BeneficiaryCreateWithoutUpdatedByInput, BeneficiaryUncheckedCreateWithoutUpdatedByInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutUpdatedByInput, BeneficiaryUncheckedUpdateWithoutUpdatedByInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutUpdatedByInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutApprovedByInput, BeneficiaryUncheckedUpdateWithoutApprovedByInput>
    create: XOR<BeneficiaryCreateWithoutApprovedByInput, BeneficiaryUncheckedCreateWithoutApprovedByInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutApprovedByInput, BeneficiaryUncheckedUpdateWithoutApprovedByInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutApprovedByInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type InstitutionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InstitutionWhereUniqueInput
    update: XOR<InstitutionUpdateWithoutCreatedByInput, InstitutionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InstitutionCreateWithoutCreatedByInput, InstitutionUncheckedCreateWithoutCreatedByInput>
  }

  export type InstitutionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InstitutionWhereUniqueInput
    data: XOR<InstitutionUpdateWithoutCreatedByInput, InstitutionUncheckedUpdateWithoutCreatedByInput>
  }

  export type InstitutionUpdateManyWithWhereWithoutCreatedByInput = {
    where: InstitutionScalarWhereInput
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InstitutionScalarWhereInput = {
    AND?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    OR?: InstitutionScalarWhereInput[]
    NOT?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    email?: StringNullableFilter<"Institution"> | string | null
    phone?: StringNullableFilter<"Institution"> | string | null
    logo?: StringNullableFilter<"Institution"> | string | null
    institutionImages?: StringNullableListFilter<"Institution">
    headName?: StringNullableFilter<"Institution"> | string | null
    institutionType?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    updatedAt?: DateTimeFilter<"Institution"> | Date | string
    createdById?: StringFilter<"Institution"> | string
    updatedById?: StringNullableFilter<"Institution"> | string | null
    approvedById?: StringNullableFilter<"Institution"> | string | null
  }

  export type InstitutionUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: InstitutionWhereUniqueInput
    update: XOR<InstitutionUpdateWithoutUpdatedByInput, InstitutionUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<InstitutionCreateWithoutUpdatedByInput, InstitutionUncheckedCreateWithoutUpdatedByInput>
  }

  export type InstitutionUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: InstitutionWhereUniqueInput
    data: XOR<InstitutionUpdateWithoutUpdatedByInput, InstitutionUncheckedUpdateWithoutUpdatedByInput>
  }

  export type InstitutionUpdateManyWithWhereWithoutUpdatedByInput = {
    where: InstitutionScalarWhereInput
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type InstitutionUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: InstitutionWhereUniqueInput
    update: XOR<InstitutionUpdateWithoutApprovedByInput, InstitutionUncheckedUpdateWithoutApprovedByInput>
    create: XOR<InstitutionCreateWithoutApprovedByInput, InstitutionUncheckedCreateWithoutApprovedByInput>
  }

  export type InstitutionUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: InstitutionWhereUniqueInput
    data: XOR<InstitutionUpdateWithoutApprovedByInput, InstitutionUncheckedUpdateWithoutApprovedByInput>
  }

  export type InstitutionUpdateManyWithWhereWithoutApprovedByInput = {
    where: InstitutionScalarWhereInput
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type FAQUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: FAQWhereUniqueInput
    update: XOR<FAQUpdateWithoutCreatedByInput, FAQUncheckedUpdateWithoutCreatedByInput>
    create: XOR<FAQCreateWithoutCreatedByInput, FAQUncheckedCreateWithoutCreatedByInput>
  }

  export type FAQUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: FAQWhereUniqueInput
    data: XOR<FAQUpdateWithoutCreatedByInput, FAQUncheckedUpdateWithoutCreatedByInput>
  }

  export type FAQUpdateManyWithWhereWithoutCreatedByInput = {
    where: FAQScalarWhereInput
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type FAQScalarWhereInput = {
    AND?: FAQScalarWhereInput | FAQScalarWhereInput[]
    OR?: FAQScalarWhereInput[]
    NOT?: FAQScalarWhereInput | FAQScalarWhereInput[]
    id?: IntFilter<"FAQ"> | number
    question?: JsonFilter<"FAQ">
    answer?: JsonFilter<"FAQ">
    category?: EnumFAQCategoryFilter<"FAQ"> | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFilter<"FAQ"> | $Enums.PublishStatus
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
    createdById?: StringFilter<"FAQ"> | string
    updatedById?: StringFilter<"FAQ"> | string
    approvedById?: StringFilter<"FAQ"> | string
  }

  export type FAQUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: FAQWhereUniqueInput
    update: XOR<FAQUpdateWithoutUpdatedByInput, FAQUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<FAQCreateWithoutUpdatedByInput, FAQUncheckedCreateWithoutUpdatedByInput>
  }

  export type FAQUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: FAQWhereUniqueInput
    data: XOR<FAQUpdateWithoutUpdatedByInput, FAQUncheckedUpdateWithoutUpdatedByInput>
  }

  export type FAQUpdateManyWithWhereWithoutUpdatedByInput = {
    where: FAQScalarWhereInput
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type FAQUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: FAQWhereUniqueInput
    update: XOR<FAQUpdateWithoutApprovedByInput, FAQUncheckedUpdateWithoutApprovedByInput>
    create: XOR<FAQCreateWithoutApprovedByInput, FAQUncheckedCreateWithoutApprovedByInput>
  }

  export type FAQUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: FAQWhereUniqueInput
    data: XOR<FAQUpdateWithoutApprovedByInput, FAQUncheckedUpdateWithoutApprovedByInput>
  }

  export type FAQUpdateManyWithWhereWithoutApprovedByInput = {
    where: FAQScalarWhereInput
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type UserCreateWithoutPasswordHistoryInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutPasswordHistoryInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutPasswordHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
  }

  export type UserUpsertWithoutPasswordHistoryInput = {
    update: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
    create: XOR<UserCreateWithoutPasswordHistoryInput, UserUncheckedCreateWithoutPasswordHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordHistoryInput, UserUncheckedUpdateWithoutPasswordHistoryInput>
  }

  export type UserUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutPasswordChangeLogInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutPasswordChangeLogInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutPasswordChangeLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordChangeLogInput, UserUncheckedCreateWithoutPasswordChangeLogInput>
  }

  export type UserUpsertWithoutPasswordChangeLogInput = {
    update: XOR<UserUpdateWithoutPasswordChangeLogInput, UserUncheckedUpdateWithoutPasswordChangeLogInput>
    create: XOR<UserCreateWithoutPasswordChangeLogInput, UserUncheckedCreateWithoutPasswordChangeLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordChangeLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordChangeLogInput, UserUncheckedUpdateWithoutPasswordChangeLogInput>
  }

  export type UserUpdateWithoutPasswordChangeLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordChangeLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutFailedLoginsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutFailedLoginsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutFailedLoginsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFailedLoginsInput, UserUncheckedCreateWithoutFailedLoginsInput>
  }

  export type UserUpsertWithoutFailedLoginsInput = {
    update: XOR<UserUpdateWithoutFailedLoginsInput, UserUncheckedUpdateWithoutFailedLoginsInput>
    create: XOR<UserCreateWithoutFailedLoginsInput, UserUncheckedCreateWithoutFailedLoginsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFailedLoginsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFailedLoginsInput, UserUncheckedUpdateWithoutFailedLoginsInput>
  }

  export type UserUpdateWithoutFailedLoginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFailedLoginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutCreatedEventsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedEventsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedEventsInput, UserUncheckedCreateWithoutCreatedEventsInput>
  }

  export type UserCreateWithoutUpdatedEventsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedEventsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedEventsInput, UserUncheckedCreateWithoutUpdatedEventsInput>
  }

  export type ProjectCreateWithoutEventsInput = {
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedProjectsInput
    createdBy: UserCreateNestedOneWithoutCreatedProjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedProjectsInput
    reports?: ReportCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEventsInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
  }

  export type ReportCreateWithoutEventsInput = {
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: UserCreateNestedOneWithoutApprovedReportsInput
    createdBy: UserCreateNestedOneWithoutCreatedReportsInput
    project?: ProjectCreateNestedOneWithoutReportsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedReportsInput
  }

  export type ReportUncheckedCreateWithoutEventsInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    projectId?: number | null
  }

  export type ReportCreateOrConnectWithoutEventsInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutEventsInput, ReportUncheckedCreateWithoutEventsInput>
  }

  export type UserUpsertWithoutCreatedEventsInput = {
    update: XOR<UserUpdateWithoutCreatedEventsInput, UserUncheckedUpdateWithoutCreatedEventsInput>
    create: XOR<UserCreateWithoutCreatedEventsInput, UserUncheckedCreateWithoutCreatedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedEventsInput, UserUncheckedUpdateWithoutCreatedEventsInput>
  }

  export type UserUpdateWithoutCreatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedEventsInput = {
    update: XOR<UserUpdateWithoutUpdatedEventsInput, UserUncheckedUpdateWithoutUpdatedEventsInput>
    create: XOR<UserCreateWithoutUpdatedEventsInput, UserUncheckedCreateWithoutUpdatedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedEventsInput, UserUncheckedUpdateWithoutUpdatedEventsInput>
  }

  export type UserUpdateWithoutUpdatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ProjectUpsertWithoutEventsInput = {
    update: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
    create: XOR<ProjectCreateWithoutEventsInput, ProjectUncheckedCreateWithoutEventsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEventsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEventsInput, ProjectUncheckedUpdateWithoutEventsInput>
  }

  export type ProjectUpdateWithoutEventsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedProjectsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedProjectsNestedInput
    reports?: ReportUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ReportUpsertWithoutEventsInput = {
    update: XOR<ReportUpdateWithoutEventsInput, ReportUncheckedUpdateWithoutEventsInput>
    create: XOR<ReportCreateWithoutEventsInput, ReportUncheckedCreateWithoutEventsInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutEventsInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutEventsInput, ReportUncheckedUpdateWithoutEventsInput>
  }

  export type ReportUpdateWithoutEventsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedReportsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
    project?: ProjectUpdateOneWithoutReportsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LocationCreateWithoutInstitutionInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type LocationUncheckedCreateWithoutInstitutionInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type LocationCreateOrConnectWithoutInstitutionInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput>
  }

  export type LocationCreateManyInstitutionInputEnvelope = {
    data: LocationCreateManyInstitutionInput | LocationCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutInstitutionInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseCreateNestedManyWithoutResponderBeneficiaryInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutInstitutionInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutInstitutionInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput>
  }

  export type BeneficiaryCreateManyInstitutionInputEnvelope = {
    data: BeneficiaryCreateManyInstitutionInput | BeneficiaryCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedInstitutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInstitutionsInput, UserUncheckedCreateWithoutCreatedInstitutionsInput>
  }

  export type UserCreateWithoutUpdatedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedInstitutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedInstitutionsInput, UserUncheckedCreateWithoutUpdatedInstitutionsInput>
  }

  export type UserCreateWithoutApprovedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovedInstitutionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovedInstitutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedInstitutionsInput, UserUncheckedCreateWithoutApprovedInstitutionsInput>
  }

  export type LocationUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutInstitutionInput, LocationUncheckedUpdateWithoutInstitutionInput>
    create: XOR<LocationCreateWithoutInstitutionInput, LocationUncheckedCreateWithoutInstitutionInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutInstitutionInput, LocationUncheckedUpdateWithoutInstitutionInput>
  }

  export type LocationUpdateManyWithWhereWithoutInstitutionInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    locationName?: StringNullableFilter<"Location"> | string | null
    latitude?: FloatNullableFilter<"Location"> | number | null
    longitude?: FloatNullableFilter<"Location"> | number | null
    institutionId?: StringFilter<"Location"> | string
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutInstitutionInput, BeneficiaryUncheckedUpdateWithoutInstitutionInput>
    create: XOR<BeneficiaryCreateWithoutInstitutionInput, BeneficiaryUncheckedCreateWithoutInstitutionInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutInstitutionInput, BeneficiaryUncheckedUpdateWithoutInstitutionInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutInstitutionInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type UserUpsertWithoutCreatedInstitutionsInput = {
    update: XOR<UserUpdateWithoutCreatedInstitutionsInput, UserUncheckedUpdateWithoutCreatedInstitutionsInput>
    create: XOR<UserCreateWithoutCreatedInstitutionsInput, UserUncheckedCreateWithoutCreatedInstitutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInstitutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInstitutionsInput, UserUncheckedUpdateWithoutCreatedInstitutionsInput>
  }

  export type UserUpdateWithoutCreatedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedInstitutionsInput = {
    update: XOR<UserUpdateWithoutUpdatedInstitutionsInput, UserUncheckedUpdateWithoutUpdatedInstitutionsInput>
    create: XOR<UserCreateWithoutUpdatedInstitutionsInput, UserUncheckedCreateWithoutUpdatedInstitutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedInstitutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedInstitutionsInput, UserUncheckedUpdateWithoutUpdatedInstitutionsInput>
  }

  export type UserUpdateWithoutUpdatedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutApprovedInstitutionsInput = {
    update: XOR<UserUpdateWithoutApprovedInstitutionsInput, UserUncheckedUpdateWithoutApprovedInstitutionsInput>
    create: XOR<UserCreateWithoutApprovedInstitutionsInput, UserUncheckedCreateWithoutApprovedInstitutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedInstitutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedInstitutionsInput, UserUncheckedUpdateWithoutApprovedInstitutionsInput>
  }

  export type UserUpdateWithoutApprovedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type InstitutionCreateWithoutLocationsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaries?: BeneficiaryCreateNestedManyWithoutInstitutionInput
    createdBy: UserCreateNestedOneWithoutCreatedInstitutionsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedInstitutionsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedInstitutionsInput
  }

  export type InstitutionUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutLocationsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutLocationsInput, InstitutionUncheckedCreateWithoutLocationsInput>
  }

  export type InstitutionUpsertWithoutLocationsInput = {
    update: XOR<InstitutionUpdateWithoutLocationsInput, InstitutionUncheckedUpdateWithoutLocationsInput>
    create: XOR<InstitutionCreateWithoutLocationsInput, InstitutionUncheckedCreateWithoutLocationsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutLocationsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutLocationsInput, InstitutionUncheckedUpdateWithoutLocationsInput>
  }

  export type InstitutionUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaries?: BeneficiaryUpdateManyWithoutInstitutionNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedInstitutionsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type MessageCreateWithoutBeneficiaryInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedMessagesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMessagesInput
    approver?: UserCreateNestedOneWithoutApprovedMessagesInput
    responses?: ResponseCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutBeneficiaryInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    approvedById?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutBeneficiaryInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput>
  }

  export type MessageCreateManyBeneficiaryInputEnvelope = {
    data: MessageCreateManyBeneficiaryInput | MessageCreateManyBeneficiaryInput[]
    skipDuplicates?: boolean
  }

  export type ResponseCreateWithoutResponderBeneficiaryInput = {
    id?: string
    responderType?: $Enums.ResponderType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutResponsesInput
    responderUser?: UserCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutResponderBeneficiaryInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseCreateOrConnectWithoutResponderBeneficiaryInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput>
  }

  export type ResponseCreateManyResponderBeneficiaryInputEnvelope = {
    data: ResponseCreateManyResponderBeneficiaryInput | ResponseCreateManyResponderBeneficiaryInput[]
    skipDuplicates?: boolean
  }

  export type InstitutionCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutInstitutionInput
    createdBy: UserCreateNestedOneWithoutCreatedInstitutionsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedInstitutionsInput
    approvedBy?: UserCreateNestedOneWithoutApprovedInstitutionsInput
  }

  export type InstitutionUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutBeneficiariesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutBeneficiariesInput, InstitutionUncheckedCreateWithoutBeneficiariesInput>
  }

  export type UserCreateWithoutCreatedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedBeneficiariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBeneficiariesInput, UserUncheckedCreateWithoutCreatedBeneficiariesInput>
  }

  export type UserCreateWithoutUpdatedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedBeneficiariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedBeneficiariesInput, UserUncheckedCreateWithoutUpdatedBeneficiariesInput>
  }

  export type UserCreateWithoutApprovedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovedBeneficiariesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovedBeneficiariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedBeneficiariesInput, UserUncheckedCreateWithoutApprovedBeneficiariesInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutBeneficiaryInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutBeneficiaryInput, MessageUncheckedUpdateWithoutBeneficiaryInput>
    create: XOR<MessageCreateWithoutBeneficiaryInput, MessageUncheckedCreateWithoutBeneficiaryInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutBeneficiaryInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutBeneficiaryInput, MessageUncheckedUpdateWithoutBeneficiaryInput>
  }

  export type MessageUpdateManyWithWhereWithoutBeneficiaryInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutBeneficiaryInput>
  }

  export type ResponseUpsertWithWhereUniqueWithoutResponderBeneficiaryInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutResponderBeneficiaryInput, ResponseUncheckedUpdateWithoutResponderBeneficiaryInput>
    create: XOR<ResponseCreateWithoutResponderBeneficiaryInput, ResponseUncheckedCreateWithoutResponderBeneficiaryInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutResponderBeneficiaryInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutResponderBeneficiaryInput, ResponseUncheckedUpdateWithoutResponderBeneficiaryInput>
  }

  export type ResponseUpdateManyWithWhereWithoutResponderBeneficiaryInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutResponderBeneficiaryInput>
  }

  export type InstitutionUpsertWithoutBeneficiariesInput = {
    update: XOR<InstitutionUpdateWithoutBeneficiariesInput, InstitutionUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<InstitutionCreateWithoutBeneficiariesInput, InstitutionUncheckedCreateWithoutBeneficiariesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutBeneficiariesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutBeneficiariesInput, InstitutionUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type InstitutionUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutInstitutionNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedInstitutionsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserUpsertWithoutCreatedBeneficiariesInput = {
    update: XOR<UserUpdateWithoutCreatedBeneficiariesInput, UserUncheckedUpdateWithoutCreatedBeneficiariesInput>
    create: XOR<UserCreateWithoutCreatedBeneficiariesInput, UserUncheckedCreateWithoutCreatedBeneficiariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBeneficiariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBeneficiariesInput, UserUncheckedUpdateWithoutCreatedBeneficiariesInput>
  }

  export type UserUpdateWithoutCreatedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedBeneficiariesInput = {
    update: XOR<UserUpdateWithoutUpdatedBeneficiariesInput, UserUncheckedUpdateWithoutUpdatedBeneficiariesInput>
    create: XOR<UserCreateWithoutUpdatedBeneficiariesInput, UserUncheckedCreateWithoutUpdatedBeneficiariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedBeneficiariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedBeneficiariesInput, UserUncheckedUpdateWithoutUpdatedBeneficiariesInput>
  }

  export type UserUpdateWithoutUpdatedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutApprovedBeneficiariesInput = {
    update: XOR<UserUpdateWithoutApprovedBeneficiariesInput, UserUncheckedUpdateWithoutApprovedBeneficiariesInput>
    create: XOR<UserCreateWithoutApprovedBeneficiariesInput, UserUncheckedCreateWithoutApprovedBeneficiariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedBeneficiariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedBeneficiariesInput, UserUncheckedUpdateWithoutApprovedBeneficiariesInput>
  }

  export type UserUpdateWithoutApprovedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type MessageCreateWithoutResponsesInput = {
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedMessagesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMessagesInput
    approver?: UserCreateNestedOneWithoutApprovedMessagesInput
    beneficiary?: BeneficiaryCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutResponsesInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
  }

  export type MessageCreateOrConnectWithoutResponsesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutResponsesInput, MessageUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutResponsesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutResponsesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
  }

  export type BeneficiaryCreateWithoutResponsesInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    messages?: MessageCreateNestedManyWithoutBeneficiaryInput
    institution?: InstitutionCreateNestedOneWithoutBeneficiariesInput
    createdBy: UserCreateNestedOneWithoutCreatedBeneficiariesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBeneficiariesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutResponsesInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutResponsesInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutResponsesInput, BeneficiaryUncheckedCreateWithoutResponsesInput>
  }

  export type MessageUpsertWithoutResponsesInput = {
    update: XOR<MessageUpdateWithoutResponsesInput, MessageUncheckedUpdateWithoutResponsesInput>
    create: XOR<MessageCreateWithoutResponsesInput, MessageUncheckedCreateWithoutResponsesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutResponsesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutResponsesInput, MessageUncheckedUpdateWithoutResponsesInput>
  }

  export type MessageUpdateWithoutResponsesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedMessagesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMessagesNestedInput
    approver?: UserUpdateOneWithoutApprovedMessagesNestedInput
    beneficiary?: BeneficiaryUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutResponsesInput = {
    update: XOR<UserUpdateWithoutResponsesInput, UserUncheckedUpdateWithoutResponsesInput>
    create: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponsesInput, UserUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type BeneficiaryUpsertWithoutResponsesInput = {
    update: XOR<BeneficiaryUpdateWithoutResponsesInput, BeneficiaryUncheckedUpdateWithoutResponsesInput>
    create: XOR<BeneficiaryCreateWithoutResponsesInput, BeneficiaryUncheckedCreateWithoutResponsesInput>
    where?: BeneficiaryWhereInput
  }

  export type BeneficiaryUpdateToOneWithWhereWithoutResponsesInput = {
    where?: BeneficiaryWhereInput
    data: XOR<BeneficiaryUpdateWithoutResponsesInput, BeneficiaryUncheckedUpdateWithoutResponsesInput>
  }

  export type BeneficiaryUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
  }

  export type UserCreateWithoutCreatedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCreatedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCreatedFaqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFaqsInput, UserUncheckedCreateWithoutCreatedFaqsInput>
  }

  export type UserCreateWithoutUpdatedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    approvedFaqs?: FAQCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    approvedFaqs?: FAQUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedFaqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedFaqsInput, UserUncheckedCreateWithoutUpdatedFaqsInput>
  }

  export type UserCreateWithoutApprovedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    approvedMessages?: MessageCreateNestedManyWithoutApproverInput
    createdMessages?: MessageCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutApprovedFaqsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    username: string
    password: string
    email?: string | null
    image?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    about?: string | null
    lastLogin?: Date | string | null
    loginStatus?: $Enums.LoginStatus
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    passwordHistory?: PasswordHistoryUncheckedCreateNestedManyWithoutUserInput
    passwordChangeLog?: PasswordChangeLogUncheckedCreateNestedManyWithoutUserInput
    failedLogins?: FailedLoginAttemptUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    approvedMessages?: MessageUncheckedCreateNestedManyWithoutApproverInput
    createdMessages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    updatedMessages?: MessageUncheckedCreateNestedManyWithoutUpdatedByInput
    responses?: ResponseUncheckedCreateNestedManyWithoutResponderUserInput
    approvedProjects?: ProjectUncheckedCreateNestedManyWithoutApprovedByInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedProjects?: ProjectUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedReports?: ReportUncheckedCreateNestedManyWithoutApprovedByInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatedByInput
    updatedReports?: ReportUncheckedCreateNestedManyWithoutUpdatedByInput
    createdEvents?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    updatedEvents?: EventUncheckedCreateNestedManyWithoutUpdatedByInput
    createdBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedBeneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutApprovedByInput
    createdInstitutions?: InstitutionUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedInstitutions?: InstitutionUncheckedCreateNestedManyWithoutApprovedByInput
    createdFaqs?: FAQUncheckedCreateNestedManyWithoutCreatedByInput
    updatedFaqs?: FAQUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutApprovedFaqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedFaqsInput, UserUncheckedCreateWithoutApprovedFaqsInput>
  }

  export type UserUpsertWithoutCreatedFaqsInput = {
    update: XOR<UserUpdateWithoutCreatedFaqsInput, UserUncheckedUpdateWithoutCreatedFaqsInput>
    create: XOR<UserCreateWithoutCreatedFaqsInput, UserUncheckedCreateWithoutCreatedFaqsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFaqsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFaqsInput, UserUncheckedUpdateWithoutCreatedFaqsInput>
  }

  export type UserUpdateWithoutCreatedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutUpdatedFaqsInput = {
    update: XOR<UserUpdateWithoutUpdatedFaqsInput, UserUncheckedUpdateWithoutUpdatedFaqsInput>
    create: XOR<UserCreateWithoutUpdatedFaqsInput, UserUncheckedCreateWithoutUpdatedFaqsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedFaqsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedFaqsInput, UserUncheckedUpdateWithoutUpdatedFaqsInput>
  }

  export type UserUpdateWithoutUpdatedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    approvedFaqs?: FAQUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedFaqs?: FAQUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutApprovedFaqsInput = {
    update: XOR<UserUpdateWithoutApprovedFaqsInput, UserUncheckedUpdateWithoutApprovedFaqsInput>
    create: XOR<UserCreateWithoutApprovedFaqsInput, UserUncheckedCreateWithoutApprovedFaqsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedFaqsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedFaqsInput, UserUncheckedUpdateWithoutApprovedFaqsInput>
  }

  export type UserUpdateWithoutApprovedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    about?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginStatus?: EnumLoginStatusFieldUpdateOperationsInput | $Enums.LoginStatus
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHistory?: PasswordHistoryUncheckedUpdateManyWithoutUserNestedInput
    passwordChangeLog?: PasswordChangeLogUncheckedUpdateManyWithoutUserNestedInput
    failedLogins?: FailedLoginAttemptUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    approvedMessages?: MessageUncheckedUpdateManyWithoutApproverNestedInput
    createdMessages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedMessages?: MessageUncheckedUpdateManyWithoutUpdatedByNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderUserNestedInput
    approvedProjects?: ProjectUncheckedUpdateManyWithoutApprovedByNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedProjects?: ProjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedReports?: ReportUncheckedUpdateManyWithoutApprovedByNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedReports?: ReportUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdEvents?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedEvents?: EventUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedBeneficiaries?: BeneficiaryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdInstitutions?: InstitutionUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInstitutions?: InstitutionUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedInstitutions?: InstitutionUncheckedUpdateManyWithoutApprovedByNestedInput
    createdFaqs?: FAQUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedFaqs?: FAQUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type ReportCreateManyProjectInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type EventCreateManyProjectInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    reportId?: number | null
  }

  export type ReportUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedReportsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedReportsNestedInput
    events?: EventUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUpdateWithoutProjectInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedEventsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedEventsNestedInput
    report?: ReportUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ResponseCreateManyMessageInput = {
    id?: string
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responderUser?: UserUpdateOneWithoutResponsesNestedInput
    responderBeneficiary?: BeneficiaryUpdateOneWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyReportInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    updatedById: string
    projectId?: number | null
  }

  export type EventUpdateWithoutReportInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedEventsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedEventsNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PasswordHistoryCreateManyUserInput = {
    id?: string
    passwordHash: string
    createdAt?: Date | string
  }

  export type PasswordChangeLogCreateManyUserInput = {
    id?: string
    changedBy?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type FailedLoginAttemptCreateManyUserInput = {
    id?: string
    ip?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    startedAt?: Date | string
    lastSeenAt?: Date | string
    endedAt?: Date | string | null
    ip?: string | null
    userAgent?: string | null
    active?: boolean
  }

  export type MessageCreateManyApproverInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    beneficiaryId?: string | null
  }

  export type MessageCreateManyCreatedByInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
  }

  export type MessageCreateManyUpdatedByInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    approvedById?: string | null
    beneficiaryId?: string | null
  }

  export type ResponseCreateManyResponderUserInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderBeneficiaryId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyApprovedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
  }

  export type ProjectCreateManyCreatedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type ProjectCreateManyUpdatedByInput = {
    id?: number
    title: string
    slug: string
    content: JsonNullValueInput | InputJsonValue
    images?: ProjectCreateimagesInput | string[]
    projectStatus: $Enums.Status
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
  }

  export type ReportCreateManyApprovedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
    projectId?: number | null
  }

  export type ReportCreateManyCreatedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
    projectId?: number | null
  }

  export type ReportCreateManyUpdatedByInput = {
    id?: number
    title: string
    slug: string
    images?: ReportCreateimagesInput | string[]
    files?: ReportCreatefilesInput | string[]
    publishStatus?: $Enums.PublishStatus
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
    projectId?: number | null
  }

  export type EventCreateManyCreatedByInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    updatedById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type EventCreateManyUpdatedByInput = {
    id?: number
    slug: string
    eventTitle: string
    eventDescription: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: string | null
    eventBanner: string
    eventImages?: EventCreateeventImagesInput | string[]
    eventFile: string
    eventStartDate: Date | string
    eventEndDate: Date | string
    eventTags?: EventCreateeventTagsInput | string[]
    eventStatus?: $Enums.EventStatus
    publishStatus?: $Enums.PublishStatus
    eventAttendance?: $Enums.AttendanceType
    maxAttendees?: number | null
    accessCount?: number
    downloadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdById: string
    projectId?: number | null
    reportId?: number | null
  }

  export type BeneficiaryCreateManyCreatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    updatedById?: string | null
    approvedById?: string | null
  }

  export type BeneficiaryCreateManyUpdatedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    approvedById?: string | null
  }

  export type BeneficiaryCreateManyApprovedByInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    institutionId?: string | null
    createdById: string
    updatedById?: string | null
  }

  export type InstitutionCreateManyCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type InstitutionCreateManyUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById?: string | null
  }

  export type InstitutionCreateManyApprovedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    logo?: string | null
    institutionImages?: InstitutionCreateinstitutionImagesInput | string[]
    headName?: string | null
    institutionType: $Enums.InstitutionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById?: string | null
  }

  export type FAQCreateManyCreatedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    approvedById: string
  }

  export type FAQCreateManyUpdatedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    approvedById: string
  }

  export type FAQCreateManyApprovedByInput = {
    id?: number
    question: JsonNullValueInput | InputJsonValue
    answer: JsonNullValueInput | InputJsonValue
    category?: $Enums.FAQCategory
    publishStatus?: $Enums.PublishStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
  }

  export type PasswordHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedLoginAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutApproverInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedMessagesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMessagesNestedInput
    beneficiary?: BeneficiaryUpdateOneWithoutMessagesNestedInput
    responses?: ResponseUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutCreatedByInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutUpdatedMessagesNestedInput
    approver?: UserUpdateOneWithoutApprovedMessagesNestedInput
    beneficiary?: BeneficiaryUpdateOneWithoutMessagesNestedInput
    responses?: ResponseUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutUpdatedByInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedMessagesNestedInput
    approver?: UserUpdateOneWithoutApprovedMessagesNestedInput
    beneficiary?: BeneficiaryUpdateOneWithoutMessagesNestedInput
    responses?: ResponseUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseUpdateWithoutResponderUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutResponsesNestedInput
    responderBeneficiary?: BeneficiaryUpdateOneWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutResponderUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUncheckedUpdateManyWithoutResponderUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderBeneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutApprovedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedProjectsNestedInput
    reports?: ReportUpdateManyWithoutProjectNestedInput
    events?: EventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutProjectNestedInput
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedProjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedProjectsNestedInput
    reports?: ReportUpdateManyWithoutProjectNestedInput
    events?: EventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutProjectNestedInput
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutUpdatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedProjectsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    reports?: ReportUpdateManyWithoutProjectNestedInput
    events?: EventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutProjectNestedInput
    events?: EventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    images?: ProjectUpdateimagesInput | string[]
    projectStatus?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutApprovedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
    project?: ProjectUpdateOneWithoutReportsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedReportsNestedInput
    events?: EventUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedReportsNestedInput
    project?: ProjectUpdateOneWithoutReportsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedReportsNestedInput
    events?: EventUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUpdateWithoutUpdatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: UserUpdateOneWithoutApprovedReportsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
    project?: ProjectUpdateOneWithoutReportsNestedInput
    events?: EventUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    images?: ReportUpdateimagesInput | string[]
    files?: ReportUpdatefilesInput | string[]
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUpdateWithoutCreatedByInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedEventsNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
    report?: ReportUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUpdateWithoutUpdatedByInput = {
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedEventsNestedInput
    project?: ProjectUpdateOneWithoutEventsNestedInput
    report?: ReportUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    eventTitle?: StringFieldUpdateOperationsInput | string
    eventDescription?: JsonNullValueInput | InputJsonValue
    eventDetails?: NullableJsonNullValueInput | InputJsonValue
    eventLocation?: NullableStringFieldUpdateOperationsInput | string | null
    eventBanner?: StringFieldUpdateOperationsInput | string
    eventImages?: EventUpdateeventImagesInput | string[]
    eventFile?: StringFieldUpdateOperationsInput | string
    eventStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventTags?: EventUpdateeventTagsInput | string[]
    eventStatus?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    eventAttendance?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    maxAttendees?: NullableIntFieldUpdateOperationsInput | number | null
    accessCount?: IntFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    reportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BeneficiaryUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BeneficiaryUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BeneficiaryUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    institution?: InstitutionUpdateOneWithoutBeneficiariesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstitutionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutInstitutionNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedInstitutionsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstitutionUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutInstitutionNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstitutionUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutInstitutionNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInstitutionsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedInstitutionsNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutInstitutionNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    institutionImages?: InstitutionUpdateinstitutionImagesInput | string[]
    headName?: NullableStringFieldUpdateOperationsInput | string | null
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FAQUpdateWithoutCreatedByInput = {
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedFaqsNestedInput
    approvedBy?: UserUpdateOneRequiredWithoutApprovedFaqsNestedInput
  }

  export type FAQUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUpdateWithoutUpdatedByInput = {
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedFaqsNestedInput
    approvedBy?: UserUpdateOneRequiredWithoutApprovedFaqsNestedInput
  }

  export type FAQUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUpdateWithoutApprovedByInput = {
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedFaqsNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedFaqsNestedInput
  }

  export type FAQUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: JsonNullValueInput | InputJsonValue
    answer?: JsonNullValueInput | InputJsonValue
    category?: EnumFAQCategoryFieldUpdateOperationsInput | $Enums.FAQCategory
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateManyInstitutionInput = {
    id?: string
    locationName?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type BeneficiaryCreateManyInstitutionInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    images?: BeneficiaryCreateimagesInput | string[]
    gender: $Enums.GenderType
    email?: string | null
    phone?: string | null
    dateOfBirth: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    beneficiaryStatus?: $Enums.PublishStatus
    createdById: string
    updatedById?: string | null
    approvedById?: string | null
  }

  export type LocationUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LocationUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LocationUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BeneficiaryUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messages?: MessageUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUpdateManyWithoutResponderBeneficiaryNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBeneficiariesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBeneficiariesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutBeneficiaryNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutResponderBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    images?: BeneficiaryUpdateimagesInput | string[]
    gender?: EnumGenderTypeFieldUpdateOperationsInput | $Enums.GenderType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyBeneficiaryInput = {
    id?: number
    title?: string | null
    affiliated?: string | null
    name?: string | null
    content: JsonNullValueInput | InputJsonValue
    nameImageUrl?: string | null
    messageImageUrl?: string | null
    messageStatus?: $Enums.PublishStatus
    messageCategory?: $Enums.MessageCategory
    senderEmail?: string | null
    senderIp?: string | null
    allowResponses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    approvedById?: string | null
  }

  export type ResponseCreateManyResponderBeneficiaryInput = {
    id?: string
    messageId: number
    responderType?: $Enums.ResponderType
    responderUserId?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutBeneficiaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedMessagesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMessagesNestedInput
    approver?: UserUpdateOneWithoutApprovedMessagesNestedInput
    responses?: ResponseUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutBeneficiaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutBeneficiaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    affiliated?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    nameImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    messageStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    messageCategory?: EnumMessageCategoryFieldUpdateOperationsInput | $Enums.MessageCategory
    senderEmail?: NullableStringFieldUpdateOperationsInput | string | null
    senderIp?: NullableStringFieldUpdateOperationsInput | string | null
    allowResponses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseUpdateWithoutResponderBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutResponsesNestedInput
    responderUser?: UserUpdateOneWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutResponderBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUncheckedUpdateManyWithoutResponderBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
    responderType?: EnumResponderTypeFieldUpdateOperationsInput | $Enums.ResponderType
    responderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}