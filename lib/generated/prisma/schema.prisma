generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Consolidated messaging schema:
 * - Replaced BeneficiaryMessage, BeneficiaryRequest, BeneficiaryRequestResponse
 * with Message and Response.
 * - Message.messageKind tags origin/intent: beneficiary, request, system, external,
 * go_girls_ict_team, testimonial.
 * External = visitor; visitors can create Message but (for now) cannot create Responses.
 * - Response is used for replies and is authored by a User, a Beneficiary, or the System.
 * - Message.allowResponses toggles whether replies are allowed per-message (useful for external messages).
 * - Message.senderEmail / senderIp store visitor metadata when messageKind = external.
 */

model Project {
  id            Int           @id @default(autoincrement())
  title         String
  slug          String        @unique
  content       Json
  images        String[]
  projectStatus Status
  publishStatus PublishStatus @default(draft)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  createdById   String
  updatedById   String?
  approvedById  String?
  approvedBy    User?         @relation("ProjectApprovedBy", fields: [approvedById], references: [id])
  createdBy     User          @relation("ProjectCreatedBy", fields: [createdById], references: [id])
  updatedBy     User?         @relation("ProjectUpdatedBy", fields: [updatedById], references: [id])
  reports       Report[]
  events        Event[]
}

model HomePage {
  id         Int      @id @default(autoincrement())
  heroVideo  String
  vision     String
  mission    String
  focus      String
  coreValues String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

enum MessageCategory {
  beneficiary
  request
  system
  external
  go_girls_ict_team
  testimonial
}

model Message {
  id              Int             @id @default(autoincrement())
  title           String?
  affiliated      String?
  name            String?
  content         Json
  nameImageUrl    String?
  messageImageUrl String?
  messageStatus   PublishStatus   @default(draft)
  messageCategory MessageCategory @default(external)

  // Visitor metadata (useful when messageCategory = external)
  senderEmail String?
  senderIp    String?

  // Toggle whether replies are allowed for this message (default true).
  allowResponses Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optional relations: messages can be created/updated/approved by a User (or be system/external)
  createdById  String?
  updatedById  String?
  approvedById String?

  createdBy User? @relation("MessageCreatedBy", fields: [createdById], references: [id])
  updatedBy User? @relation("MessageUpdatedBy", fields: [updatedById], references: [id])
  approver  User? @relation("MessageApprovedBy", fields: [approvedById], references: [id])

  // if this message is tied to a Beneficiary (testimonial, request), point to them
  beneficiaryId String?
  beneficiary   Beneficiary? @relation("BeneficiaryMessages", fields: [beneficiaryId], references: [id])

  // replies to this message
  responses Response[]

  @@map("Message")
}

model Report {
  id            Int           @id @default(autoincrement())
  title         String
  slug          String        @unique
  images        String[]
  files         String[]
  publishStatus PublishStatus @default(draft)
  accessCount   Int           @default(0)
  downloadCount Int           @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  createdById   String
  updatedById   String?
  approvedById  String?
  projectId     Int?
  approvedBy    User?         @relation("ReportApprovedBy", fields: [approvedById], references: [id])
  createdBy     User          @relation("ReportCreatedBy", fields: [createdById], references: [id])
  project       Project?      @relation(fields: [projectId], references: [id])
  updatedBy     User?         @relation("ReportUpdatedBy", fields: [updatedById], references: [id])
  events        Event[]
}

// Prisma schema: User + user-related models (PasswordHistory, PasswordChangeLog,
// FailedLoginAttempt, Session) â€” with relation fields re-introduced on User model.

enum Role {
  super // Full control, including creating and deleting users
  admin // Broad management, except creating and deleting users
  moderator // can manage and moderate content
  beneficiary // can manage their own profile and requests
  guest // can only view published content
}

enum LoginStatus {
  active
  inactive
}

model User {
  id        String   @id @default(cuid())
  firstName String?
  lastName  String?
  username  String   @unique
  password  String
  email     String?  @unique
  image     String?
  role      Role     @default(guest)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // New profile & login fields
  about       String? // brief biography
  lastLogin   DateTime? // last successful login time
  loginStatus LoginStatus @default(inactive) // active | inactive

  // Rate limit / lockout helpers
  failedLoginCount Int       @default(0)
  lockedUntil      DateTime?

  // User-centric auth/session/history relations
  passwordHistory   PasswordHistory[]
  passwordChangeLog PasswordChangeLog[]
  failedLogins      FailedLoginAttempt[]
  sessions          Session[]

  // ----- domain relations  -----
  // Messages
  approvedMessages Message[] @relation("MessageApprovedBy")
  createdMessages  Message[] @relation("MessageCreatedBy")
  updatedMessages  Message[] @relation("MessageUpdatedBy")

  // Responses authored by Users
  responses Response[] @relation("UserResponses")

  // Projects
  approvedProjects Project[] @relation("ProjectApprovedBy")
  createdProjects  Project[] @relation("ProjectCreatedBy")
  updatedProjects  Project[] @relation("ProjectUpdatedBy")

  // Reports
  approvedReports Report[] @relation("ReportApprovedBy")
  createdReports  Report[] @relation("ReportCreatedBy")
  updatedReports  Report[] @relation("ReportUpdatedBy")

  // Events
  createdEvents Event[] @relation("EventCreatedBy")
  updatedEvents Event[] @relation("EventUpdatedBy")

  // Beneficiaries
  createdBeneficiaries  Beneficiary[] @relation("BeneficiaryCreatedBy")
  updatedBeneficiaries  Beneficiary[] @relation("BeneficiaryUpdatedBy")
  approvedBeneficiaries Beneficiary[] @relation("BeneficiaryApprovedBy")

  // Institutions
  createdInstitutions  Institution[] @relation("InstitutionCreatedBy")
  updatedInstitutions  Institution[] @relation("InstitutionUpdatedBy")
  approvedInstitutions Institution[] @relation("InstitutionApprovedBy")

  // FAQs
  createdFaqs  FAQ[] @relation("FAQCreatedBy")
  updatedFaqs  FAQ[] @relation("FAQUpdatedBy")
  approvedFaqs FAQ[] @relation("FAQApprovedBy")
}

model PasswordHistory {
  id           String   @id @default(cuid())
  user         User     @relation(fields: [userId], references: [id])
  userId       String
  passwordHash String
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
}

model PasswordChangeLog {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  changedBy String? // userId of admin / null if self
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model FailedLoginAttempt {
  id        String   @id @default(cuid())
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  ip        String?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([ip, createdAt])
}

model Session {
  id         String    @id @default(cuid())
  user       User      @relation(fields: [userId], references: [id])
  userId     String
  startedAt  DateTime  @default(now())
  lastSeenAt DateTime  @default(now())
  endedAt    DateTime?
  ip         String?
  userAgent  String?
  active     Boolean   @default(true)

  @@index([userId, startedAt])
  @@index([active])
}

enum Status {
  active
  completed
  paused
}

enum PublishStatus {
  draft
  published
}

model Event {
  id               Int      @id @default(autoincrement())
  slug             String   @unique
  eventTitle       String
  eventDescription Json
  eventDetails     Json?
  eventLocation    String?
  eventBanner      String
  eventImages      String[]
  eventFile        String

  eventStartDate DateTime
  eventEndDate   DateTime

  eventTags       String[]
  eventStatus     EventStatus    @default(pending)
  publishStatus   PublishStatus  @default(draft)
  eventAttendance AttendanceType @default(public)
  maxAttendees    Int?

  accessCount   Int @default(0)
  downloadCount Int @default(0)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  createdById String
  updatedById String

  createdBy User @relation("EventCreatedBy", fields: [createdById], references: [id])
  updatedBy User @relation("EventUpdatedBy", fields: [updatedById], references: [id])

  projectId Int?
  project   Project? @relation(fields: [projectId], references: [id])

  reportId Int?
  report   Report? @relation(fields: [reportId], references: [id])
}

enum EventStatus {
  pending
  ongoing
  completed
  paused
}

enum AttendanceType {
  public
  registration_required
}

// YouTube Videos
model Video {
  id          String   @id // YouTube video ID
  title       String
  description String
  thumbnail   String
  publishedAt DateTime
  viewCount   Int?
  likeCount   Int?
  duration    String
  fetchedAt   DateTime @default(now()) // When this video was last fetched from YouTube
}

model YouTubeCacheMeta {
  id          Int      @id @default(1)
  lastFetched DateTime
}

// Institution Model
enum InstitutionType {
  education
  faith_based_organization
  local_community
  ngo
  government
  other
}

model Institution {
  id                String          @id @default(cuid())
  name              String
  email             String?         @unique
  phone             String?         @unique
  logo              String?
  institutionImages String[]
  headName          String?
  institutionType   InstitutionType
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  locations         Location[]
  beneficiaries     Beneficiary[]

  createdById  String
  updatedById  String?
  approvedById String?

  createdBy  User  @relation("InstitutionCreatedBy", fields: [createdById], references: [id])
  updatedBy  User? @relation("InstitutionUpdatedBy", fields: [updatedById], references: [id])
  approvedBy User? @relation("InstitutionApprovedBy", fields: [approvedById], references: [id])
}

// Model for representing a location (name, lat, lng)
model Location {
  id            String      @id @default(cuid())
  locationName  String?
  latitude      Float?
  longitude     Float?
  institutionId String
  institution   Institution @relation(fields: [institutionId], references: [id])
}

// Beneficiary model
enum GenderType {
  male
  female
}

model Beneficiary {
  id                String        @id @default(cuid())
  firstName         String
  lastName          String
  image             String?
  images            String[]
  gender            GenderType
  email             String?       @unique
  phone             String?       @unique
  dateOfBirth       DateTime
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  beneficiaryStatus PublishStatus @default(draft)

  // unified messages and responses
  messages  Message[]  @relation("BeneficiaryMessages")
  responses Response[] @relation("BeneficiaryResponses")

  institutionId String?
  institution   Institution? @relation(fields: [institutionId], references: [id])

  createdById  String
  updatedById  String?
  approvedById String?

  createdBy  User  @relation("BeneficiaryCreatedBy", fields: [createdById], references: [id])
  updatedBy  User? @relation("BeneficiaryUpdatedBy", fields: [updatedById], references: [id])
  approvedBy User? @relation("BeneficiaryApprovedBy", fields: [approvedById], references: [id])
}

/**
 * ResponderType: external removed so visitors cannot author Responses.
 * Use application-level checks to ensure only users/beneficiaries/system create responses.
 */
enum ResponderType {
  user
  beneficiary
  system
}

model Response {
  id            String        @id @default(cuid())
  messageId     Int
  responderType ResponderType @default(user)

  // polymorphic responder fields (only one should be set; enforce at application level)
  responderUserId        String?
  responderBeneficiaryId String?

  content Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  message              Message      @relation(fields: [messageId], references: [id])
  responderUser        User?        @relation("UserResponses", fields: [responderUserId], references: [id])
  responderBeneficiary Beneficiary? @relation("BeneficiaryResponses", fields: [responderBeneficiaryId], references: [id])
}

model FAQ {
  id            Int           @id @default(autoincrement())
  question      Json
  answer        Json
  category      FAQCategory   @default(general)
  publishStatus PublishStatus @default(draft)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  createdById  String
  updatedById  String
  approvedById String

  createdBy  User @relation("FAQCreatedBy", fields: [createdById], references: [id])
  updatedBy  User @relation("FAQUpdatedBy", fields: [updatedById], references: [id])
  approvedBy User @relation("FAQApprovedBy", fields: [approvedById], references: [id])
}

enum FAQCategory {
  general
  beneficiaries
  institutions
  projects
  events
  reports
  technnology
  other
}

// #Facebook Posts
model FacebookPost {
  id           String   @id // Facebook post ID
  message      String?
  createdTime  DateTime
  permalinkUrl String
  fullPicture  String
  fetchedAt    DateTime @default(now())
}

model FacebookCacheMeta {
  id          Int      @id @default(1)
  lastFetched DateTime
}
